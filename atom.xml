<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kotlin</title>
  <subtitle>简洁、优雅，100% 兼容 Java</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.Kotliner.cn/"/>
  <updated>2017-05-22T02:30:56.906Z</updated>
  <id>http://www.Kotliner.cn/</id>
  
  <author>
    <name>Kotlin</name>
    <email>Kotlin@kotliner.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin：forEach也能break和continue</title>
    <link href="http://www.Kotliner.cn/2017/05/22/KotlinForEachBreakContinue/"/>
    <id>http://www.Kotliner.cn/2017/05/22/KotlinForEachBreakContinue/</id>
    <published>2017-05-22T02:30:56.906Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在BennyHuo的Kotlin裙里看到有人在讨论关于</p>
<blockquote>
<p>如何在forEach中跳出循环</p>
</blockquote>
<p>这样的问题。也就是说，他们想用forEach而不是for循环，因为这很fp，很洋气（我也喜欢），<br>但是他们又想使用break和continue，也就是普通的流程控制语句中的控制语句。</p>
<p>这很不fp，因为原本有filter是用于完成这个工作的，还有flapMap。BennyHuo在他发的文章里面也说的是这种方法。</p>
<p>filter很fp，但是会导致两次遍历，这样的话给人一股效率很低的赶脚。而Java8的Stream API就只会遍历一次，<br>而且很fp。但是它会有lambda对象的产生而且实现超复杂（我没看过，不清楚），而Kotlin的集合框架可是能inline掉lambda的，<br>少产生了多少对象啊，怎么能和辣鸡Java同流合污呢？</p>
<p>有人提到使用label return，比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(ags: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  (<span class="number">0.</span><span class="number">.100</span>).forEach &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="number">50</span> &lt;= it) <span class="keyword">return</span><span class="symbol">@forEach</span></div><div class="line">    println(it)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是他做了实验之后发现这玩意只能相当于continue，也就是说你只能跳出当前循环，然后还是会继续下一轮。</p>
<p>讲道理这个你仔细想想就可以发现。为了搞清楚其中的道理，我们自己实现一个forEach。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> Pair<span class="type">&lt;Int, Int&gt;</span>.<span class="title">forEach</span><span class="params">(block: (<span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> first..second) block.invoke(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后调用一下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair(<span class="number">1</span>, <span class="number">100</span>).forEach(::println)</div></pre></td></tr></table></figure>
<p>没毛病老铁。</p>
<p>然后你会发现，你在函数体内对block产生了(second - first)次调用，不论你怎么return，都只会跳出这个block，<br>它并不影响你之后继续调用这个block，也就是说这个for循环不受block行为的影响。</p>
<p>看起来无解了，那怎么办呢？</p>
<p>那么就让我来拯救你们吧。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(ags: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  run <span class="symbol">outside@</span> &#123;</div><div class="line">    (<span class="number">0.</span><span class="number">.20</span>).forEach <span class="symbol">inside@</span> &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="number">10</span> &lt;= it) <span class="keyword">return</span><span class="symbol">@outside</span></div><div class="line">      println(it)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译之后运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<p>呐，跳出去了。</p>
<p>把label的名字起的清真一点，就是这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">run <span class="symbol">breaking@</span> &#123;</div><div class="line">  (<span class="number">0.</span><span class="number">.20</span>).forEach <span class="symbol">continuing@</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="number">10</span> &lt;= it) <span class="keyword">return</span><span class="symbol">@breaking</span></div><div class="line">    println(it)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这是break，运行结果就上面那样。</p>
<p>下面这是continue，运行结果就是continue的效果。为了让效果表现的明显，我把println复制了一下，<br>分别在if前后，这样可以很清楚地看到效果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">run <span class="symbol">breaking@</span> &#123;</div><div class="line">  (<span class="number">0.</span><span class="number">.20</span>).forEach <span class="symbol">continuing@</span> &#123;</div><div class="line">    print(it)</div><div class="line">    <span class="keyword">if</span> (<span class="number">10</span> &lt;= it) <span class="keyword">return</span><span class="symbol">@continuing</span></div><div class="line">    println(it)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">00</div><div class="line">11</div><div class="line">22</div><div class="line">33</div><div class="line">44</div><div class="line">55</div><div class="line">66</div><div class="line">77</div><div class="line">88</div><div class="line">99</div><div class="line">1011121314151617181920</div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure>
<p>而且只进行了一次迭代，非常清真，效率看起来也比较高。</p>
<p>如何证明只有一次迭代？我使用jd-gui逆向了刚才的代码，结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_5Kt</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span></span></div><div class="line">  &#123;</div><div class="line">    Intrinsics.checkParameterIsNotNull(args, <span class="string">"args"</span>);</div><div class="line">    <span class="keyword">int</span> $i$a$<span class="number">1</span>$run;</div><div class="line">    Iterable $receiver$iv = (Iterable)<span class="keyword">new</span> IntRange(<span class="number">0</span>, <span class="number">20</span>);</div><div class="line">    <span class="keyword">int</span> $i$f$forEach;</div><div class="line">    <span class="keyword">for</span> (Iterator localIterator = $receiver$iv.iterator(); localIterator.hasNext();)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">int</span> element$iv = ((IntIterator)localIterator).nextInt();<span class="keyword">int</span> it = element$iv;</div><div class="line">      <span class="keyword">int</span> $i$a$<span class="number">1</span>$forEach;</div><div class="line">      System.out.print(it);</div><div class="line">      <span class="keyword">if</span> (<span class="number">10</span> &lt;= it) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      System.out.println(it);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>确实只有一次，而且jd-gui直接把我的行为反编译为break了。服不服？</p>
<p><strong>无fuck说</strong></p>
]]></content>
    
    <summary type="html">
    
      Kotlin forEach has breaking and continuing, too
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.Kotliner.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.Kotliner.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>成都 Kotlin 线下聚会报告及科技汇总</title>
    <link href="http://www.Kotliner.cn/2017/05/22/2017-5-13-KotlinMeetupChengDu/"/>
    <id>http://www.Kotliner.cn/2017/05/22/2017-5-13-KotlinMeetupChengDu/</id>
    <published>2017-05-22T02:30:56.890Z</published>
    <updated>2017-05-22T02:30:56.890Z</updated>
    
    <content type="html"><![CDATA[<p>上星期我组织了成都的一次主题为 Kotlin 的线下聚会（也可以说是沙龙），来的人不到十个，却代表了三代人啊。</p>
<h2 id="为何线下聚会"><a href="#为何线下聚会" class="headerlink" title="为何线下聚会"></a>为何线下聚会</h2><p>不知道</p>
<h2 id="活动内容"><a href="#活动内容" class="headerlink" title="活动内容"></a>活动内容</h2><p>早上 9:30 ~ 10:00 基本把成员接到。</p>
<p>上午大概的内容：</p>
<ol>
<li><em>千里冰封</em>聊 Kotlin DSL 的原理</li>
<li><em>CharlieJiang</em> 聊 Kotlin JNI 调用</li>
<li><em>CharlieJiang</em> 介绍项目 <a href="https://github.com/cqjjjzr/Laplacian" target="_blank" rel="external">Laplacian</a> ， JVM 音乐播放器内核</li>
<li><em>清水河学渣</em>介绍 Kotlin Web 开发</li>
<li><em>清水河学渣</em>介绍自己写的 IntelliJ 高亮插件 <a href="https://github.com/huoguangjin/MultiHighlight" target="_blank" rel="external">MultiHighlight</a></li>
<li>大家一起讨论 Kotlin 的花样玩法。</li>
</ol>
<p>然后午饭就在旁边一破地方吃的，<em>优格</em>还说他来过这地方（汗），吃到一半，<em>迎风尿，腿不抖</em>被公司召唤而去。<br><code>members.size.dec()</code>。</p>
<p>下午，<em>优格</em>拿出了他的<strong>任天堂 switch</strong>，然后一发而不可收拾。。</p>
<ul>
<li><em>清水河学渣</em>暴露身份，实际上是<strong>清水河学神</strong>。</li>
<li>有个挤牛奶的游戏，玩起来动作很像撸管</li>
<li>最年轻的<em>查理江</em>同学全程打守望先锋</li>
<li>大家都笑得像个孩子</li>
</ul>
<p>这次聚会我反正学到了新东西，很开心。希望别人也如此。</p>
<p>这里总结一下我觉得值得一提的聚会中聊到的科技。这两天我又有新发现，下次活动说。</p>
<h2 id="黑科技汇总"><a href="#黑科技汇总" class="headerlink" title="黑科技汇总"></a>黑科技汇总</h2><h3 id="假构造方法模拟-Factory"><a href="#假构造方法模拟-Factory" class="headerlink" title="假构造方法模拟 Factory"></a>假构造方法模拟 Factory</h3><p>（by 清水河学渣）</p>
<ul>
<li>重载 <code>companion object</code> 的操作符模仿构造方法，还能做到完全模拟 Factory ：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 直线，使用解析式表示</div><div class="line"> * ax + by + c = 0</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span>(<span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Int</span>, <span class="keyword">val</span> c: <span class="built_in">Int</span>) &#123;</div><div class="line"><span class="comment">//  constructor(point1: Pair&lt;Int, Int&gt;, point2: Pair&lt;Int, Int&gt;) : this()</span></div><div class="line"><span class="comment">// 上面这样写，通过两点计算 a b c 表达式会很复杂，可读性并不好（虽然我不觉得）</span></div><div class="line"><span class="comment">// 但是你必须在第一时间调用 primary constructor ，在此之前不能进行</span></div><div class="line"><span class="comment">// 任何变量声明或者流程控制</span></div><div class="line"><span class="comment">// 怎么办呢</span></div><div class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</div><div class="line">    <span class="comment">// 于是可以通过这个解决</span></div><div class="line">    <span class="comment">// 这个求 a b c 的写法其实并不优雅，只是为了展示例子</span></div><div class="line">    <span class="comment">// 这个方法调用起来和构造方法语法完全相同</span></div><div class="line">    <span class="comment">// 但是这样写，可以在调用构造方法之前进行一些流程控制或者变量声明</span></div><div class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(one: <span class="type">Pair</span>&lt;<span class="type">Int</span>, <span class="built_in">Int</span>&gt;, two: <span class="type">Pair</span>&lt;<span class="type">Int</span>, <span class="built_in">Int</span>&gt;)</span></span>: Line &#123;</div><div class="line">      <span class="keyword">val</span> a = two.second - one.second</div><div class="line">      <span class="keyword">val</span> b = one.first - two.first</div><div class="line">      <span class="keyword">val</span> c = two.first * one.second - one.first * two.second</div><div class="line">      <span class="keyword">return</span> Line(a, b, c)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = Line(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 调用构造方法</span></div><div class="line">  <span class="keyword">val</span> b = Line(Pair(<span class="number">1</span>, <span class="number">2</span>), Pair(<span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// 调用操作符重载</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="非常规函数的-JNI-声明"><a href="#非常规函数的-JNI-声明" class="headerlink" title="非常规函数的 JNI 声明"></a>非常规函数的 JNI 声明</h3><p>（by CharlieJiang）</p>
<ul>
<li>非常规函数的 JNI 声明，以及通过注解确保编译器不改名</li>
</ul>
<p>比如 getter setter 以及改名的函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> a: <span class="built_in">Int</span></div><div class="line">    external <span class="keyword">get</span></div><div class="line">    external <span class="keyword">set</span></div><div class="line"></div><div class="line">  <span class="meta">@JvmName(<span class="meta-string">"myNameIsVan"</span>)</span></div><div class="line">  external <span class="function"><span class="keyword">fun</span> <span class="title">myNameIsVan</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="JvmMultifileClass"><a href="#JvmMultifileClass" class="headerlink" title="JvmMultifileClass"></a>JvmMultifileClass</h3><p>（by 千里冰封）</p>
<ul>
<li>将多个文件的内容编译到同一个类里面</li>
</ul>
<p>文件 1：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file 1.kt</span></div><div class="line"><span class="meta">@file:JvmName</span>(<span class="string">"Fuck"</span>)</div><div class="line"><span class="meta">@file:JvmMultifileClass</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> shit = <span class="string">"fuck"</span></div><div class="line"><span class="keyword">val</span> fuck = <span class="string">"shit"</span></div></pre></td></tr></table></figure>
<p>文件 2：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file 2.kt</span></div><div class="line"><span class="meta">@file:JvmName</span>(<span class="string">"Fuck"</span>)</div><div class="line"><span class="meta">@file:JvmMultifileClass</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> GameObject.<span class="title">destroy</span><span class="params">()</span></span> &#123;</div><div class="line">  isAlive = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译之后只会生成一个类 ‘Fuck.class’ ，里面有 <code>shit fuck destroy</code> 三个成员。</p>
<h3 id="模拟-Null-safety"><a href="#模拟-Null-safety" class="headerlink" title="模拟 Null safety"></a>模拟 Null safety</h3><p>（by 千里冰封）</p>
<ul>
<li>代数数据类型模拟 Null safety</li>
</ul>
<p>这是个函数式编程的概念，这里用了 when+is 模拟模式匹配。</p>
<p>这个我在讲的时候代码写错了，后来我想到了原因，是因为没加泛型的协变。</p>
<p>关于我当时举的例子（用 ADT 处理除法的除数为 0 的情况），正确的代码是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Option</span>&lt;<span class="type">out T</span>&gt;</span>()</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Some</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> obj: T) : Option&lt;T&gt;()</div><div class="line"><span class="keyword">object</span> None : Option&lt;<span class="built_in">Nothing</span>&gt;()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">div</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : Option&lt;<span class="built_in">Int</span>&gt; =</div><div class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) None <span class="keyword">else</span> Some(a / b)</div></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> io = Scanner(System.`<span class="keyword">in</span>`)</div><div class="line">  <span class="keyword">val</span> res = div(io.nextInt(), io.nextInt())</div><div class="line">  println(<span class="keyword">when</span> (res) &#123;</div><div class="line">    <span class="keyword">is</span> Some -&gt; println(<span class="string">"result: <span class="subst">$&#123;res.obj&#125;</span>"</span>) <span class="comment">// smart cast</span></div><div class="line">    <span class="keyword">is</span> None -&gt; println(<span class="string">"nothing here"</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我觉得还行。</p>
<h2 id="三代人"><a href="#三代人" class="headerlink" title="三代人"></a>三代人</h2><p>两个 00 后，两个 80 后，三个 90 后，我感觉没有任何代沟，最后一起嗨起来。</p>
<p>也许这就是单纯吧.jpg</p>
<h2 id="集体照"><a href="#集体照" class="headerlink" title="集体照"></a>集体照</h2><p>随便 po 两张上来：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://coding.net/u/ice1000/p/Images/git/raw/master/blog-img/14/1.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://coding.net/u/ice1000/p/Images/git/raw/master/blog-img/14/2.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://coding.net/u/ice1000/p/Images/git/raw/master/blog-img/14/3.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<hr>
<p>如果你有兴趣加入我们，请直接关注公众号 Kotlin ，并且加 QQ 群：162452394 联系我们。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/arts/kotlin_group.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
    
    <summary type="html">
    
      kotlin event ChengDu
    
    </summary>
    
      <category term="线下活动" scheme="http://www.Kotliner.cn/categories/%E7%BA%BF%E4%B8%8B%E6%B4%BB%E5%8A%A8/"/>
    
    
      <category term="线下活动" scheme="http://www.Kotliner.cn/tags/%E7%BA%BF%E4%B8%8B%E6%B4%BB%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 一个很厉害的 DSL 写法</title>
    <link href="http://www.Kotliner.cn/2017/05/22/2017-5-11-KotlinDSL2/"/>
    <id>http://www.Kotliner.cn/2017/05/22/2017-5-11-KotlinDSL2/</id>
    <published>2017-05-22T02:30:56.890Z</published>
    <updated>2017-05-22T02:30:56.890Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写博客了，今天发几个最近在各个地方看到的一些碉堡了的 Kotlin DSL。本文先介绍一种 DSL 写法，再推荐几个 DSL 项目。</p>
<h2 id="超厉害的-DSL"><a href="#超厉害的-DSL" class="headerlink" title="超厉害的 DSL"></a>超厉害的 DSL</h2><p>之前在 <a href="https://github.com/kotlintest/kotlintest" target="_blank" rel="external">KotlinTest</a> 上看到一个很牛逼的写法（我把 README 里的实例改了下）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSpecExample</span> : <span class="type">StringSpec</span></span>() &#123;</div><div class="line">  init &#123;</div><div class="line"></div><div class="line">    <span class="string">"should add"</span> &#123;</div><div class="line">       forAll(table(</div><div class="line">           headers(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"result"</span>),</div><div class="line">           row(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</div><div class="line">           row(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">         )) &#123; a, b, result -&gt;</div><div class="line">         a + b shouldBe result</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这其中涉及了好几个 DSL 要素。我一一列举：</p>
<h3 id="字符串后面跟一个代码块"><a href="#字符串后面跟一个代码块" class="headerlink" title="字符串后面跟一个代码块"></a>字符串后面跟一个代码块</h3><p>这个东西的原理你只要看了源码就知道了，很简单，但是你不看就是想不到（这也是我厨 Kotlin 的原因之一，它很简单，<br>但是可以玩出很多花样来）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">invoke</span><span class="params">(block: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就这样你可以利用这个 extension 写出字符串后面跟一个代码块的 DSL 。<br>此处使用的语言特性有：</p>
<ol>
<li>extension （万 DSL 基于 extension）</li>
<li>操作符重载</li>
<li>最后一个参数是 Lambda ，不需要写调用的括号</li>
</ol>
<p>明白了吧。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>举个例子，把他作为一个 URL 的 utility ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">invoke</span><span class="params">(block: (<span class="type">URL</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  block(URL(<span class="keyword">this</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">"ice1000.org"</span> &#123; url -&gt;</div><div class="line">  File(<span class="string">"download.html"</span>).run &#123;</div><div class="line">    <span class="keyword">if</span> (!exists()) createNewFile()</div><div class="line">    writeText(url.readText())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="表格字面量"><a href="#表格字面量" class="headerlink" title="表格字面量"></a>表格字面量</h3><p>就是形如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = listOf(</div><div class="line">   listOf(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>),</div><div class="line">       listOf(<span class="number">0</span>, <span class="number">1</span>),</div><div class="line">          listOf(<span class="number">1</span>),</div><div class="line">          listOf(<span class="number">1</span>, <span class="number">2</span>),</div><div class="line">          listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</div><div class="line">          listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>这样的东西（上面的代码纯粹搞起耍，请不要在意）。</p>
<p>这个就更简单了我觉得你们应该都知道：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">listOf</span><span class="params">(<span class="keyword">vararg</span> vars: <span class="type">T</span>)</span></span> = LinkedList(vars.size).apply &#123; addAll(*vars) &#125;</div></pre></td></tr></table></figure>
<p>无非就是变长参数。</p>
<h2 id="形如-quot-1-1-quot-shouldBe-2-的测试"><a href="#形如-quot-1-1-quot-shouldBe-2-的测试" class="headerlink" title="形如 &quot;(+ 1 1)&quot; shouldBe 2 的测试"></a>形如 <code>&quot;(+ 1 1)&quot; shouldBe 2</code> 的测试</h2><p>这个也很简单，我在小标题里写的就是我在 <a href="https://github.com/lice-lang/lice" target="_blank" rel="external">lice</a> 里使用的测试。</p>
<p>首先，假定我们有以下测试：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">  assertEquals(<span class="string">"ass we can"</span>, trie[<span class="string">"key"</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们希望写成：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">  trie[<span class="string">"key"</span>] shouldBe <span class="string">"ass we can"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，可以有：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T?.<span class="title">shouldBe</span><span class="params">(expected: <span class="type">T</span>?)</span></span> = assertEquals(expected, <span class="keyword">this</span>)</div></pre></td></tr></table></figure>
<p>就是一个中缀表达式而已。这有什么难的？</p>
<h4 id="一些特定情况"><a href="#一些特定情况" class="headerlink" title="一些特定情况"></a>一些特定情况</h4><p>我给我的 lice 写的测试中直接把运行字符串的那一步给包含进去了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> Sting.<span class="title">shouldBe</span><span class="params">(expected: <span class="type">T</span>?)</span></span> = assertEquals(expected, Lice.run(<span class="keyword">this</span>))</div></pre></td></tr></table></figure>
<p>看到没有，运行 lice 代码就是这么简单，还能返回最后一个表达式的值 （喂</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>任何长得类似这样的 DSL 都有一个缺点，就是缩进膨胀（字面意思）。 Scala 为了解决这个问题，<br>推荐用户使用 <code>Tab size 2</code> 的缩进（喂。 于是我也建议读者使用 2 空格缩进。</p>
<h2 id="几个厉害的-DSL-项目"><a href="#几个厉害的-DSL-项目" class="headerlink" title="几个厉害的 DSL 项目"></a>几个厉害的 DSL 项目</h2><p>根据推荐程度排序：</p>
<h3 id="Anko"><a href="#Anko" class="headerlink" title="Anko"></a>Anko</h3><p><a href="https://github.com/Kotlin/anko" target="_blank" rel="external">传送门</a>，不说了，最强的 Kotlin DSL 框架，想必大家早已有所耳闻：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</div><div class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState)</div><div class="line">  verticalLayout &#123;</div><div class="line">      padding = dip(<span class="number">30</span>)</div><div class="line">      editText &#123;</div><div class="line">        hint = <span class="string">"Name"</span></div><div class="line">        textSize = <span class="number">24</span>f</div><div class="line">      &#125;</div><div class="line">      editText &#123;</div><div class="line">        hint = <span class="string">"Password"</span></div><div class="line">        textSize = <span class="number">24</span>f</div><div class="line">      &#125;</div><div class="line">      button(<span class="string">"Login"</span>) &#123;</div><div class="line">        textSize = <span class="number">26</span>f</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>厉害吧。这个框架是用于 Android 的，用于描述 UI 。有一点要说一下，现在的预览插件挂了。</p>
<p>弹窗：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(<span class="string">"Hi, I'm Roy"</span>, <span class="string">"Have you tried turning it off and on again?"</span>) &#123;</div><div class="line">    yesButton &#123; toast(<span class="string">"Oh…"</span>) &#125;</div><div class="line">    noButton &#123;&#125;</div><div class="line">&#125;.show()</div></pre></td></tr></table></figure>
<p>还有一些非 UI 的吊炸天的代码块，比如异步：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">doAsync &#123;</div><div class="line">    <span class="comment">// Long background task</span></div><div class="line">    uiThread &#123;</div><div class="line">        result.text = <span class="string">"Done"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="两个基于-Swing-的-DSL"><a href="#两个基于-Swing-的-DSL" class="headerlink" title="两个基于 Swing 的 DSL"></a>两个基于 Swing 的 DSL</h3><h4 id="Gensokyo"><a href="#Gensokyo" class="headerlink" title="Gensokyo"></a>Gensokyo</h4><p><a href="https://github.com/cqjjjzr/Gensokyo" target="_blank" rel="external">传送门</a>，一个刚出来的项目，它长这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  systemLookAndFeel()</div><div class="line">  frame (title = <span class="string">"Test"</span>, show = <span class="literal">true</span>) &#123;</div><div class="line">      size(<span class="number">500</span>, <span class="number">500</span>)</div><div class="line">      exitOnClose</div><div class="line">    </div><div class="line">      menuBar &#123;</div><div class="line">        subMenu(<span class="string">"File"</span>) &#123;</div><div class="line">          item(<span class="string">"Open"</span>) &#123;</div><div class="line">              listenAction &#123;</div><div class="line">                println(<span class="string">"BOOM!"</span></div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          separator</div><div class="line">          subMenu(<span class="string">"Recent"</span>) &#123;</div><div class="line">              item(<span class="string">"nanimo arimasen"</span>) &#123;</div><div class="line">                listenAction &#123;</div><div class="line">                  println(<span class="string">"SHIT!"</span>)</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          separator</div><div class="line">          item(<span class="string">"Exit"</span>) &#123;</div><div class="line">              listenAction &#123;</div><div class="line">                println(<span class="string">"NOPE! SHIT!"</span>)</div><div class="line">                exitProcess(<span class="number">0</span>)</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    </div><div class="line">      gridLayout &#123;</div><div class="line">        row &#123;</div><div class="line">          button(<span class="string">"Hello!"</span>) &#123;</div><div class="line">              listenAction &#123;</div><div class="line">                println(<span class="string">"click!"</span>)</div><div class="line">                hide</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// gap</span></div><div class="line">        &#125;</div><div class="line">        row &#123;</div><div class="line">          button(<span class="string">"Another Hello!"</span>) &#123;</div><div class="line">              listenAction &#123;</div><div class="line">                println(<span class="string">"another click!"</span>)</div><div class="line">                hide</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// gap</span></div><div class="line">        &#125;</div><div class="line">        row &#123;</div><div class="line">          container &#123;</div><div class="line">              gridLayout &#123;</div><div class="line">                row &#123;</div><div class="line">                  button(<span class="string">"Oh Boy♂Next♂Door!"</span>) &#123;</div><div class="line">                      listenAction&#123;</div><div class="line">                        println(<span class="string">"Ahh fuck you"</span>)</div><div class="line">                        hide</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">                  button(<span class="string">"change the boss of the gym!"</span>) &#123;</div><div class="line">                      listenActionWithEvent &#123; source, _, _, _ -&gt;</div><div class="line">                        println(<span class="string">"Ahh FA♂Q <span class="subst">$source</span>"</span>)</div><div class="line">                        hide</div><div class="line">                        <span class="keyword">this</span><span class="symbol">@frame</span>.hide</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swing 其实没那么垃圾，只要配上 DSL ，啥 GUI 代码都变得好看了。</p>
<h4 id="FriceEngine-DSL"><a href="#FriceEngine-DSL" class="headerlink" title="FriceEngine DSL"></a>FriceEngine DSL</h4><p>这是我之前弄的那个游戏引擎的 DSL 系统，<a href="https://github.com/icela/FriceEngine-DSL" target="_blank" rel="external">传送门</a>，它长这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  game &#123;</div><div class="line">    bounds(<span class="number">500</span>, <span class="number">500</span>, <span class="number">800</span>, <span class="number">750</span>)</div><div class="line">    showFPS = <span class="literal">false</span></div><div class="line"></div><div class="line">    whenExit &#123;</div><div class="line">      closeWindow()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    whenUpdate &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="number">800.</span>elapsed()) &#123;</div><div class="line">        rectangle &#123;</div><div class="line">          x = elapsed / <span class="number">10.0</span></div><div class="line">          y = elapsed / <span class="number">10.0</span></div><div class="line">          color = PINK</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    every(<span class="number">1000</span>) &#123;</div><div class="line">      oval &#123;</div><div class="line">        x = elapsed / <span class="number">10.0</span></div><div class="line">        y = elapsed / <span class="number">10.0</span></div><div class="line">        color = ORANGE</div><div class="line">      &#125;</div><div class="line">      log(<span class="string">"1 second has past."</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    rectangle &#123;</div><div class="line">      name(<span class="string">"rectangle"</span>)</div><div class="line">      x = <span class="number">100.0</span></div><div class="line">      y = <span class="number">100.0</span></div><div class="line">      width = <span class="number">100.0</span></div><div class="line">    &#125;</div><div class="line">    oval &#123;</div><div class="line">      x = <span class="number">0.0</span></div><div class="line">      y = <span class="number">85.0</span></div><div class="line">      accelerate &#123;</div><div class="line">        x = <span class="number">10.0</span></div><div class="line">      &#125;</div><div class="line">      whenColliding(<span class="string">"rectangle"</span>) &#123;</div><div class="line">        stop()</div><div class="line">        x -= <span class="number">5</span></div><div class="line">        accelerate &#123;</div><div class="line">          x = <span class="number">-2.0</span></div><div class="line">          y = <span class="number">10.0</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    image &#123;</div><div class="line">      file(<span class="string">"C:/frice.png"</span>)</div><div class="line">      x = <span class="number">200.0</span></div><div class="line">      y = <span class="number">300.0</span></div><div class="line">      velocity &#123;</div><div class="line">        x = <span class="number">-5.5</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我自己觉得做的还不错。我还为它搞了个中文版，比较粗鄙，用于讽刺中文编程，请前往同项目的 README 查看。</p>
<h3 id="官方教程里的-HTML-DSL"><a href="#官方教程里的-HTML-DSL" class="headerlink" title="官方教程里的 HTML DSL"></a>官方教程里的 HTML DSL</h3><p><a href="https://github.com/Kotlin/kotlinx.html" target="_blank" rel="external">传送门</a>，它长这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">window.setInterval(&#123;</div><div class="line">  <span class="keyword">val</span> myDiv = document.create.div(<span class="string">"panel"</span>) &#123;</div><div class="line">      p &#123; </div><div class="line">        +<span class="string">"Here is "</span></div><div class="line">        a(<span class="string">"http://kotlinlang.org"</span>) &#123; +<span class="string">"official Kotlin site"</span> &#125; </div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  document.getElementById(<span class="string">"container"</span>)?.let &#123;</div><div class="line">    it.appendChild(myDiv)</div><div class="line">    it.append &#123; div &#123; +<span class="string">"added it"</span> &#125; &#125;</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="number">1000</span>L)</div></pre></td></tr></table></figure>
<p>这代码也是我从 README 里面改过的，原文太瘦了，我改的胖一点。</p>
<p>官方给的例子，非常给力（当时也是看这个的源码搞懂了 anko 的原理）。</p>
<h3 id="JavaFX-DSL"><a href="#JavaFX-DSL" class="headerlink" title="JavaFX DSL"></a>JavaFX DSL</h3><p><a href="https://github.com/edvin/tornadofx" target="_blank" rel="external">传送门</a>，它长这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> : <span class="type">View</span></span>() &#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> persons = FXCollections.observableArrayList(</div><div class="line">        Person(<span class="number">1</span>, <span class="string">"Samantha Stuart"</span>, LocalDate.of(<span class="number">1981</span>, <span class="number">12</span>, <span class="number">4</span>)),</div><div class="line">        Person(<span class="number">2</span>, <span class="string">"Tom Marks"</span>, LocalDate.of(<span class="number">2001</span>, <span class="number">1</span>, <span class="number">23</span>)),</div><div class="line">        Person(<span class="number">3</span>, <span class="string">"Stuart Gills"</span>, LocalDate.of(<span class="number">1989</span>, <span class="number">5</span>, <span class="number">23</span>)),</div><div class="line">        Person(<span class="number">3</span>, <span class="string">"Nicole Williams"</span>, LocalDate.of(<span class="number">1998</span>, <span class="number">8</span>, <span class="number">11</span>))</div><div class="line">  )</div><div class="line">  <span class="keyword">override</span> <span class="keyword">val</span> root = tableview(persons) &#123;</div><div class="line">      column(<span class="string">"ID"</span>, Person::id)</div><div class="line">      column(<span class="string">"Name"</span>, Person::name)</div><div class="line">      column(<span class="string">"Birthday"</span>, Person::birthday)</div><div class="line">      column(<span class="string">"Age"</span>, Person::age)</div><div class="line">      columnResizePolicy = SmartResize.POLICY</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我个人觉得很不错了已经。</p>
<p>嘛。祝大家玩 Kotlin 开心。</p>
<hr>
<p>如果你有兴趣加入我们，请直接关注公众号 Kotlin ，并且加 QQ 群：162452394 联系我们。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/arts/kotlin_group.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
    
    <summary type="html">
    
      Kotlin DSL which su go i de su ne!
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.Kotliner.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.Kotliner.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Google 力挺 Kotlin，这是怎么回事！</title>
    <link href="http://www.Kotliner.cn/2017/05/18/Kotlin-on-Android-Now-official/"/>
    <id>http://www.Kotliner.cn/2017/05/18/Kotlin-on-Android-Now-official/</id>
    <published>2017-05-17T23:38:18.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>困死梦中惊坐起，Google 力挺 Kotlin ！</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.05.18/android_kotlin.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>话说洒家梦中化身鲁肃，正准备跟孔明去草船借箭呢，突然好友微信发来则消息：Google 将 Kotlin 列为 Android 官方开发语言，据称 IO 大会上提到这一点的时候，下面的掌声如雷鸣般不绝于耳~</p>
<p>艾玛，这掌声，台上讲话的确定不是毛爷爷？</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.05.18/maoyeye.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>话说听到这一消息之后，群里的小伙伴们都炸了，嗯？这么多夜猫子！</p>
<p>好啦，不说别的，就说说这一消息能给我们带来什么影响呢？</p>
<h2 id="不敢用-Kotlin？"><a href="#不敢用-Kotlin？" class="headerlink" title="不敢用 Kotlin？"></a>不敢用 Kotlin？</h2><p>要知道，在 Google 大大在背后撑腰之前，我们在 Android 当中写 Kotlin 都算是野路子，没有人认可这事儿的，出了问题也还要自己负责，代码移交的时候也会带来一堆麻烦（毕竟大家大多数人不愿意学这个东西啊）。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.05.18/bengkui.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>现在好了，你就可以理直气壮的说，哇塞，Kotlin 是官方语言了，这么好的东西你们都不用，都不愿意去用，你们迟早要被遗忘在历史的车轮印里面的那个小缝缝里面！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.05.18/confirm.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="想用-Lambda？"><a href="#想用-Lambda？" class="headerlink" title="想用 Lambda？"></a>想用 Lambda？</h2><p>要说 Kotlin 最早用在写 Android 上，让人感觉最爽的就是可以任性的使用 <strong>Lambda</strong>，当然这在 Java 8 中也得到了支持（虽然还是支持得很诡异），于是 Google 就差人去折腾个 Jack&amp;Jill，折腾了两年，有一天有个人一进门就冲着 J&amp;J 的开发者们喊了一句 “Hi, Jack!”，于是这个项目就 Deprecated 了。嗯，Android 开发者们想用 Lambda 指望 Google 看来是要等到猴年马月了，而且按照之前的尿性，估计也得等到某个 api 版本才会支持，这就尴尬了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.05.18/jacknjill.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>谁能拯救你？当然是 Kotlin 啊！函数是头等公民的 Kotlin，支持函数式编程都毫无压力，Lambda 的体验更是不在话下，哎呀，不说了，我要去写 Kotlin 了~</p>
<h2 id="想用-Coroutine？"><a href="#想用-Coroutine？" class="headerlink" title="想用 Coroutine？"></a>想用 Coroutine？</h2><p>最近在封装 Camera api。用过的小伙伴肯定都知道，Camera 有两套 api，老 api 基本是是同步调用的接口，只有拍照、对角这两个有回调；新 api 呢，所有的指令都类似于 http 请求一样异步发出去，回调呢，运行在我们发请求时传入的一个 Handler 所在的线程上，这样看来，回调恶魔的大戏就要上演了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.05.18/callback_evil.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>遇到这样的 api，我也很绝望啊。。</p>
<p>开发当中类似回调套回调的写法不在少数，我们该如何写出一段看上去是同步执行的代码，实际上却自己处理了异步请求呢？当然是 Coroutine 啊。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.05.18/coroutine.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>开发过 Unity 的朋友肯定会想到这个，去年有个同事去搞了一段时间游戏，对 Coroutine 的用法大为赞赏，它的主要优点有哪些呢？</p>
<ul>
<li>代码看上去直观，易懂</li>
<li>异常处理简单（一个 try … catch 就解决问题）</li>
<li>资源消耗少（比起你动不动就搞十个八个线程池来说，Coroutine 简直太经济啦）</li>
</ul>
<p>好，最关键的是什么呢？这在 Kotlin 1.1 当中，Coroutine 已经非常完善了，尽管还被标记为 Experimental，但 Kotlin 1.2 的时候目测也不会有大改动，想想以后的 Android 代码还会有这样的东西，真的感觉世界都很美好呢！</p>
<p>哎呀，咋又说这么多，我要去写 Kotlin 了！</p>
<h2 id="WTFUtils"><a href="#WTFUtils" class="headerlink" title="WTFUtils"></a>WTFUtils</h2><p>每次都要提这个东西。你的代码里面一定一堆堆的 StringUtils/ImageUtils/BitmapUtils/LogUtils 这样的东西吧！</p>
<p>更搞笑的是，每个人都有自己的 LogUtils，当然也不排除有些人用的是 LogUtil，结果呢，我在 as 当中 double-shift 输入 LogUti 之后出来一堆，天呐，你们让我选哪一个啊。。</p>
<p>曾经有一次组里面的 iOS 大哥做分享，叫“手把手教 Android 开发写 iOS”，里面特别提到了动态修改方法的特性，以及扩展方法的特性，艾玛，看得我眼馋的不要不要的，想着哪天我也可以给 String 加个什么 util 方法的，该多好。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.05.18/xiangjingjing.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>后来遇到了 Kotlin，Android 的小伙伴们，来吧，删掉你的 XXUtils 或者 XXUtil 吧，让那些不堪回首的往事都随风而去吧。</p>
<h2 id="空指针异常？"><a href="#空指针异常？" class="headerlink" title="空指针异常？"></a>空指针异常？</h2><p>听说你用 Java 写的 Android 代码经常出空指针异常啊？是不是辛辛苦苦大半月，一跑就挂千百遍？千百遍，还每次都是那个空指针，急得你直把眼泪掉，哎，这TM是什么破逻辑，模板代码数不尽，查着查着就懵逼。</p>
<p>Kotlin，安全类型来帮你，从此不怕空指针。</p>
<p>。。。</p>
<p>好人就做到这里，剩下的你们自己关注公众号 Kotlin 翻看以前的文章自己体会 ~</p>
<p><strong>哈哈，我去写 Kotlin 了，别拦着我。</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.05.18/byebye.jpeg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>如果你有兴趣加入我们，请直接关注公众号 Kotlin ，或者加 QQ 群：162452394 联系我们。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/arts/kotlin_group.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;困死梦中惊坐起，Google 力挺 Kotlin ！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
      
    
    </summary>
    
      <category term="官方动态" scheme="http://www.Kotliner.cn/categories/%E5%AE%98%E6%96%B9%E5%8A%A8%E6%80%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 官方参考文档翻译完毕</title>
    <link href="http://www.Kotliner.cn/2017/05/17/kotlin-reference-translated/"/>
    <id>http://www.Kotliner.cn/2017/05/17/kotlin-reference-translated/</id>
    <published>2017-05-17T03:13:15.000Z</published>
    <updated>2017-05-22T02:30:56.921Z</updated>
    
    <content type="html"><![CDATA[<p>非常高兴跟大家宣布：Kotlin 官方文档的参考部分已翻译校对完毕、且与官网同步，这也是目前唯一完整且最新的官方参考文档翻译。</p>
<p>打开 <a href="https://www.kotlincn.net/" target="_blank" rel="external">Kotlin 语言中文站</a>，点<a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="external">学习</a>即是，或者直接打开这个链接：<a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="external">https://www.kotlincn.net/docs/reference/</a>。为了便于离线阅读，还可以从 GitBook 项目 <a href="https://www.gitbook.com/book/hltj/kotlin-reference-chinese/details" target="_blank" rel="external">gitbook.com/book/hltj/kotlin-reference-chinese</a> 下载对应电子书。今后官方文档有更新时，中文站和 GitBook 也会及时同步并更新翻译，关注 Kotlin 语言的同学请保持关注。</p>
<h2 id="Kotlin-是什么？"><a href="#Kotlin-是什么？" class="headerlink" title="Kotlin 是什么？"></a>Kotlin 是什么？</h2><p>Kotlin 中文站首页（<a href="https://www.kotlincn.net/" target="_blank" rel="external">https://www.kotlincn.net/</a>）已经用很醒目的字眼回答了这个问题。而我觉得这样介绍会更充分一些：Kotlin 是一门支持多范式、多平台的现代静态编程语言。Kotlin 支持面向对象、泛型与函数式等编程范式，它支持 JVM、Android、JavaScript 目标平台，而<a href="https://www.kotliner.cn/2017/05/12/Kotlin_Native%20v0.2%20is%20out/">原生（Native）平台的 Kotlin 几天前也发布了 0.2 版本</a>。而且 Kotlin 具有很多现代（也有称下一代的）静态语言特性：如类型推断、多范式支持、可空性表达、扩展函数、模式匹配等。因此上面描述毫不夸张，它是一门非常有潜力的新兴语言。</p>
<p>另外 100% 的 Java 互操作性，，使 Kotlin 能够与既有工具/框架如 Dagger、Spring、Vert.x 等集成，也能让既有的基于 Java 的服务端与 Android 项目逐步迁移到 Kotlin。详情参见<a href="https://www.kotlincn.net/docs/reference/server-overview.html" target="_blank" rel="external">Kotlin 用于服务器端</a>与<a href="https://www.kotlincn.net/docs/reference/android-overview.html" target="_blank" rel="external">Kotlin 用于 Android</a>。了解更多关于 Kotlin 的内容，请关注 <a href="https://www.kotlincn.net/" target="_blank" rel="external">Kotlin 中文站</a>与 <a href="https://www.kotliner.cn/">Kotlin 中文博客</a>。</p>
<h2 id="Kotlin-中文站"><a href="#Kotlin-中文站" class="headerlink" title="Kotlin 中文站"></a>Kotlin 中文站</h2><p>针对 Kotlin 官方参考文档的翻译有很多支系，而只有 <a href="https://www.kotlincn.net/" target="_blank" rel="external">Kotlin 中文站</a> 能够与官网及时同步且最终完成全部参考文档翻译。</p>
<p>这当然离不开创始人<a href="http://tanfujun.com" target="_blank" rel="external">晓_晨DEV</a>和我（<a href="https://hltj.me/" target="_blank" rel="external">灰蓝天际</a>）以及<a href="https://www.kotlincn.net/contribute.html#中文站翻译贡献者" target="_blank" rel="external">所有参与翻译的同学</a>的共同努力。我从 2016 年 2 月开始参与 Kotlin 中文站的翻译，Kotlin 1.0 就是那时正式发布的，时隔一年多又亲历了它 1.1 版的发布，见证它成长的同时，也在不断校对和补充官方参考文档的翻译。而晓_晨DEV更是在 2015 年就开了 Kotlin 中文站的翻译，并且组织带动社区参与者一起翻译。在 Kotlin 中文站版本库的<a href="https://github.com/hltj/kotlin-web-site-cn/graphs/contributors" target="_blank" rel="external">贡献者统计图</a>中可以看到晓_晨DEV与我分别提交了近 4000 行与近 6000 行的改动，已经同官方文档的撰写者一起排进了前十。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.05.17/contributors.png" alt="contributors.png" title="">
                </div>
                <div class="image-caption">contributors.png</div>
            </figure>
<h2 id="与官方站及时同步"><a href="#与官方站及时同步" class="headerlink" title="与官方站及时同步"></a>与官方站及时同步</h2><p>Kotlin 中文站之所以能够与官网内容同步，在于创始人晓_晨DEV采用了科学的翻译方式，其实也是开源界普遍采用的 fork-修改模式，只是 Kotlin 中文站直接 fork 了官方的英文源站。这样做的显著优势是官方站有任何更新可以及时合并进来。尽管这可能会引入冲突解决的环节，并且合并新的英文原版内容会降低翻译完整度。</p>
<p>2016 年 2 月当我评估各个翻译组潜力的时候，就发现了这个问题，当时虽然 Kotlin 中文站的完成度不是最高的，但是其他的翻译组都不具备与官网及时同步的能力，于是果断加入了 Kotlin 中文站翻译。</p>
<h2 id="GitBook-避免重复工作"><a href="#GitBook-避免重复工作" class="headerlink" title="GitBook 避免重复工作"></a>GitBook 避免重复工作</h2><p>Kotlin 网站最初是基于 Jekyll 的网站，目前是使用 Jinjia2 模版引擎的类 Jekyll 网站，并不能直接拿来制作 GitBook。为了能够方便提供 ePUB 版和 Moby 版电子书，我在 <a href="https://www.gitbook.com/book/hltj/kotlin-reference-chinese/details" target="_blank" rel="external">gitbook.com/book/hltj/kotlin-reference-chinese</a> 项目中采用了引入语法，在 GitBook 项目中只维护目录、章节等基本结构，内容都是引用的 Kotlin 中文站版本库的，当然其中用了一些具体的技巧来处理不兼容问题。这样在避免重复工作的同时，也避免出现同步脱节的问题。</p>
<h2 id="参与和改进"><a href="#参与和改进" class="headerlink" title="参与和改进"></a>参与和改进</h2><p>后续 Koltin 中文站会继续翻译教程部分以及参考部分的更新内容。参与翻译请直接 fork <a href="https://github.com/hltj/kotlin-web-site-cn" target="_blank" rel="external">github.com/hltj/kotlin-web-site-cn</a> 并提 Pull Request 过来。</p>
<p>关于网站与 PDF 有任何问题请在<a href="https://github.com/hltj/kotlin-web-site-cn/issues" target="_blank" rel="external">这里</a>反馈；<br>关于 ePUB 与 Mobi 有任何问题请在<a href="https://github.com/hltj/kotlin-reference-chinese/issues" target="_blank" rel="external">这里</a>反馈。</p>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>多年互联网研发从业者。Kotlin 中文站维护人。欢迎关注</p>
<ul>
<li>Github：<a href="https://github.com/hltj" target="_blank" rel="external">https://github.com/hltj</a></li>
<li><p>微博：<a href="http://weibo.com/hltj" target="_blank" rel="external">灰蓝天际</a></p>
<p><img src="/assets/2017.05.17/weibo_qr.png" alt="">    <img src="/assets/2017.05.17/wechat_qr.png" alt=""></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常高兴跟大家宣布：Kotlin 官方文档的参考部分已翻译校对完毕、且与官网同步，这也是目前唯一完整且最新的官方参考文档翻译。&lt;/p&gt;
&lt;p&gt;打开 &lt;a href=&quot;https://www.kotlincn.net/&quot; target=&quot;_blank&quot; rel=&quot;extern
    
    </summary>
    
      <category term="社区动态" scheme="http://www.Kotliner.cn/categories/%E7%A4%BE%E5%8C%BA%E5%8A%A8%E6%80%81/"/>
    
    
      <category term="Kotlin" scheme="http://www.Kotliner.cn/tags/Kotlin/"/>
    
      <category term="中文" scheme="http://www.Kotliner.cn/tags/%E4%B8%AD%E6%96%87/"/>
    
      <category term="官网" scheme="http://www.Kotliner.cn/tags/%E5%AE%98%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>成都线下活动成功举行，Kotliner 获得 Ucloud 赞助</title>
    <link href="http://www.Kotliner.cn/2017/05/15/Good-news-chengdu_meetup-ucloud_support/"/>
    <id>http://www.Kotliner.cn/2017/05/15/Good-news-chengdu_meetup-ucloud_support/</id>
    <published>2017-05-15T03:13:15.000Z</published>
    <updated>2017-05-22T02:30:56.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文来自：<a href="https://www.kotliner.cn">www.kotliner.cn</a></p>
</blockquote>
<p>下面是近期我们组织和参与的一些活动，希望 Kotlin 社区在国内站稳脚跟，发扬光大~</p>
<h2 id="Kotliner-获得-Ucloud-赞助"><a href="#Kotliner-获得-Ucloud-赞助" class="headerlink" title="Kotliner 获得 Ucloud 赞助"></a>Kotliner 获得 Ucloud 赞助</h2><p>Ucloud 云计算的相关负责人在了解了我们的 Kotliner 网站之后决定赞助我们一台云服务器，简直不能更赞。Ucloud 还为我们的站点提供了注册优惠，大家可以阅读原文点击<a href="https://account.ucloud.cn/cas/register?utm_source=kotliner&amp;utm_medium=content_pic_pc&amp;utm_campaign=zanzhu&amp;ytag=kotliner" target="_blank" rel="external">注册</a>，注册立即赠送 50 元代金券~</p>
<p>那么，我们终于可以将托管在 Github 以及 Coding.net 上面的静态站点迁到自己独立的服务器上面了，后续我们也将推出更多有价值的内容，帮助大家迅速了解和掌握 Kotlin，并切实享受到新时代不可阻挡的开发体验。</p>
<h2 id="成都线下活动成功举行"><a href="#成都线下活动成功举行" class="headerlink" title="成都线下活动成功举行"></a>成都线下活动成功举行</h2><p>目前国内使用 Kotlin 的小伙伴们越来越多，在我们 Kotlin 的布道师<a href="http://ice1000.org/" target="_blank" rel="external">千里冰封</a>的组织下，成都的小伙伴们都按捺不住率先搞了一波<a href="https://www.kotliner.cn/2017/05/15/2017-5-13-KotlinMeetupChengDu/">线下聚会</a>，这个事情对我们的触动也不小，北京地区也将在 6月初举办一次线下活动，有兴趣的同学可以加群联系我们。</p>
<h2 id="线下活动-Kotlin-官方表示支持"><a href="#线下活动-Kotlin-官方表示支持" class="headerlink" title="线下活动 Kotlin 官方表示支持"></a>线下活动 Kotlin 官方表示支持</h2><p>就在我们如火如荼的瞎折腾的时候，我们收到了官方的慰问邮件，他们表示要给我们寄文化衫过来(虽然有点儿远，但是我们可以等！)，北京地区和成都地区的链接也挂到了<a href="http://kotlinlang.org/community/user-groups.html" target="_blank" rel="external">官网</a>。</p>
<h2 id="腾讯云近期举办-Kotlin-分享"><a href="#腾讯云近期举办-Kotlin-分享" class="headerlink" title="腾讯云近期举办 Kotlin 分享"></a>腾讯云近期举办 Kotlin 分享</h2><p>腾讯云将在近期举办 Kotlin 直播分享，届时主讲人将为大家带来自己在 Kotlin 方面的学习以及实战经历。具体分享的时间和参与形式我们将在微信公众号 Kotlin 中第一时间为大家推送，敬请关注。</p>
<hr>
<p>如果你有兴趣加入我们，请直接关注公众号 Kotlin ，并且加 QQ 群：162452394 联系我们。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/arts/kotlin_group.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自：&lt;a href=&quot;https://www.kotliner.cn&quot;&gt;www.kotliner.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是近期我们组织和参与的一些活动，希望 Kotlin 社区在国内站稳脚跟，发扬光大~&lt;
    
    </summary>
    
      <category term="编程语言" scheme="http://www.Kotliner.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Kotlin" scheme="http://www.Kotliner.cn/tags/Kotlin/"/>
    
      <category term="Native" scheme="http://www.Kotliner.cn/tags/Native/"/>
    
  </entry>
  
  <entry>
    <title>[译]Kotlin/Native v0.2 发布啦</title>
    <link href="http://www.Kotliner.cn/2017/05/12/Kotlin_Native%20v0.2%20is%20out/"/>
    <id>http://www.Kotliner.cn/2017/05/12/Kotlin_Native v0.2 is out/</id>
    <published>2017-05-12T03:08:00.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<p>我们很高兴地宣布Kotlin / Native v0.2 发布啦，这是 Kotlin / Native 技术预览版的一次功能更新和 Bug 修复。这次更新增加了对协程和跨模块内联函数的支持，以及整体上的问题修复和优化。<br>这次更新包括了一个演示如何使用 <a href="https://github.com/JetBrains/kotlin-native/tree/master/samples/nonBlockingEchoServer" target="_blank" rel="external">并发非阻塞IO协同程序</a> 的示例， 一个 <a href="https://github.com/JetBrains/kotlin-native/tree/master/samples/gtk" target="_blank" rel="external">使用GTK的GUI应用程序</a> ，以及一个由Julius Kunze贡献的<a href="https://github.com/JetBrains/kotlin-native/tree/master/samples/tensorflow" target="_blank" rel="external">TensorFlow机器学习框架</a> 客户端。</p>
<p>下面的代码演示了如何使用协程处理并发 Socket IO。各个用户的请求将得到并发处理。</p>

<p></p>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> connectionId = <span class="number">0</span></div><div class="line">acceptClientsAndRun(listenFd) &#123;</div><div class="line">  memScoped &#123;</div><div class="line">    <span class="keyword">val</span> bufferLength = <span class="number">100</span>L</div><div class="line">    <span class="keyword">val</span> buffer = allocArray&lt;ByteVar&gt;(bufferLength)</div><div class="line">    <span class="keyword">val</span> connectionIdString = <span class="string">"#<span class="subst">$&#123;++connectionId&#125;</span>: "</span>.cstr</div><div class="line">    <span class="keyword">val</span> connectionIdBytes = connectionIdString.getPointer(<span class="keyword">this</span>)</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">val</span> length = read(buffer, bufferLength)</div><div class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>L) <span class="keyword">break</span></div><div class="line">        write(connectionIdBytes, connectionIdString.size.toLong())</div><div class="line">        write(buffer, length)</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</div><div class="line">      println(<span class="string">"I/O error occurred: <span class="subst">$&#123;e.message&#125;</span>"</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

<p></p>

<p>下面的这段代码则演示了如何创建一个带有事件监听的GTK按钮：</p>

<p></p>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> button = gtk_button_new_with_label(<span class="string">"Click me!"</span>)!!</div><div class="line">g_signal_connect(button, <span class="string">"clicked"</span>,</div><div class="line">   staticCFunction &#123; _: CPointer&lt;GtkWidget&gt;?, _: gpointer? -&gt; println(<span class="string">"Hi from Kotlin"</span>) &#125;</div><div class="line">)</div></pre></td></tr></table></figure>

<p></p>

<p>简单地说，Kotlin Native v0.2 能够支持我们编写一些功能完善而精巧的程序了。</p>
<p>另外，Kotlin Native 编译和运行时性能均有明显改善，编译生成的可执行程序体积也进一步得到了缩减。</p>
<p>完整更新内容请参考 <a href="https://github.com/JetBrains/kotlin-native/blob/v0.2.0/CHANGELOG.md" target="_blank" rel="external">更新日志。</a></p>
<p> 点击后面的链接即可下载 <a href="http://download.jetbrains.com/kotlin/native/kotlin-native-linux-0.2.tar.gz" target="_blank" rel="external">Linux</a>  和 <a href="http://download.jetbrains.com/kotlin/native/kotlin-native-macos-0.2.tar.gz" target="_blank" rel="external">MacOS</a> 版本的编译器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们很高兴地宣布Kotlin / Native v0.2 发布啦，这是 Kotlin / Native 技术预览版的一次功能更新和 Bug 修复。这次更新增加了对协程和跨模块内联函数的支持，以及整体上的问题修复和优化。&lt;br&gt;这次更新包括了一个演示如何使用 &lt;a href=
    
    </summary>
    
      <category term="官方动态" scheme="http://www.Kotliner.cn/categories/%E5%AE%98%E6%96%B9%E5%8A%A8%E6%80%81/"/>
    
    
  </entry>
  
  <entry>
    <title>[译]Kotlin 1.1.2 is out</title>
    <link href="http://www.Kotliner.cn/2017/04/25/Kotlin%201.1.2%20is%20out/"/>
    <id>http://www.Kotliner.cn/2017/04/25/Kotlin 1.1.2 is out/</id>
    <published>2017-04-25T13:19:00.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<p>我们很高兴宣布Kotlin 1.1.2正式发布了，这也是Kotlin 1.1的第二次 Bug 修复和工具更新。此次更新不仅提升了编译器和 IntelliJ IDEA 插件的性能，同时也在工具中增加了新的特性，当然还有各方面的问题修复。 此外，Kotlin 1.1.2也提升了与Android Gradle插件版本2.4.0-alpha的兼容性。<br>本次发布版本的所有更新可在<a href="https://github.com/JetBrains/kotlin/blob/1.1.2/ChangeLog.md" target="_blank" rel="external">更新日志</a>中查看。<br>在这里要感谢所有外部的贡献者，他们提交的pull request也包含于该版本中：<a href="https://github.com/shiraji" target="_blank" rel="external">Yoshinori Isogai</a>，<a href="https://github.com/JLLeitschuh" target="_blank" rel="external">Jonathan Leitschuh</a>和<a href="https://github.com/cypressious" target="_blank" rel="external">Kirill Rakhman</a> 。感谢所有尝试EAP构建并向我们发送反馈意见的人！</p>
<h2 id="迁移说明"><a href="#迁移说明" class="headerlink" title="迁移说明"></a>迁移说明</h2><p>Kotlin编译器现在也需要基于JDK 8运行。但您应该不需要在意这一点改变，因为大多数其他Java开发工具（比如Gradle和Android工具）也需要JDK 8，因此您肯定已经安装了JDK 8。对于由编译器生成的代码，仍然默认兼容Java 1.6，而且我们也没有计划要放弃对生成的Java 1.6兼容性字节码的支持。    </p>
<p>内部类当中不能再声明 object，因为这个 object 将能够访问外部类的实例，我们知道 object 始终是一个单例，因此这在理论上是行不通的。同样的，内部密封类也是不被允许的。然而这只是临时方案，在我们添加了在其外部类而非内部类中声明内部密封类的子类的可能性时，将会删除该限制。(<a href="https://youtrack.jetbrains.com/issue/KT-16232" target="_blank" rel="external">KT-16232</a>，<a href="https://youtrack.jetbrains.com/issue/KT-16233" target="_blank" rel="external">KT-16233</a>）    </p>
<p>现在使用一个名称完全由下划线字符组成的声明时将必须使用反引号。(<a href="https://youtrack.jetbrains.com/issue/KT-16264" target="_blank" rel="external">KT-16264</a>）</p>

<p><span id="more-4945"></span></p>

<h2 id="Maven增量编译"><a href="#Maven增量编译" class="headerlink" title="Maven增量编译"></a>Maven增量编译</h2><p>从Kotlin 1.1.2开始，以前用于IntelliJ IDEA和Gradle构建的增量编译现在也支持Maven。启用该功能时，需要使用-D命令行参数或<code>proterties</code>标记设置<code>kotlin.compiler.incremental</code>属性为true：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;properties&gt;</div><div class="line">    &lt;kotlin.compiler.incremental&gt;<span class="literal">true</span>&lt;/kotlin.compiler.incremental&gt;</div><div class="line">&lt;/properties&gt;</div></pre></td></tr></table></figure>
<h2 id="Maven注解处理"><a href="#Maven注解处理" class="headerlink" title="Maven注解处理"></a>Maven注解处理</h2><p>现在可以从Maven构建中调用Kotlin的注解处理工具kapt了，只需要在<code>compile</code>前，从kotlin-maven-plugin中添加<code>kapt</code>的执行目标：</p>

<p></p>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;execution&gt;</div><div class="line">    &lt;id&gt;kapt&lt;/id&gt;</div><div class="line">    &lt;goals&gt;</div><div class="line">        &lt;goal&gt;kapt&lt;/goal&gt;</div><div class="line">    &lt;/goals&gt;</div><div class="line">    &lt;configuration&gt;</div><div class="line">        &lt;sourceDirs&gt;</div><div class="line">            &lt;sourceDir&gt;src/main/kotlin&lt;/sourceDir&gt;</div><div class="line">            &lt;sourceDir&gt;src/main/java&lt;/sourceDir&gt;</div><div class="line">        &lt;/sourceDirs&gt;</div><div class="line">        &lt;annotationProcessorPaths&gt;</div><div class="line">            &lt;!-- Specify your <span class="keyword">annotation</span> processors here. --&gt;</div><div class="line">            &lt;annotationProcessorPath&gt;</div><div class="line">                &lt;groupId&gt;com.google.dagger&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;dagger-compiler&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;<span class="number">2.9</span>&lt;/version&gt;</div><div class="line">            &lt;/annotationProcessorPath&gt;</div><div class="line">        &lt;/annotationProcessorPaths&gt;</div><div class="line">    &lt;/configuration&gt;</div><div class="line">&lt;/execution&gt;</div></pre></td></tr></table></figure>

<p></p>

<p>在<a href="https://github.com/JetBrains/kotlin-examples/blob/master/maven/dagger-maven-example/pom.xml" target="_blank" rel="external">这里</a>查看具有Java-Kotlin代码支持和测试的POM文件完整示例。  </p>
<p>请注意，IntelliJ IDEA自己的构建系统仍然不支持<code>kapt</code>。当您要重新运行注解处理时，需要从“Maven Projects”工具栏中启动构建。</p>
<h2 id="内联方法重构"><a href="#内联方法重构" class="headerlink" title="内联方法重构"></a>内联方法重构</h2><p>我们终于在Kotlin代码中实现了Inline方法（Function）的支持。</p>
<h2 id="其他IDE改进"><a href="#其他IDE改进" class="headerlink" title="其他IDE改进"></a>其他IDE改进</h2><p>在1.1.x时间范围内，我们很大一部分的工作是致力于提高IntelliJ IDEA插件的性能。在此次发布的1.1.2版本中，我们对几项主要性能进行了改进，主要涉及输入响应，同时我们也已经为后续1.1.3版本进行了额外的重大改进。  </p>
<p>除此之外，我们还在此版本中进行了大量新的检测，快速解决方案和小型IDE功能。特别值得一提的是，在编辑器中支持折叠Android String资源引用，以及新的用于处理Android API版本问题的问题解决方案。</p>
<h2 id="如何更新"><a href="#如何更新" class="headerlink" title="如何更新"></a>如何更新</h2><p>要更新IDEA插件，在菜单栏中依次选择 Tools | Kotlin | Configure Kotlin Plugin Update，然后点击“Check for updates now”按钮。另外，不要忘记在Maven和Gradle构建脚本中更新编译器和标准库版本</p>
<p>命令行编译器可以从 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.1.1" target="_blank" rel="external">Github发布页面</a> 页面下载。<br>像往常一样，如果您在新版本中遇到任何问题，您可以在 <a href="https://discuss.kotlinlang.org/" target="_blank" rel="external">论坛</a> 中寻求帮助，在Slack(<a href="http://kotlinslackin.herokuapp.com/" target="_blank" rel="external">获取邀请</a>)、或者在<a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="external">问题追踪器</a>提出问题 。<br>让我们来吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们很高兴宣布Kotlin 1.1.2正式发布了，这也是Kotlin 1.1的第二次 Bug 修复和工具更新。此次更新不仅提升了编译器和 IntelliJ IDEA 插件的性能，同时也在工具中增加了新的特性，当然还有各方面的问题修复。 此外，Kotlin 1.1.2也提升了
    
    </summary>
    
      <category term="官方动态" scheme="http://www.Kotliner.cn/categories/%E5%AE%98%E6%96%B9%E5%8A%A8%E6%80%81/"/>
    
    
  </entry>
  
  <entry>
    <title>如何正确终止 forEach</title>
    <link href="http://www.Kotliner.cn/2017/04/23/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%BB%88%E6%AD%A2-forEach/"/>
    <id>http://www.Kotliner.cn/2017/04/23/如何正确终止-forEach/</id>
    <published>2017-04-23T15:18:52.000Z</published>
    <updated>2017-05-22T02:30:56.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>话说周六下午团建回来，看到群里的小伙伴们在纠结一个问题，如何退出 forEach 循环，或者说有没有终止 forEach 循环的方法，就像 break 那样。我们来看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>)</div><div class="line"><span class="keyword">for</span>(e <span class="keyword">in</span> list)&#123;</div><div class="line">    <span class="keyword">if</span>(e &gt; <span class="number">3</span>) <span class="keyword">break</span></div><div class="line">    println(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 e 大于 3，那么循环终止，这是传统的写法，那么问题来了，我们现在追求更现代化的写法，要把代码改成 forEach 的函数调用，那么我们会怎么写呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list.forEach &#123;</div><div class="line">    <span class="keyword">if</span>(it &gt; <span class="number">3</span>) ???</div><div class="line">    println(it)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就像上面这样吗？感觉应该是这样，不过大于 3 的时候，究竟该怎么办才能退出这个循环呢？</p>
<h2 id="return-还是-return-forEach-？"><a href="#return-还是-return-forEach-？" class="headerlink" title="return 还是 return@forEach ？"></a>return 还是 return@forEach ？</h2><p>作为基本上等价于匿名函数的 Lambda 表达式，我们可能希望它能够提前返回，这样是不是就相当于终止循环了呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>)</div><div class="line">    list.forEach &#123;</div><div class="line">        <span class="keyword">if</span>(it &gt; <span class="number">3</span>) <span class="keyword">return</span></div><div class="line">        println(it)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时候我们毫不犹豫的写下了这样的代码，大于 3 的时候，直接 return，结果呢？运行到 4 的时候，forEach 就真的被终止了，后面也就没有了输出。</p>
<p>嗯，这样是不是就算把问题解决啦？想想也不可能呀，不然我这周的文章岂不是太坑人了？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>)</div><div class="line">    list.forEach &#123;</div><div class="line">        <span class="keyword">if</span>(it &gt; <span class="number">3</span>) <span class="keyword">return</span></div><div class="line">        println(it)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"Hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们把代码改成这样的时候，我们运行时发现只输出 1 3，后面的 Hello 则是无法打印的。原因呢，当然也很简单，在 return 眼里，Lambda 表达式都不算事儿，所以我们在大于 3 时的 return，实际上是返回了 main 函数，于是 list.forEach 这个结构之后的代码就不能被执行了。</p>
<p>好吧，那这里用 return 肯定是有问题的，我们不用它了行了吧。那不用 return 用什么呢？好在 Kotlin 为我们提供了标签式的返回方法，也就是说，如果你想从一个 Lambda 表达式当中显式地返回，那么你只需要写 return@xxx 即可，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>)</div><div class="line">    list.forEach &#123;</div><div class="line">        <span class="keyword">if</span>(it &gt; <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@forEach</span></div><div class="line">        println(it)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"Hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以给这个 Lambda 表达式起个新标签名称，比如 block：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>)</div><div class="line">    list.forEach <span class="symbol">block@</span>&#123;</div><div class="line">        <span class="keyword">if</span>(it &gt; <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@block</span></div><div class="line">        println(it)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"Hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们的程序运行结果就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">3</div><div class="line">Hello</div></pre></td></tr></table></figure>
<p>这一步大家都会想到的，不过这并不是最终的解。</p>
<h2 id="调用还是循环？"><a href="#调用还是循环？" class="headerlink" title="调用还是循环？"></a>调用还是循环？</h2><p>我来问大家一个问题，前面的 forEach 后面传入的 Lambda 表达式体是循环体吗？</p>
<p>当然不是。那其实就是一个函数体，因此对这个函数体的退出只能退出当前的调用。为了说明这个问题，我们还是需要对原有的例子做下小修改：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>)</div><div class="line">    list.forEach <span class="symbol">block@</span>&#123;</div><div class="line">        println(<span class="string">"it=<span class="subst">$it</span>"</span>)</div><div class="line">        <span class="keyword">if</span>(it &gt; <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@block</span></div><div class="line">        println(it)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"Hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">it=<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line">it=<span class="number">3</span></div><div class="line"><span class="number">3</span></div><div class="line">it=<span class="number">4</span></div><div class="line">it=<span class="number">5</span></div><div class="line">it=<span class="number">6</span></div><div class="line">it=<span class="number">7</span></div><div class="line">it=<span class="number">9</span></div><div class="line">Hello</div></pre></td></tr></table></figure>
<p>好家伙，尽管我们在大于 3 的时候 return@block，但看上去仍然没有什么软用，显然，后面的循环仍然执行了。</p>
<p>简单总结一下，在 Lambda 表达式中，return 返回的是所在函数，return@xxx 返回的是 xxx 标签对应的代码块。由于 forEach 后面的这个 Lambda 实际上被调用了多次，因此我们没有办法像 for 循环那样直接 break 。</p>
<p>额。。这可如何是好？</p>
<h2 id="流式数据处理"><a href="#流式数据处理" class="headerlink" title="流式数据处理"></a>流式数据处理</h2><p>实际上我们在 Kotlin 当中用到的 forEach、map、flatMap 等等这样的高阶函数调用，都是流式数据处理的典型例子，我们也看到不甘落后却又跟不上节奏的 Java 在 8.0 推出了 stream Api，其实也无非就是为流式数据处理提供了方便。</p>
<p>采用流式 api 处理数据，我们就不能再像以前那样思考问题啦，以前的思维方式多单薄呀，只要是遍历，那就是 for 循环，只要是条件那就是 if…else，殊不知世界在变，api 也在变，你不跟着变，那你就请便啦。</p>
<p>那么，回到我们最开始的问题，需求其实很明确，遇到某一个大于 3 的数，我们就终止遍历，这样的代码用流式 api 写出来应该是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>)</div><div class="line">list.takeWhile &#123; it &lt;= <span class="number">3</span> &#125;.forEach(::println)</div><div class="line">println(<span class="string">"Hello"</span>)</div></pre></td></tr></table></figure>
<p>我们首先通过 takeWhile 来筛选出前面连续不大于 3 的元素，也就是说一旦遇到一个大于 3 的元素我们就丢弃从这个开始所有后面的元素；接着，我们把取到的这些不大于 3 的元素通过 forEach 打印出来，这样的话，程序的效果与文章最开头的 for 循环 break 的实现就完全一致了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>)</div><div class="line"><span class="keyword">for</span>(e <span class="keyword">in</span> list)&#123;</div><div class="line">    <span class="keyword">if</span>(e &gt; <span class="number">3</span>) <span class="keyword">break</span></div><div class="line">    println(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，你可能会说如果我想要打印其中的偶数，那我该怎么写呢？这时候我告诉大家，如果你写出了下面这样的代码，那么我只能告诉你，。。额，我刚想说啥来着？？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">list.forEach &#123; </div><div class="line">    <span class="keyword">if</span>(it % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">        println(it)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这样写的代码呢，让我想起了辫帅张勋：张将军，你知不知道，咱大清已经亡了呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;.forEach(::println)</div></pre></td></tr></table></figure>
<p>哈哈，如果真的希望使用流式 api，那么上面这样的写法才算是符合风格的写法。当然了，如果你愿意，你还可以定义一个 isEven 的方法，代码写出来就像下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">isEven</span><span class="params">()</span></span> = <span class="keyword">this</span> % <span class="number">2</span> == <span class="number">0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>)</div><div class="line">    list.filter(<span class="built_in">Int</span>::isEven).forEach(::println)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>前不久看到有一篇文章对 Java 8 的流式 api 做了评测，说流式 api 的执行效率比传统的 for-loop 差出一倍甚至更多，所以建议大家慎重考虑选择。</p>
<p>其实对于这个东西我认为我们没必要把神经绷这么紧。原因也很简单呀，流式 api 的执行效率从实现上来讲，确实很难达到纯 for-loop 那样的高效，例如我们前面的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.filter(<span class="built_in">Int</span>::isEvent).forEach(::println)</div></pre></td></tr></table></figure>
<p>在 filter 的时候就调用了一次完整的 for-loop，而后面的 forEach 同样再来一遍，也就是说我们用传统的 for-loop 一遍搞定的事儿，用流式 api 写了两遍，如果条件比较复杂，出现两遍三遍的情况也是比较正常的。</p>
<p>不过这并不能说明流式 api 就一定要慎重使用。流式 api 更适用于数据的流式处理，特别是涉及到较多 UI 交互的场景，这样的业务逻辑用流式 api 表达起来会非常的简洁直观，也易于维护，相应的，这样的场景对于性能的要求并没有到吹毛求疵的地步；而对于性能比较敏感的程序，通常来说也没有很复杂的业务逻辑，流式 api 在这里也难以发挥作用。</p>
<p>另外，仅仅多个几次循环也并不会改变算法本身的运算效率的数量级，所以对于适用于流式 api 的场景，大家还是可以放心去使用的。</p>
<p>–</p>
<p>如果你有兴趣加入我们，请直接关注公众号 Kotlin ，或者加 QQ 群：162452394 联系我们。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/arts/kotlin_group.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;话说周六下午团建回来，看到群里的小伙伴们在纠结一个问题，如何退出 forEach 循环，或者说有没有终止 forEach 循
    
    </summary>
    
      <category term="编程语言" scheme="http://www.Kotliner.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Kotlin" scheme="http://www.Kotliner.cn/tags/Kotlin/"/>
    
      <category term="Lambda" scheme="http://www.Kotliner.cn/tags/Lambda/"/>
    
      <category term="Stream Api" scheme="http://www.Kotliner.cn/tags/Stream-Api/"/>
    
  </entry>
  
  <entry>
    <title>[译]Use Kotlin with npm, webpack and react</title>
    <link href="http://www.Kotliner.cn/2017/04/18/Use%20Kotlin%20with%20npm,%20webpack%20and%20react/"/>
    <id>http://www.Kotliner.cn/2017/04/18/Use Kotlin with npm, webpack and react/</id>
    <published>2017-04-18T07:23:00.000Z</published>
    <updated>2017-05-22T02:30:56.921Z</updated>
    
    <content type="html"><![CDATA[<p>在 Kotlin 1.1 中，编译器生成 JavaScript 功能已经达到生产可用状态。当然，编译器支持还不足以解决现实生活中的问题，所以我们继续将 Kotlin 整合到更大的 JavaScript 生态系统中。<br>今天，我们要介绍两个新项目：一个将 Kotlin 与 npm，webpack 和 karma 集成在一起的 Gradle 插件，以及一个实现了 Kotlin/JVM 后端和基于 React 的 Kotlin/JS 前端的全栈应用程序示例。</p>
<h2 id="Kotlin-前端插件"><a href="#Kotlin-前端插件" class="headerlink" title="Kotlin 前端插件"></a>Kotlin 前端插件</h2><p><a href="https://github.com/Kotlin/kotlin-frontend-plugin" target="_blank" rel="external">Kotlin 前端插件</a>  允许你使用 webpack 构建和部署 Kotlin 前端应用。你可以使用 npm 作为应用的包管理器，插件将负责将依赖的包下载并将其打包到生成的 JS 文件中。该插件还与 Karma 集成，允许你运行应用的测试用例。为了获得最佳的工作流程，该插件支持连续编译和实时预览，确保你的应用在浏览器中始终是最新的。<br><a href="https://github.com/Kotlin/kotlin-frontend-plugin/blob/master/README.md" target="_blank" rel="external">README</a>  文件给出使用插件的说明，示例目录包含一个 <a href="https://github.com/Kotlin/kotlin-frontend-plugin/tree/master/examples/frontend-only" target="_blank" rel="external">简单的例子</a>  显示如何将其应用于真实的项目。</p>
<h2 id="Kotlin-React-例子"><a href="#Kotlin-React-例子" class="headerlink" title="Kotlin React 例子"></a>Kotlin React 例子</h2><p> <a href="https://github.com/Kotlin/kotlin-fullstack-sample" target="_blank" rel="external">Thinkter</a>  是使用 Kotlin 构建的现代全栈应用程序的一个例子。后端运行在 Jetty 并使用 <a href="https://github.com/kotlin/ktor" target="_blank" rel="external">Ktor</a> （由 Kotlin 团队开发的 Kotlin Web 应用程序框架）。前端使用 React; Kotlin 的 React Wrappers 是 <a href="https://github.com/Kotlin/kotlin-fullstack-sample/tree/master/frontend/src/org/jetbrains/react" target="_blank" rel="external">作为项目的一部分提供</a> 。欢迎你在项目中使用我们的 React Wrappers，并根据自己的需要进行调整。请注意，我们正在努力在内部开发 React Wrappers，我们正在考虑将它们作为单独的开源库发布。<br>想要了解 Kotlin React 的代码，可以直接阅读 <a href="https://github.com/Kotlin/kotlin-fullstack-sample/blob/master/frontend/src/org/jetbrains/demo/thinkter/NewThoughtComponent.kt" target="_blank" rel="external">应用组件</a> 的源码。<br>Kotlin 开发团队非常欢迎你们反馈意见！请在 GitHub 上提交问题，逛逛 <a href="https://discuss.kotlinlang.org/" target="_blank" rel="external">论坛</a> ，或者加入<a href="http://slack.kotlinlang.org/" target="_blank" rel="external">Kotlin Slack</a> 的 #javascript 频道。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Kotlin 1.1 中，编译器生成 JavaScript 功能已经达到生产可用状态。当然，编译器支持还不足以解决现实生活中的问题，所以我们继续将 Kotlin 整合到更大的 JavaScript 生态系统中。&lt;br&gt;今天，我们要介绍两个新项目：一个将 Kotlin 与
    
    </summary>
    
      <category term="官方动态" scheme="http://www.Kotliner.cn/categories/%E5%AE%98%E6%96%B9%E5%8A%A8%E6%80%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Kotlin Native 详细体验，你想要的都在这儿</title>
    <link href="http://www.Kotliner.cn/2017/04/15/Kotlin%20Native%20%E8%AF%A6%E7%BB%86%E4%BD%93%E9%AA%8C%EF%BC%8C%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E5%84%BF/"/>
    <id>http://www.Kotliner.cn/2017/04/15/Kotlin Native 详细体验，你想要的都在这儿/</id>
    <published>2017-04-15T03:13:15.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文来自：www.kotliner.cn，</p>
<p>源码地址：<a href="https://github.com/enbandari/Kotlin-Native-Demo" target="_blank" rel="external">https://github.com/enbandari/Kotlin-Native-Demo</a></p>
</blockquote>
<p><strong>内容提要：本文通过 gradle 以及 makefile 两种方式对 Kotlin Native 项目进行构建，提供了详细的从 C 源码编译、到 Kotlin Native 项目的编译及运行的方法，以及该过程中遇到的问题和解决方案，涉及两处对编译器的修改也已经提交 pr。</strong></p>
<p>最近因为 <a href="http://www.kotliner.cn/">www.kotliner.cn</a>上线的原因，一直没顾上对 Kotlin Native 进行体验，现在 Kotlin Native 预览版发布一周了，我来给大家较为详细地介绍一下它的一些相关内容。</p>
<h2 id="1、Kotlin-Native-是什么"><a href="#1、Kotlin-Native-是什么" class="headerlink" title="1、Kotlin Native 是什么"></a>1、Kotlin Native 是什么</h2><p>Kotlin Native 不是 Jni 的概念，它不仅仅是要与底层代码比如 C、C++ 交互，而且还要绕过 Jvm 直接编译成机器码供系统运行。也就是说，Kotlin 准备丢掉 Java 这根拐杖了！</p>
<p>其实我第一次看到 Native 这个名字的时候很自然的想到了 Jni，Kotlin 跑在 Jvm 上面，使用 Jni 与底层代码交互是一件再正常不过的事情了，至于搞这么大动静么，不过等我进行了一番了解之后才发现，Kotlin 项目组的野心真是不小，Java 诞生这么多年了，也没有做过编译成除 Java 虚拟机字节码以外的字节码的事情，Kotlin 才出来多久啊，果然具有革命性。</p>
<p>所以以后有人再问你，什么是 Kotlin，你要回答，Kotlin 是一门很牛逼的静态语言（而不是之前经常说的 Kotlin 是一门运行在 Jvm、Android、FE 上的静态语言了），反正你能想到的，Kotlin 项目组都想干。。</p>
<h2 id="2、如何编写-Kotlin-Native-程序"><a href="#2、如何编写-Kotlin-Native-程序" class="headerlink" title="2、如何编写 Kotlin Native 程序"></a>2、如何编写 Kotlin Native 程序</h2><p>现在 Kotlin Native 刚刚处在技术预览阶段，离商用目测还需要至少一年的时间（小小地激动一下，2018年会不会发布正式版呢），性能优化、标准库、反射等等功能现在尚处于早期的状态，所以大家也没必要强求。下面我给大家介绍下怎么编译出一个 HelloWorld 工程。</p>
<h3 id="2-1-准备编译器"><a href="#2-1-准备编译器" class="headerlink" title="2.1 准备编译器"></a>2.1 准备编译器</h3><p>编译器目前有 Mac、Linux 两个版本，可以编出运行在 树莓派、iOS 以及 OS X 和 Linux 系统上的程序（Windows 真可怜。。），下面的演示运行在 Mac OS X 10.11.6 上，与 Linux 的小伙伴可能稍微一些差异。</p>
<p>编译器官方有现成可用的版本，下载地址如下：</p>
<ul>
<li><a href="http://download.jetbrains.com/kotlin/native/kotlin-native-macos-0.1.tar.gz" target="_blank" rel="external">Mac / iOS</a></li>
<li><a href="http://download.jetbrains.com/kotlin/native/kotlin-native-linux-0.1.tar.gz" target="_blank" rel="external">Linux / 树莓派</a></li>
</ul>
<p>不过呢，也建议小伙伴们直接 clone 编译器源码编译，没有复杂的编译步骤，两行命令即可搞定编译。</p>
<p><a href="https://github.com/JetBrains/kotlin-native" target="_blank" rel="external">Github: Kotlin Native</a></p>
<p>代码拖下来之后，保证网络畅通，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./gradlew dependencies:update</div></pre></td></tr></table></figure>
<p>这一步是下载依赖，官方源码使用了 gradle-wrapper，所以如果你本地没有 gradle 3.1 的话也会自动去下载。这一步就是下载下载下载，所以一定要注意，出错的话基本上就是网络问题。运行完成之后，你就会在 dist/dependencies 目录下面看到下载的各种依赖了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.04.15/deps.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>接着就可以编译了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew dist</div></pre></td></tr></table></figure>
<p>编译时间不长，如果出现错误，可以 clean 多试几次。。编译完之后我们就可以得到编译器一份啦。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.04.15/compiler.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="2-2-Gradle-版-HelloWorld"><a href="#2-2-Gradle-版-HelloWorld" class="headerlink" title="2.2 Gradle 版 HelloWorld"></a>2.2 Gradle 版 HelloWorld</h3><p>下面我们先在 IntelliJ 中创建一个普通的 Gradle 工程，创建好之后，修改 build.gradle 文件，改成下面这样：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        mavenCentral()</div><div class="line">        maven &#123;</div><div class="line">            url  <span class="string">"https://dl.bintray.com/jetbrains/kotlin-native-dependencies"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dependencies &#123;</div><div class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-native-gradle-plugin:0.1"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">apply <span class="string">plugin:</span> <span class="string">'konan'</span></div><div class="line"></div><div class="line">konanInterop &#123;</div><div class="line">    kotliner &#123;</div><div class="line">        defFile <span class="string">'kotliner.def'</span> <span class="comment">// interop 的配置文件</span></div><div class="line">        includeDirs <span class="string">"src/c"</span> <span class="comment">// C 头文件目录，可以传入多个</span></div><div class="line">        <span class="comment">//pkg "cn.kotliner.native" // C 头文件编译后映射为 Kotlin 的包名，这个有问题，后面我们再说</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">konanArtifacts &#123;</div><div class="line">    Kotliner &#123;</div><div class="line">        inputFiles fileTree(<span class="string">"src/kotlin"</span>) <span class="comment">//kotlin 代码配置，项目入口 main 需要定义在这里</span></div><div class="line">        useInterop <span class="string">'kotliner'</span> <span class="comment">//使用前面的 interop 配置</span></div><div class="line">        nativeLibrary file(<span class="string">'src/c/cn_kotliner.bc'</span>) <span class="comment">//自己编译的 llvm 字节格式的依赖</span></div><div class="line">        target <span class="string">'macbook'</span> <span class="comment">// 编译的目标平台</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，konan 就是用来编译 Kotlin 为 native 代码的插件，konanArtifacts 配置我们的项目，konanInterop 主要用来配置 Kotlin 调用 C 的接口。有关插件的配置，可以参考官方文档：<a href="https://github.com/JetBrains/kotlin-native/blob/master/GRADLE_PLUGIN.md" target="_blank" rel="external">GRADLE_PLUGIN</a>。</p>
<p>配置好之后，我们还要创建一个 gradle.properties 文件，加入下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 配置编译器 home，要配置为 bin 目录的 parent</div><div class="line"># 例如：konan.home=&lt;你的 kotlin-native 源码路径&gt;/kotlin-native/dist</div><div class="line">konan.home=&lt;你的编译器路径&gt;</div></pre></td></tr></table></figure>
<p>当然，这个配置可以不加，那样的话，你编译的时候会首先下载一个编译器放到你本地。</p>
<p>接着我们创建一个 kotliner.def 文件，用来配置 c 源码到 kotlin 的映射关系：</p>
<p><strong>kotliner.def</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">headers=cn_kotliner.h</div></pre></td></tr></table></figure>
<p>下面准备我们的源码，在工程目录下面创建 src 目录，在 src/c 目录下面创建下面的文件：</p>
<p><strong>src/c/cn_kotliner.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CN_KOTLINER_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CN_KOTLINER_H</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CN_KOTLINER_H</span></span></div></pre></td></tr></table></figure>
<p><strong>src/c/cn_kotliner.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cn_kotliner.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"[C]HelloWorld\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"[C]calc factorial: %d\n"</span>, n);</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们定义了两个函数，一个用来打印 “HelloWorld”，一个用来计算阶乘。</p>
<p>接着在 src/c 目录下面，用命令行编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -std=c99 -c cn_kotliner.c -o cn_kotliner.bc -emit-llvm</div></pre></td></tr></table></figure>
<blockquote>
<p>如果提示找不到 clang 命令，可以去编译器的 dependencies 目录中找。</p>
</blockquote>
<p>截止到现在，我们已经编译好 C 源码了。接着我们创建 kotlin 源码：</p>
<p><strong>src/kotlin/main.kt</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> kotliner.*</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    printHello()</div><div class="line">    (<span class="number">1.</span><span class="number">.5</span>).map(::factorial).forEach(::println)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，这时候我们可以运行 gradle 的 build 任务了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">12:47:29: Executing external task &apos;build&apos;...</div><div class="line">:downloadKonanCompiler</div><div class="line">:genKotlinerInteropStubs UP-TO-DATE</div><div class="line">:compileKotlinerInteropStubs</div><div class="line">JetFile: kotliner.kt</div><div class="line">JetFile: kotliner.kt</div><div class="line">:compileKonanKotliner</div><div class="line">JetFile: main.kt</div><div class="line">src/kotlin/main.kt:4:11: warning: inliner failed to obtain inline function declaration</div><div class="line">src/kotlin/main.kt:4:28: warning: inliner failed to obtain inline function declaration</div><div class="line">:build</div><div class="line"></div><div class="line">BUILD SUCCESSFUL</div><div class="line"></div><div class="line">Total time: 34.743 secs</div><div class="line">12:48:04: External task execution finished &apos;build&apos;.</div></pre></td></tr></table></figure>
<p>编译完成之后，在 build/konan/Kotliner/bin 目录中会生成一个 kexe 文件，命令行运行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ ./Kotliner.kexe</div><div class="line">[C]HelloWorld</div><div class="line">[C]calc factorial: 1</div><div class="line">[C]calc factorial: 0</div><div class="line">[C]calc factorial: 2</div><div class="line">[C]calc factorial: 1</div><div class="line">[C]calc factorial: 0</div><div class="line">[C]calc factorial: 3</div><div class="line">[C]calc factorial: 2</div><div class="line">[C]calc factorial: 1</div><div class="line">[C]calc factorial: 0</div><div class="line">[C]calc factorial: 4</div><div class="line">[C]calc factorial: 3</div><div class="line">[C]calc factorial: 2</div><div class="line">[C]calc factorial: 1</div><div class="line">[C]calc factorial: 0</div><div class="line">[C]calc factorial: 5</div><div class="line">[C]calc factorial: 4</div><div class="line">[C]calc factorial: 3</div><div class="line">[C]calc factorial: 2</div><div class="line">[C]calc factorial: 1</div><div class="line">[C]calc factorial: 0</div><div class="line">1</div><div class="line">2</div><div class="line">6</div><div class="line">24</div><div class="line">120</div></pre></td></tr></table></figure>
<p>好，我们的程序已经运行起来了，我们看到了 C 当中的 HelloWorld 输出以及阶乘求解的过程，大功告成。</p>
<p>当然，你还可以编写更多好玩的代码，编译的结果就是 Kotlin 再也不需要 Jvm 了，你说激动不激动？</p>
<h3 id="2-3-命令行版-HelloWorld"><a href="#2-3-命令行版-HelloWorld" class="headerlink" title="2.3 命令行版 HelloWorld"></a>2.3 命令行版 HelloWorld</h3><p>除了 gradle 构建外，我们也可以直接使用命令行编译 Kotlin Native，具体步骤也比较类似，首先准备好源码，跟 2.2 中一致。</p>
<p>接着编写 Makefile 或者 build.sh，官方采用了 shell 脚本的方式来构建，那么我下面给出类似的 Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">build : src/kotlin/main.kt kotliner.kt.bc</div><div class="line">	konanc src/kotlin/main.kt -library build/kotliner/kotliner.kt.bc -nativelibrary build/kotliner/cn_kotliner.bc -o build/kotliner/kotliner.kexe</div><div class="line"></div><div class="line">kotliner.kt.bc : kotliner.bc kotliner.def</div><div class="line">	cinterop -def ./kotliner.def -o build/kotliner/kotliner.kt.bc</div><div class="line"></div><div class="line">kotliner.bc : src/c/cn_kotliner.c src/c/cn_kotliner.h</div><div class="line">	mkdir -p build/kotliner</div><div class="line">	clang -std=c99  -c src/c/cn_kotliner.c -o build/kotliner/cn_kotliner.bc -emit-llvm</div><div class="line"></div><div class="line"><span class="section">clean:</span></div><div class="line">	  rm -rf build/kotliner</div></pre></td></tr></table></figure>
<p>这样只需要在命令行执行先把编译器 <konan.home>/bin 加入 path，之后执行 make，编译完成之后就可以在 build/kotliner/ 下面找到 kotliner.kexe 了。</konan.home></p>
<h2 id="3-几个重要的坑"><a href="#3-几个重要的坑" class="headerlink" title="3. 几个重要的坑"></a>3. 几个重要的坑</h2><h3 id="3-1-Gradle-插件指定包名的问题"><a href="#3-1-Gradle-插件指定包名的问题" class="headerlink" title="3.1 Gradle 插件指定包名的问题"></a>3.1 Gradle 插件指定包名的问题</h3><p>gradle konan 插件配置中， 有一行可以配置 C 代码映射到 Kotlin 的包名：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">konanInterop &#123;</div><div class="line">    kotliner &#123;</div><div class="line">        ...</div><div class="line">        pkg <span class="string">"cn.kotliner.native"</span> <span class="comment">// 生成的 C 代码标识符中含有 “.” 倒是无法编译</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这样配置，那么生成的 cstubs.c 文件就会出现下面的情形：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cn_kotliner.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int32_t</span> kni_cn.kotliner.native_factorial (<span class="keyword">int32_t</span> n) &#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">int32_t</span>) (factorial((<span class="keyword">int</span>)n));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>kni_cn.kotliner.native_factorial</code> 显然这不是一个合法的 C 标识符。因此目前这个地方还是有问题的。</p>
<p>这个问题我已经提了 issue，参见：<a href="https://github.com/JetBrains/kotlin-native/issues/490" target="_blank" rel="external">interop with package name failed</a></p>
<p>解决方案也比较简单，我发现这段儿 C 代码生成的时候，编译器企图对包名中的特殊字符进行替换，只不过替换的是 “/“ 而不是 “.”：</p>
<p><strong>org/jetbrains/kotlin/native/interop/gen/jvm/StubGenerator.kt</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> FunctionDecl.cStubName: String</div><div class="line">         <span class="keyword">get</span>() &#123;</div><div class="line">             require(platform == KotlinPlatform.NATIVE)</div><div class="line">-            <span class="keyword">return</span> <span class="string">"kni_"</span> + pkgName.replace(<span class="string">'/'</span>, <span class="string">'_'</span>) + <span class="string">'_'</span> + <span class="keyword">this</span>.name</div><div class="line">+            <span class="keyword">return</span> <span class="string">"kni_"</span> + pkgName.replace(<span class="string">'.'</span>, <span class="string">'_'</span>) + <span class="string">'_'</span> + <span class="keyword">this</span>.name</div><div class="line">         &#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-Kotlin-的-main-函数不能有包名"><a href="#3-2-Kotlin-的-main-函数不能有包名" class="headerlink" title="3.2 Kotlin 的 main 函数不能有包名"></a>3.2 Kotlin 的 main 函数不能有包名</h3><p>细心的读者应该会发现，我们前面写的 main 函数所在文件是没有 package 的，如果你给这个文件制定一个 package，那么编译器就无法找到入口函数，进而导致编译链接错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Undefined symbols for architecture x86_64:</div><div class="line">  &quot;_kfun:main(kotlin.Array&lt;kotlin.String&gt;)&quot;, referenced from:</div><div class="line">      _Konan_start in combined8326574232997306104.o</div><div class="line">ld: symbol(s) not found for architecture x86_64</div><div class="line">exception: java.lang.IllegalStateException: The /Users/benny/Github/kotlin-native/dist/dependencies/target-sysroot-1-darwin-macos/usr/bin/ld command returned non-zero exit code: 1.</div><div class="line">	at org.jetbrains.kotlin.backend.konan.LinkStage.runTool(LinkStage.kt:285)</div><div class="line">	at org.jetbrains.kotlin.backend.konan.LinkStage.link(LinkStage.kt:261)</div></pre></td></tr></table></figure>
<h3 id="3-3-def-文件的路径"><a href="#3-3-def-文件的路径" class="headerlink" title="3.3 def 文件的路径"></a>3.3 def 文件的路径</h3><p>如果你使用前面的 makefile 进行编译，cinterop 调用时传入的 def 文件的路径一定不能写成下面这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cinterop -def kotliner.def -o build/kotliner/kotliner.kt.bc</div></pre></td></tr></table></figure>
<p>kotliner.def 必须使用 ./kotliner.def 的形式，否则编译器在编译时出遇到类似下面的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;konan.home&gt;/dependencies/clang-llvm-3.9.0-darwin-macos/bin/clang -Isrc/c -isystem &lt;konan.home&gt;/dependencies/clang-llvm-3.9.0-darwin-macos/lib/clang/3.9.0/include -B&lt;konan.home&gt;/dependencies/target-sysroot-1-darwin-macos/usr/bin --sysroot=&lt;konan.home&gt;/dependencies/target-sysroot-1-darwin-macos -mmacosx-version-min=10.11 -emit-llvm -c build/kotliner/kotliner.kt.bc-build/natives/cstubs.c -o build/kotliner/kotliner.kt.bc-build/natives/cstubs.bc</div><div class="line">clang-3.9: error: no such file or directory: &apos;build/kotliner/kotliner.kt.bc-build/natives/cstubs.c&apos;</div><div class="line">clang-3.9: error: no input files</div><div class="line">Exception in thread &quot;main&quot; java.lang.Error: Process finished with non-zero exit code: 1</div><div class="line">        at org.jetbrains.kotlin.native.interop.gen.jvm.MainKt.runExpectingSuccess(main.kt:112)</div><div class="line">        at org.jetbrains.kotlin.native.interop.gen.jvm.MainKt.runCmd(main.kt:158)</div><div class="line">        at org.jetbrains.kotlin.native.interop.gen.jvm.MainKt.processLib(main.kt:396)</div><div class="line">        at org.jetbrains.kotlin.native.interop.gen.jvm.MainKt.main(main.kt:43)</div></pre></td></tr></table></figure>
<blockquote>
<p>以上用 &lt; konan.home &gt; 替换了编译的路径。</p>
</blockquote>
<p>这个问题是因为 cinterop 最终会调用 clang 去编译一个动态生成的 c 文件，而调用时传入的 workdir 是 def 文件的父目录，如果我们传入 def 文件时写了形如 “-def kotliner.def” 这样的参数，那么得到的父目录就是 null 了，于是就出现了各种找不到文件的情况。</p>
<p>当然我们可以对编译器源码稍作修改就可以解决这个问题：</p>
<p><strong>Interop/StubGenerator/src/main/kotlin/org/jetbrains/kotlin/native/interop/gen/jvm/main.kt</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">357</span> -    <span class="keyword">val</span> workDir = defFile?.parentFile ?: File(System.getProperty(<span class="string">"java.io.tmpdir"</span>))</div><div class="line">    +    <span class="keyword">val</span> workDir = defFile?.absoluteFile?.parentFile ?: File(System.getProperty(<span class="string">"java.io.tmpdir"</span>))</div></pre></td></tr></table></figure>
<p>这个问题我也在 github 提了 pr，大家可以参考：<a href="https://github.com/JetBrains/kotlin-native/pull/492" target="_blank" rel="external">Wrong workdir when use relative def file path like “-def interop.def”</a>。</p>
<h2 id="4、展望"><a href="#4、展望" class="headerlink" title="4、展望"></a>4、展望</h2><p>嗯，这题目看上去真有点儿让我想起毕业论文来呢。不过这个展望比起论文的展望要踏实得多。</p>
<h3 id="4-1-IntelliJ-支持"><a href="#4-1-IntelliJ-支持" class="headerlink" title="4.1 IntelliJ 支持"></a>4.1 IntelliJ 支持</h3><p>通过前面两节对 Kotlin Native 项目的构建和运行，我们发现 Kotlin 官方对于开发体验非常关注，尽管目前 IntelliJ 对此的支持还基本为零，不过 gradle 插件的支持已经非常令人满意了。相信随着 Kotlin Native 项目的迭代，IntelliJ 对其的支持也会趋于完善，彼时我们开发 Kotlin Native 的程序简直会 high 到飞起。</p>
<p>当然，我们也看到前面的构建过程中，对于 c 源码的构建支持几乎为零，我们仍然需要手动对 c 文件进行编译，不过这个并不复杂，所以极有可能出现的情形是 JetBrains 专门为 Kotlin 搞一个 IntelliJ 的版本（哇塞），整合 CLion 以及现有 Kotlin Native 的功能，一键编译 c 以及 Kotlin Native 源码也未可知呀。</p>
<h3 id="4-2-支持更多平台"><a href="#4-2-支持更多平台" class="headerlink" title="4.2 支持更多平台"></a>4.2 支持更多平台</h3><p>Kotlin Native 技术预览版还不支持 windows，这可苦了没有 Unix-like 机器的小伙伴们（嗯，虚拟机可以拯救你们），不过这只是暂时的，前期也没必要在很多平台上投入精力，一旦 Kotlin Native 在 Unix-like 机器上火起来，届时 windows 版的动力岂不是更大么，哈哈。</p>
<p>比起对 windows 版的支持，我觉得对 Android 的支持才是杀手级的。毕竟现在写桌面程序的人要少一些了，而 windows 程序也大多用微软全家桶，所以赶紧支持 Android 吧，哈哈哈。</p>
<h3 id="4-3-再见，Jni"><a href="#4-3-再见，Jni" class="headerlink" title="4.3 再见，Jni"></a>4.3 再见，Jni</h3><p>从学知道 Jni 的一开始，就尝试着写过几个小程序，结果毋庸置疑，除了蛋疼就是蛋疼，IDE 支持也困难得不要不要的。后来开始写 Android，也基本上对 Jni 是敬而远之。</p>
<p>说起来我们公司项目有大量的 openGL 代码用 C/C++ 编写，在 windows 和 Mac 上有相应的移植版本，开发完成后再打包移植到 Android 以及 iOS 上。当然，我并不在这些项目组，我只是觉得搞这些开发的同事特别是负责移植到 Android 的同事的实在太优秀了，像我这种 JB 脑残粉，离了 IDE 智能提示的话，一行代码都写不下去。。。</p>
<p>Kotlin 的出现很有希望终结 Jni 的痛苦现状，Kotlin Native 也将为我们这些 Jvmer 打开一扇窗户，让我们几乎零成本进入底层代码的编写。</p>
<p>那个什么，以后别说自己是 Jvmer 了，说自己是 Kotliner 吧，也欢迎大家经常光顾 www.kotliner.cn。</p>
<h3 id="4-4-大一统"><a href="#4-4-大一统" class="headerlink" title="4.4 大一统"></a>4.4 大一统</h3><p>如果我想写个牛逼一点儿的程序，我会选择 Java，原因是我对它最熟；</p>
<p>如果我想写一个工具脚本，我会选择 python，尽管 python 有时候还真是挺坑的，不过用着还算不错；</p>
<p>如果我想写个网站，我会选择 php，因为。。开发方便，资料也多。。。</p>
<p>嗯，自打一开始学编程，我就发现这坑可踩大发了。尽管用 C 可以写出 php 能写出的任何程序，Java 也一样，不过每一门语言终究因其自身的特点而擅长于不同的使用场景。</p>
<p>前不久跟一个资深开发聊天，他问我 Kotlin 能做什么，我说能做这个，能做那个，结果他听了之后来了一句：Kotlin 能写的 Java 都能写是呗？没错，他说得是对的，只是这能和能做好之间可就差了十万八千里了。</p>
<p>请问，如果你想要写一个小工具，你用 Java 写的话，是不是工程还没有配好，别人用 python 就已经调试完了？如果你用 C++ 写 web 应用，是不是工程还没配好，别人用 php 已经开始跟客户端联调了？这么说也许夸张了一些，但不得不承认的是，每一门语言都有其擅长的场景，“xxx能干的yyy也能干” 这样的句式简直让人有种 “你行你上啊” 来批驳的冲动。</p>
<p>那么 Kotlin 的出现究竟能给我们带来什么呢？试想一下，写小工具，我们可以用 kts（Kotlin Script）；所有 Java 擅长的 Kotlin 都擅长，而且写起来还比 Java 简洁不少；你甚至可以用 Kotlin 来开发前端程序来替代 JavaScript，尽管这个目前看来还没有很多人用到。而现在呢，我们还可以把 Kotlin 直接编译成 C 一样的机器码来运行，这样一来，Kotlin 将来还可以直接应用于嵌入式等对性能要求比较高的场景，这可真是上的了云端，下的了桌面，写的了网页，嵌的了冰箱啊。</p>
<p>一句话，Kotlin 从 Jvm 起家，现正在向着各种应用场景用功，各个场景的表现也不错，俨然成为一门擅长多个领域的语言了。</p>
<p>当然，程序员们也是萝卜青菜各有所爱，真正实现大一统显然也不太现实，但我们至少拥有了这样的途径和机会是不是？</p>
<hr>
<p>如果你有兴趣加入我们，请直接关注公众号 Kotlin ，并且加 QQ 群：162452394 联系我们。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/arts/kotlin_group.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自：www.kotliner.cn，&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/enbandari/Kotlin-Native-Demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;h
    
    </summary>
    
      <category term="编程语言" scheme="http://www.Kotliner.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Kotlin" scheme="http://www.Kotliner.cn/tags/Kotlin/"/>
    
      <category term="Native" scheme="http://www.Kotliner.cn/tags/Native/"/>
    
  </entry>
  
  <entry>
    <title>Kotliner.cn 上线啦</title>
    <link href="http://www.Kotliner.cn/2017/04/10/Kotliner.cn%20%E4%B8%8A%E7%BA%BF%E5%95%A6/"/>
    <id>http://www.Kotliner.cn/2017/04/10/Kotliner.cn 上线啦/</id>
    <published>2017-04-10T03:09:51.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.kotliner.cn">Kotliner</a></p>
<p>Kotlin 在国内目前引起了不少人的关注，不过整体上 Kotlin 的国内技术氛围还是要稍微差一些的。目前国内有一个 Kotlin 论坛，不过不太活跃，毕竟论坛的时代已经过去了，现在除了房地产水一下水木，找 IT 工作的水一下北邮人，技术论坛感觉已经过气了。我看到有些朋友在 Github 上面发起翻译 Kotlin 官网的项目，这个想法挺不错，不过应该知道的人不多，可能需要一些宣传；在总结了前人的经验之后，我觉得我们可以依托公众号和 QQ 群搭建一个博客，这个博客主要承担下面的功能：</p>
<ul>
<li>同步更新官方博客中文版</li>
<li>同步更新 Kotlin 公众号</li>
<li>收录整理国内优秀的 Kotlin 资源</li>
<li>发现并宣传国内优秀的 Kotlin 开发者和分享者</li>
</ul>
<p>总体上讲，做到 Kotlin 开发者的一本重要的参考手册，在目前国内资源匮乏的条件下满足 Kotlin 开发者的日常开发需求，同时也要为热衷于分享的 Kotlin 开发者提供一个展示自己的机会。</p>
<p>截止现在，Kotliner 已经同步完所有 Kotlin 公众号的文章，我们的下一步计划是同步 Kotlin 1.0 发布以来官方博客的部分有价值的文章，这些文章发布于正式版之后，基本上到现在还是比较有参考价值的。</p>
<p>如果你有兴趣加入我们，请直接回复公众号，或者加 QQ 群：162452394 联系我们。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/arts/e_group.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.kotliner.cn&quot;&gt;Kotliner&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kotlin 在国内目前引起了不少人的关注，不过整体上 Kotlin 的国内技术氛围还是要稍微差一些的。目前国内有一个 Kotlin 论坛，不过不太活跃，毕竟论坛的时代
    
    </summary>
    
      <category term="官方动态" scheme="http://www.Kotliner.cn/categories/%E5%AE%98%E6%96%B9%E5%8A%A8%E6%80%81/"/>
    
    
      <category term="kotlin.cn 中文博客" scheme="http://www.Kotliner.cn/tags/kotlin-cn-%E4%B8%AD%E6%96%87%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Native：本周又搞了个大事情</title>
    <link href="http://www.Kotliner.cn/2017/04/10/Kotlin%20Native%EF%BC%9A%E6%9C%AC%E5%91%A8%E5%8F%88%E6%90%9E%E4%BA%86%E4%B8%AA%E5%A4%A7%E4%BA%8B%E6%83%85/"/>
    <id>http://www.Kotliner.cn/2017/04/10/Kotlin Native：本周又搞了个大事情/</id>
    <published>2017-04-10T01:49:45.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<p>话说。。有一天在地铁上正站得我风生水起（这玩意儿也能风生水起？）的时候，小伙伴突然往群里面丢了一个链接，然后群里就炸了：<a href="https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/" target="_blank" rel="external">Kotlin/Native Tech Preview: Kotlin without a VM</a>，Kotlin Native 在年初的时候就逐渐引起大家的注意，Kotlin 的扛把子 Andrey 哥也一再表示“用不了多久咱们就能过上好日子啦”，当然我估摸着 2017 年的大事情会不少，这不来得还挺快。</p>
<p>话说这 Kotlin Native 呢，还处于预览阶段，官方一再强调“我还是个宝宝，你们可不要乱来哦”：</p>
<blockquote>
<p>No performance optimization has been done yet, so benchmarking Kotlin/Native makes no sense at this point.</p>
</blockquote>
<p>这个嘛，请官方放心，我们不会轻易放过你的！</p>
<p>于是群里小伙伴们开始下载 Native 的源码 <a href="https://github.com/JetBrains/kotlin-native" target="_blank" rel="external">Github: Kotlin-native</a> 开始编译，并运行其中的 sample，整个过程其乐融融，有 Mac 和 Linux 的小伙伴表示毫无压力，而只有 windows 的哥们表示“我的树莓派不在家里啊”。额，看到没，用 windows 做开发是没有钱途滴！这事儿突然让我想起来前几天编译 Android Sdk 源码，编译 mac 版在 Mac 上面编即可，而想编译 windows 的 sdk，你就得在 Linux 上面先编译完 Linux 版 sdk，然后再用 Linux 版来个移魂大法换成 windows 版，额，我就改了几句 aapt 的代码，mac 版立等可取，windows 版编了好几天啊哭。。</p>
<p>接着说 Kotlin Native，当小伙伴们看到 Kn 编译之后生成了这样的 stubs，瞬间表示 Jni 有救啦！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.4.10/native.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>一个注解就能连接上 C 代码，是不是很让人期待！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.4.10/show.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>想来也真是给力，上周刚刚推送的文章对 Kotlin Native 做了狠狠的期待，这周就出这样的大新闻，不得不说，2017 年 Kotlin 很让人期待呀，如果你还在犹豫到底要不要学，啥也别说了先加 QQ 群吧：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/arts/e_group.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说。。有一天在地铁上正站得我风生水起（这玩意儿也能风生水起？）的时候，小伙伴突然往群里面丢了一个链接，然后群里就炸了：&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-
    
    </summary>
    
      <category term="官方动态" scheme="http://www.Kotliner.cn/categories/%E5%AE%98%E6%96%B9%E5%8A%A8%E6%80%81/"/>
    
    
      <category term="Native" scheme="http://www.Kotliner.cn/tags/Native/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Primer草稿 函数</title>
    <link href="http://www.Kotliner.cn/2017/04/07/KotlinPrimerFunction/"/>
    <id>http://www.Kotliner.cn/2017/04/07/KotlinPrimerFunction/</id>
    <published>2017-04-07T01:10:11.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>本章节主要介绍Kotlin中的函数相关的概念。</p>
<h2 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>即使Kotlin是一门面向对象的编程语言，它也是有函数的概念的——而不像Java那样，仅仅有“方法”。</p>
<p>Java中有静态方法来代替函数的作用，但是Kotlin的函数比Java的静态方法自由度大很多。<br>我们先来看几个例子。</p>
<p>函数声明使用fun保留字，语法比较类似Scala：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">()</span></span> &#123;</div><div class="line">  println(<span class="string">"This is a function"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你需要一个有参数的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionWithParams</span><span class="params">(obj: <span class="type">Any</span>?)</span></span> &#123;</div><div class="line">  println(<span class="string">"You have passed an object to this function: <span class="subst">$obj</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的函数有一个Any?类型的参数。类似的例子还有程序的入口main函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你需要一个返回值的话：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionWithReturnValue</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">  <span class="keyword">return</span> Random().nextInt()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个函数不返回东西，你可以不写返回值。也可以让它显示返回Unit：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionReturnsUnit</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个函数不会返回（也就是说只要调用这个函数，那么在它返回之前程序肯定GG了（比如一定会抛出异常的函数）），<br>因此你也不知道返回值该写啥，那么你可以让它返回Nothing：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionReturnsNothing</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> &#123;</div><div class="line">  <span class="keyword">throw</span> RuntimeException(<span class="string">""</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个函数也可以拥有Java风格的泛型参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">functionWithGenericsParam</span><span class="params">(t: <span class="type">T</span>)</span></span>: T &#123;</div><div class="line">  <span class="keyword">return</span> t</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Kotlin中的泛型概念和Java基本相同，这里不再展开讨论。关于型变、协变等Java中没有的复杂泛型概念将在下文讨论。</p>
<p>函数参数可以有默认值（关于这个函数中for循环的中缀语法下文会提到，这里可以先忽略）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionWithDefaultParams</span><span class="params">(limit: <span class="type">Int</span> = <span class="number">10</span>)</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.limit step <span class="number">2</span>) println(i)</div><div class="line">  <span class="keyword">return</span> limit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是你不再需要像Java那样为了默认参数而写一大长串重载函数了。当然，Kotlin也支持重载。</p>
<p>如果一个函数的函数体只需要一个表达式就可以计算出来，比如考虑如下函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionReturningIncreasedInteger</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">  <span class="keyword">return</span> num + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以直接使用这种语法（expression function body）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionReturningIncreasedInteger</span><span class="params">(num: <span class="type">Int</span>)</span></span> = num + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>第二种语法省略了返回值类型（编译器可以根据后面的表达式推导出返回类型），以及大括号。</p>
<p>同理，比如说我们有一个求平方的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">square</span><span class="params">(int: <span class="type">Int</span>)</span></span> = int * int</div></pre></td></tr></table></figure>
<p>如果一个函数是空函数，比如Swing的ActionListener强制要求重载但是又不需要使用的函数，可以通过这种方式来表达：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> input = JTextField()</div><div class="line">  input.addKeyListener(<span class="keyword">object</span> : KeyListener &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">keyTyped</span><span class="params">(e: <span class="type">KeyEvent</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">keyReleased</span><span class="params">(e: <span class="type">KeyEvent</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">keyPressed</span><span class="params">(e: <span class="type">KeyEvent</span>?)</span></span> &#123;</div><div class="line">      <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.keyCode == KeyEvent.VK_ENTER) &#123;</div><div class="line">        output.append(<span class="string">"<span class="subst">$&#123;input.text&#125;</span>\n"</span>, Color(<span class="number">0x467CDA</span>))</div><div class="line">        repl.handle(input.text, sl)</div><div class="line">        input.text = <span class="string">""</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中， <code>fun xxx() = Unit</code> 表示这是一个空函数。</p>
<p>如果一个函数不返回Unit或者Nothing，那么<strong>尽可能让它成为一个<a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="external">纯函数</a></strong>（即没有<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science" target="_blank" rel="external">副作用</a>)的函数）。<br>这是<strong><a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">函数式编程</a></strong>的约定。</p>
<blockquote>
<p>关于函数式编程：<br><br>函数式编程是一种学院派的编程范式，与之对应的是“命令式编程”。它常常与数学中的范畴论（category theory）结合，追求编写更易维护、并发性更好的程序。业界对它褒贬不一，笔者倾向于将它与面向对象编程结合。</p>
</blockquote>
<p>虽然Hadi Hariri曾经在JetBrains中国开发者日上说过Kotlin不是函数式编程语言，但是Kotlin有大量的（看起来非常）函数式的特性、约定、标准库函数。<br>因此我们可以默认它是追求函数式编程的，那么就应该尽可能遵循函数式法则。</p>
<blockquote>
<p>为什么返回Unit或者Nothing就不需要纯了呢？</p>
</blockquote>
<p>既然一个函数没有返回值，那么对它讨论<a href="https://en.wikipedia.org/wiki/Referential_transparency" target="_blank" rel="external">引用透明</a>也就没有意义了。<br>如果一个返回Unit或者Nothing的函数没有副作用，那么它的存在也将没有意义。</p>
<p>更多关于函数式编程的知识不在本书讨论范围内，读者可以自行查询相关资料。</p>
<h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>函数里面也可以定义函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionWithAnotherFunctionInside</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> valuesInTheOuterScope = <span class="string">"Kotlin is awesome!"</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">theFunctionInside</span><span class="params">(int: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</div><div class="line">    println(valuesInTheOuterScope)</div><div class="line">    <span class="keyword">if</span> (int &gt;= <span class="number">5</span>) theFunctionInside(int - <span class="number">1</span>)</div><div class="line">  &#125;</div><div class="line">  theFunctionInside()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部函数可以直接访问外部函数的局部变量、常量，Java是做不到这点的哦。</p>
<p>递归也没有任何问题。如上面的代码所示。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是一种特殊的函数，它必须通过类的实例调用，也就是说每个方法可以在方法内部拿到这个方法的实例。这是方法和函数的不同之处。</p>
<p>方法和函数几乎一模一样，唯一的区别就是方法必须声明在类里面。下面是一个方法和一个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">thisIsAFunction</span><span class="params">()</span></span> = <span class="built_in">Unit</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisIsAClass</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">thisIsAMethod</span><span class="params">()</span></span> = <span class="built_in">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>可能你会好奇上面给出的一个例子中有一个for循环使用的诡异语法，即中缀表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span> step <span class="number">20</span>) &#123;</div><div class="line">    println(i)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个step是什么意思呢？</p>
<p>其实是Kotlin方法的一种语法糖，一个方法如果在声明时有一个infix修饰符，那么它可以使用中缀语法调用。</p>
<p>所谓中缀语法就是不需要点和括号的方法调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">infixFunction</span><span class="params">(b: <span class="type">B</span>)</span></span> &#123;</div><div class="line">    <span class="comment">// codes</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = A()</div><div class="line">  a infixFunction b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，我们只需要给一个类增加一个中缀的step方法就可以实现上面的语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">step</span><span class="params">(step: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = A()</div><div class="line">  a step <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个功能基本就是用于将代码变得“更易阅读”。<br>Scala所有函数缺省支持中缀表达式，Kotlin需要单独声明。</p>
<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>中缀表达式可以在一定程度上简化函数调用的代码。如果说中缀表达式还不够简洁，那么你一定需要操作符重载了。</p>
<p>Kotlin的操作符重载的规则是：</p>
<ol>
<li>该方法使用operator修饰符</li>
<li>该方法的方法名必须被声明为特定的名称，以将对应的操作符映射为这个函数的调用</li>
<li>参数必须符合该操作符的规定，比如+的重载就不能有多于一个（不含）的参数，也不能为空参数。</li>
</ol>
<p>举个例子，我们要重载A类的+运算符。注意三个规定（函数名、参数得符合规矩，加operator修饰）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">A</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"invoking plus"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是对+的重载了。我们可以这样调用这个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = A() + A()</div></pre></td></tr></table></figure>
<p>此处的+就是对plus方法的调用了。我们可以运行上面的代码，看到输出：”invoking plus”。</p>
<p>当然，操作符重载也可以被替换为函数调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = A().plus(A())</div></pre></td></tr></table></figure>
<p>这段代码和上面那段完全相同。</p>
<p>还有不少操作符的重载，下面给出一系列例子（仅作为函数名的实例，实现全部为空/false/0（因为部分操作符重载要求返回Int/Boolean））：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">times</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">div</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rem</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="meta">@Suppress(<span class="meta-string">"DEPRECATED_BINARY_MOD"</span>)</span></div><div class="line">  <span class="meta">@Deprecated(<span class="meta-string">"mod should be replaced with rem"</span>, ReplaceWith(<span class="meta-string">"rem"</span>)</span>)</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">mod</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rangeTo</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">Any</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>, value: <span class="type">Any</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">  </div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(obj: <span class="type">Any</span>?)</span></span></div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">inc</span><span class="params">()</span></span> = A()</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">dec</span><span class="params">()</span></span> = A()</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryPlus</span><span class="params">()</span></span> = A()</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryMinus</span><span class="params">()</span></span> = A()</div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Any</span>?)</span></span> = <span class="number">0</span></div><div class="line">  <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span> = <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">Any</span>?)</span></span> = <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span> = <span class="keyword">object</span> : Iterator&lt;Any&gt; &#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span> = <span class="literal">false</span></div><div class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span> = <span class="built_in">Unit</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是最基本的操作符，它们对应的操作符和注释中的一一对应：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// +</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// -</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">times</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// *</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">div</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// /</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rem</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// %</span></div><div class="line"></div><div class="line">  <span class="meta">@Suppress(<span class="meta-string">"DEPRECATED_BINARY_MOD"</span>)</span></div><div class="line">  <span class="meta">@Deprecated(<span class="meta-string">"mod should be replaced with rem"</span>, ReplaceWith(<span class="meta-string">"rem"</span>)</span>)</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">mod</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// %，和rem一样</span></div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rangeTo</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// ..</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>倒数第二个mod是特殊的操作符重载——它在Kotlin1.1中被标记为过时（Deprecated）的。<br>在1.1中，使用了rem（remainder）来代替mod，符合java.math.BigInteger的命名。</p>
<p>关于最后那个rangeTo有些不符合人的直觉，下面讲到contains的时候会一起提到，读者可以暂时放下这个问题。</p>
<p>然后是下标访问操作符：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">Any</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>, value: <span class="type">Any</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get接收任意数量的int参数，假设它们是index1, index2, index3（以此类推），<br>那么对应的操作符就是对应维数个下标的访问。比如以下例子，操作符对应的方法调用写在行尾注释里了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = A()</div><div class="line">  a[<span class="number">1</span>] <span class="comment">// a.get(1)</span></div><div class="line">  a[<span class="number">1</span>][<span class="number">2</span>] <span class="comment">// a.get(1, 2)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的set接收任意数量个int，以及一个任意类型的对象，表示将下标访问作为左值并赋值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = A()</div><div class="line">  a[<span class="number">1</span>] = <span class="number">233</span> <span class="comment">// a.set(1, 233)</span></div><div class="line">  a[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"666"</span> <span class="comment">// a.set(1, 2, "666")</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>invoke方法允许你把一个Kotlin对象当作Lambda表达式来使用。关于什么是Lambda表达式下文会专门介绍。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(obj: <span class="type">Any</span>?)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = A()</div><div class="line">  a(obj) <span class="comment">// 实际上调用了 a.invoke(obj)</span></div><div class="line">  <span class="comment">// 还可以</span></div><div class="line">  A()(obj)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自增自减运算符就更简单了，它们必须返回自己所在类的子类型。这里直接在注释里面写出对应的操作符表达：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设a是A的一个实例</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">inc</span><span class="params">()</span></span> = A() <span class="comment">// a++</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">dec</span><span class="params">()</span></span> = A() <span class="comment">// a--</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryPlus</span><span class="params">()</span></span> = A() <span class="comment">// ++a</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryMinus</span><span class="params">()</span></span> = A() <span class="comment">// --a</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有比较运算符，这是一个特殊的操作符重载，一个函数将会生成一组操作符。有一个特殊情况，就是相等的判断。</p>
<p>考虑以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Any</span>?)</span></span> = <span class="number">0</span></div><div class="line">  <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span> = <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当一个类只有compareTo没有equals的时候，所有的六个比较运算符（\&lt;, >, \&lt;=, >=, ==, !=）会被全部代理给compareTo函数的返回值和0的大小比较：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  A() &gt; A() <span class="comment">// A().compareTo(A()) &gt; 0</span></div><div class="line">  A() &lt; A() <span class="comment">// A().compareTo(A()) &gt; 0</span></div><div class="line">  A() &gt;= A() <span class="comment">// A().compareTo(A()) &gt;= 0</span></div><div class="line">  A() &lt;= A() <span class="comment">// A().compareTo(A()) &lt;= 0</span></div><div class="line">  A() == A() <span class="comment">// A().compareTo(A()) == 0</span></div><div class="line">  A() != A() <span class="comment">// A().compareTo(A()) != 0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有equals，==和!=两个操作符会被代理给equals方法，其余不变。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  A() == A() <span class="comment">// A().equals(A())</span></div><div class="line">  A() != A() <span class="comment">// !A().equals(A())</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有一个操作符，这个操作符不是严格意义上的“操作符”，但它比起其它的操作符重载，它还多了一个特权。它就是in操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">Any</span>?)</span></span> = <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它要求返回Boolean，传入一个参数。调用的话使用in：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> ls = listOf(<span class="number">12</span>, <span class="number">233</span>, <span class="number">43</span>)</div><div class="line">  println(<span class="number">233</span> <span class="keyword">in</span> ls)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的in就是调用了ls的contains方法。这里你可能要问了：既然是使用in这个符合Kotlin函数命名规范的表达，为什么不使用中缀表达式呢？</p>
<p>想清楚了，我们暂且不说in其实是Kotlin保留字这个问题，中缀表达式的语法是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  a.func(b)</div><div class="line">  <span class="comment">// 变成</span></div><div class="line">  a func b</div><div class="line">  <span class="comment">// 它不能变成</span></div><div class="line">  <span class="comment">// b func a</span></div><div class="line">  <span class="comment">// 上面那个是错的，会变成b.func(a)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是a in b其实是调用了b的一个方法，因此中缀表达式无法实现这个in。</p>
<p>前面说到contains操作符有一个特权，我们来看看这个特权。还记得when语句吗？它非常灵活，比Java风格的switch不知道高到哪里去了。这里先看一个基本用法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = Random(System.currentTimeMillis()).nextInt()</div><div class="line">  <span class="keyword">when</span> (a) &#123;</div><div class="line">    <span class="number">1</span> -&gt; &#123; <span class="comment">/* codes */</span> <span class="number">233</span> &#125;</div><div class="line">    <span class="number">2</span> -&gt; <span class="number">233</span></div><div class="line">    <span class="keyword">else</span> -&gt; <span class="number">666</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它可以配合contains方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = Random(System.currentTimeMillis()).nextInt()</div><div class="line">  <span class="keyword">when</span> (a) &#123;</div><div class="line">    <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span> -&gt; <span class="number">233</span></div><div class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; <span class="number">2333</span></div><div class="line">    <span class="keyword">else</span> -&gt; <span class="number">666</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到了吗？in还可以这样写哦。</p>
<p>还有一组运算符，它们将被编译为相同的一个操作符，也是in，只不过场合不同。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span> = <span class="literal">false</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span> = <span class="built_in">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个in是用于for-in循环的。上面例子中的for循环使用的是这个in操作符。</p>
<p>一个标准的Kotlin风格的for循环应该是下面这样的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它和下面的代码完全等价：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> range = <span class="number">1.</span><span class="number">.10</span></div><div class="line">  <span class="keyword">val</span> item = range.iterator()</div><div class="line">  <span class="keyword">while</span> (item.hasNext()) &#123;</div><div class="line">    println(item.next())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还记得那个step吗？它其实是对1..100调用了一个中缀的方法step。这下读者对于前面遗留的疑问就全部解决了。</p>
<p>Kotlin关于操作符重载的内容确实比较繁杂，但是比起C++的操作符重载还是要强大那么一点点的（C++没有in这种操作符）。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>好了这是函数式编程的重头戏——<a href="https://en.wikipedia.org/wiki/Lambda_expression" target="_blank" rel="external">Lambda表达式</a>。</p>
<p>Lambda表达式俗称匿名函数，熟悉Java的大家应该也明白这是个什么概念。Kotlin的Lambda表达式更“纯粹”一点，<br>因为它是真正把Lambda抽象为了一种类型，而Java只是单方法匿名接口实现的语法糖罢了。</p>
<p>Lambda在Java中非常常用，这里不再单独介绍它。</p>
<p>Lambda表达式最常用的地方之一是为GUI控件设置监听器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> button = JButton(<span class="string">"Clear screen"</span>)</div><div class="line">  button.addActionListener &#123;</div><div class="line">    output.text = <span class="string">""</span></div><div class="line">    output.append(<span class="string">"Repl.HINT"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有调用集合框架抽象出来的<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">高阶函数</a>（Higher Order Function）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  (<span class="number">1.</span><span class="number">.10</span>).forEach &#123;</div><div class="line">    println(it)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码可能会令读者产生疑惑，那个it是什么鬼？</p>
<p>it是Kotlin为单参数的Lambda钦定的默认参数名。单参数的Lambda可以省去参数的声明，转而使用it这个名字。</p>
<p>首先，我们有无参数的Lambda表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以直接把它写在外面，并且把它当成对象使用。Lambda对象有缺省的invoke函数的实现，也就是调用这个Lambda：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  &#123; println(<span class="string">"invoking lambda"</span>) &#125;.invoke()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以使用操作符重载的方式调用invoke函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  &#123; println(<span class="string">"invoking lambda"</span>) &#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个Lambda有参数，那么需要使用这样的语法声明：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="comment">// &#123;参数名:参数类型 -&gt; Lambda体&#125;()</span></div><div class="line">  &#123; str: String -&gt; println(str) &#125;(<span class="string">"the deep dark fantasy"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有多个参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="comment">// &#123;参数名:参数类型, 参数名:参数类型 -&gt; Lambda体&#125;()</span></div><div class="line">  &#123; str: String, num: <span class="built_in">Int</span> -&gt;</div><div class="line">    println(<span class="string">"num = <span class="subst">$num</span>, str = <span class="subst">$str</span>"</span>)</div><div class="line">  &#125;(<span class="string">"the deep dark fantasy"</span>, <span class="number">233</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lambda变量的签名不需要写参数名，只需要写类型。Lambda的返回值就是最后一个表达式的返回值。就像这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="comment">// 只需要写类型，我没骗你吧</span></div><div class="line">  <span class="keyword">val</span> value: (String, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span></div><div class="line">  value = &#123; str: String, num: <span class="built_in">Int</span> -&gt;</div><div class="line">    println(<span class="string">"num = <span class="subst">$num</span>, str = <span class="subst">$str</span>"</span>)</div><div class="line">    num</div><div class="line">  &#125;</div><div class="line">  value(<span class="string">"the deep dark fantasy"</span>, <span class="number">233</span>) + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果Lambda的参数、返回值类型不匹配，互相赋值是会报错的哦。</p>
<p>当然，Lambda经常作为函数参数使用。</p>
<ul>
<li>如果一个Lambda是一个函数的最后一个参数，Kotlin为这种情况专门提供了一个语法糖。</li>
<li>Lambda在作为匿名变量传递给函数时，不需要显式声明参数类型（因为可以根据函数参数那里的类型签名推导）。</li>
</ul>
<p>上面两句话如何理解呢？比如你有一个自定义UI控件：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinButton</span> : <span class="type">View</span></span>() &#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(block: (<span class="type">View</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">    <span class="comment">// set</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后调用的时候就可以使用这个语法糖了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(save: <span class="type">Bundle</span>?)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> a = KotlinButton()</div><div class="line">    <span class="comment">// 原本是：</span></div><div class="line">    <span class="comment">// a.setOnClickListener(&#123; view -&gt;</span></div><div class="line">    <span class="comment">//   toast("Clicked")</span></div><div class="line">    <span class="comment">// &#125;)</span></div><div class="line">    <span class="comment">// 语法糖省去了表示参数的括号，直接写Lambda</span></div><div class="line">    a.setOnClickListener &#123; view -&gt;</div><div class="line">    <span class="comment">// 编译器的类型推导省去了 view: View 的类型声明</span></div><div class="line">      toast(<span class="string">"Clicked"</span>)</div><div class="line">      view.text = <span class="string">"Oh my god"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面那段代码是Android的，熟悉的API看出来了吗？</p>
<p>你甚至还可以把那个view参数的声明给省了，因为只有一个参数，可以使用it代替：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  a.setOnClickListener &#123;</div><div class="line">    toast(<span class="string">"Hia hia"</span>)</div><div class="line">    it.text = <span class="string">"clicked"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个函数不只是有一个参数，但是最后一个参数（依然符合条件），那么可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  a.callSomeMethods(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &#123;</div><div class="line">    <span class="comment">// do something</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它完全等价于：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    a.callSomeMethods(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;</div><div class="line">      <span class="comment">// do something else</span></div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你不需要用到那个参数，又不想为它命名，那么使用下划线代替它吧。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  a.setOnClickListener &#123; _ -&gt;</div><div class="line">    toast(<span class="string">"LOL LOL LOL"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时你可能会问：上面那个代码完全可以把整个<code>_ -&gt;</code>给省掉啊？不是说单参数可以省吗？</p>
<p>因为多参数是不能省的（多参数Lambda不写参数会报错），所以它还是很有用的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).forEachIndexed &#123; _, _ -&gt;</div><div class="line">    println(<span class="string">"Looping!"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后说的这个下划线的特性是Kotlin1.1才引入的。</p>
<p><strong>请读者注意不要混淆上面的两个“多参数”，第一处说的是函数多参数，第二处说的是Lambda多参数。</strong></p>
<p>我们可以通过Lambda表达式来勉强地实现函数的<a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="external">柯里化</a>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">Int</span>)</span></span> = &#123; b: <span class="built_in">Int</span> -&gt; a + b &#125;</div></pre></td></tr></table></figure>
<p>调用就可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  println(plus(<span class="number">233</span>)(<span class="number">666</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这有什么用呢？可以实现一个函数的<a href="https://en.wikipedia.org/wiki/Partial_application" target="_blank" rel="external">部分应用</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = plus(<span class="number">233</span>)</div><div class="line">  <span class="comment">// 然后呱啦呱啦呱啦一堆东西</span></div><div class="line">  <span class="keyword">val</span> pluser2 = getIntFromSomewhere()</div><div class="line">  println(a(pluser2))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和泛型结合之后可以泛化出上面那个函数的抽象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B, C&gt;</span> <span class="params">((a: <span class="type">A</span>, b: <span class="type">B</span>)</span></span> -&gt; C).curry() =</div><div class="line">    &#123; a: A -&gt; &#123; b: B -&gt; invoke(a, b) &#125; &#125;</div></pre></td></tr></table></figure>
<p>plus就可以这样被抽象出来：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> plusOrigin = &#123; a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span> -&gt;</div><div class="line">    a + b</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">val</span> a = plusOrigin.curry()</div><div class="line">  a(<span class="number">233</span>)(<span class="number">666</span>) <span class="comment">// 和上面那个就是一样的了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还可以做出多参数的柯里化的抽象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B, C, D, E, F, G&gt;</span></span></div><div class="line"> ((a: A, b: B, c: C, d: D, e: E, f: F) -&gt; G).curry() =</div><div class="line">     &#123; a: A -&gt; &#123; b: B -&gt; &#123; c: C -&gt; &#123; d: D -&gt; &#123; e: E -&gt;</div><div class="line">     &#123; f: F -&gt; invoke(a, b, c, d, e, f) &#125; &#125; &#125; &#125; &#125; &#125;</div></pre></td></tr></table></figure>
<p>这样的抽象可以用于更多参数的函数的柯里化：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> makeString = &#123; a: <span class="built_in">Int</span>,</div><div class="line">                     b: <span class="built_in">Short</span>,</div><div class="line">                     c: String,</div><div class="line">                     d: File,</div><div class="line">                     e: URL,</div><div class="line">                     f: <span class="built_in">Double</span> -&gt;</div><div class="line">    <span class="string">"<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span> <span class="subst">$d</span> <span class="subst">$e</span> <span class="subst">$f</span>"</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">val</span> a = makeString.curry()</div><div class="line">  <span class="comment">// 调用方法一</span></div><div class="line">  a(<span class="number">233</span>)(<span class="number">666</span>)(<span class="string">"Gensokyo"</span>)(File(<span class="string">"./README.md"</span>))(URL(</div><div class="line">  <span class="string">"https://github.com/ice1000"</span>))(<span class="number">1.0</span>)</div><div class="line">  <span class="comment">// 调用方法二</span></div><div class="line">  a(<span class="number">233</span>)</div><div class="line">      .invoke(<span class="number">666</span>)</div><div class="line">      .invoke(<span class="string">"Gensokyo"</span>)</div><div class="line">      .invoke(File(<span class="string">"./README.md"</span>))</div><div class="line">      .invoke(URL(<span class="string">"https://github.com/ice1000"</span>))</div><div class="line">      .invoke(<span class="number">1.0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是这样。</p>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>函数调用写法和Java几乎完全一样，比如调用上面声明的几个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  functionWithGenericsParam(<span class="number">233</span>)</div><div class="line">  functionReturnsNothing()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>已经说过了Lambda的invoke写法所以这里不再提及。</p>
<p>当你需要调用一个接收了“有返回值的Lambda”的函数时，这样的写法是会报错的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  function &#123;</div><div class="line">    println(<span class="string">"Hi there!"</span>)</div><div class="line">    <span class="comment">// 下面这句会报错！</span></div><div class="line">    <span class="comment">// return 233</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为这样的return语句在被inline之后，编译器不知道你是要return掉main函数还是这个Lambda。</p>
<p>因此你需要显式声明return的作用域：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  function &#123;</div><div class="line">    println(<span class="string">"Hi there!"</span>)</div><div class="line">    <span class="keyword">return</span><span class="symbol">@function</span> <span class="number">233</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这叫做“Label return”，其中<code>return@</code>后面的标签（Label）是你要return的Lambda所传递给的函数名（比如上面就是function）。</p>
<p>如果你的函数名是kotlinIsAwesome，那么你就需要这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  kotlinIsAwesome &#123;</div><div class="line">    <span class="keyword">return</span><span class="symbol">@kotlinIsAwesome</span> <span class="number">233</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你使用IntelliJ IDEA，它会告诉你你需要写什么标签。</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>顾名思义，就是把函数体给内联到调用处。这对程序的逻辑是没有影响的，只是对一些无关逻辑的因素有影响，比如：</p>
<ul>
<li>运行效率</li>
<li>目标文件体积</li>
<li>重构上的优越性</li>
</ul>
<p>等等。</p>
<p>比如标准库的一堆函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Prints the given message to the standard output stream. */</span></div><div class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</div><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(message: <span class="type">Any</span>?)</span></span> &#123;</div><div class="line">    System.<span class="keyword">out</span>.print(message)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内联函数最好的好处就是直接内联Lambda，不产生匿名内部类对象。这是一个非常黑的黑科技，<br>减少Lambda对象的数量可以既保证函数式的优美代码，又不必为Lambda对象的开销买单。</p>
<p>如果一个内联函数没有内联到Lambda表达式，那么Kotlin编译器会给出一个警告——<br>因为inline本身就只是为了inline掉Lambda而准备的特性，标准库会有一些专门用于内联的函数（后面会讲到）。<br>inline一些无关紧要的函数反而会导致无谓的体积增加（JVM本身就会在运行时内联不少函数）。</p>
<p>Kotlin-discussion曾经出现过一个帖子，楼主说他太喜欢inline这个功能了，<br>以至于把大量的大型函数inline的到处都是，最后导致了jar体积的肥大。</p>
<h3 id="crossinline与noinline"><a href="#crossinline与noinline" class="headerlink" title="crossinline与noinline"></a>crossinline与noinline</h3><p>crossinline是一种比普通inline更高级的inline方法，它只能修饰Lambda参数，<br>用于处理一些奇怪的Lambda的内部return（有时你只是想return掉Lambda，但是内联后会导致return掉外部context）。</p>
<p>Kotlin编译器使用了一些奇怪的方法来复用内联Lambda产生的参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">crossInlineFunction</span><span class="params">(<span class="keyword">crossinline</span> f: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  f.invoke()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>noinline也只能用于修饰Lambda参数，表示在内联这个函数的情况下，不对这个Lambda进行内联优化<br>（即：依然针对Lambda产生一个匿名内部类对象，开销和Java的就一样了。<br>有些情况编译器无法内联这个Lambda，只能提示你加上noinline。这里不再展开讲解）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">noInlineFunction</span><span class="params">(<span class="keyword">noinline</span> f: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  f.invoke()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，请读者尽可能遵循标准规定：仅对接收Lambda的函数使用内联。</p>
<h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>扩展可谓是Kotlin的“killer feature”，它只是一个语法糖，却是一个（有时）难以理解的语法糖，一般黑带Kotlin程序员会谨慎并大量地使用它。</p>
<p>在IDE的帮助下，扩展对原库的污染已经不再是污染，因为扩展和原方法会被高亮给清晰地区分开。</p>
<p>下文中，有时会把扩展函数称为扩展方法，指的实际上是同一个概念。</p>
<h3 id="普通的扩展函数"><a href="#普通的扩展函数" class="headerlink" title="普通的扩展函数"></a>普通的扩展函数</h3><p>说了这么多，扩展到底是什么呢？</p>
<blockquote>
<p>就是使用一些语法糖来假装给一些类添加方法，并像真正的方法一样调用它。</p>
</blockquote>
<p>为什么要“假装给类添加方法”呢？</p>
<blockquote>
<p>你有种给java.io.File类添加一个openOrCreate方法啊？</p>
</blockquote>
<p>（以上调侃并不适用于rt.jar开发人员）</p>
<p>你可能还是不能理解这是什么，那么看看下面的例子吧：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> ls = java.util.ArrayList&lt;<span class="built_in">Int</span>&gt;()</div><div class="line">  ls.add(<span class="number">233</span>)</div><div class="line">  ls.add(<span class="number">666</span>)</div><div class="line">  ls.add(<span class="number">555</span>)</div><div class="line">  ls.add(<span class="number">1024</span>)</div><div class="line">  <span class="keyword">val</span> sum = ls.fold(<span class="number">0</span>) &#123; sum, value -&gt;</div><div class="line">    sum + value</div><div class="line">  &#125;</div><div class="line">  println(sum)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码使用Kotlin1.1第一个正式版编译器编译通过。在JRE1.8_101上完美运行。</p>
<p>你肯定知道，java.util.ArrayList是没有fold这个方法的。</p>
<p>那上面的代码是怎么回事？为什么我可以在ls对象上调用一个它本来没有的方法呢？</p>
<p>这完全符合刚才的定义：</p>
<blockquote>
<p>像真正的方法一样调用它。</p>
</blockquote>
<p>那么我们来看看这个方法怎么实现吧。这里不使用集合框架，而是使用另一个例子：给File类增加一个openOrCreate方法。</p>
<p>首先，我们可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">openOrCreate</span><span class="params">(file: <span class="type">java</span>.<span class="type">io</span>.<span class="type">File</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> (!file.exists()) file.createNewFile()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后这样调用它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  openOrCreate(File(<span class="string">"./save.txt"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果我们希望一种更优美的方式，我们可以使用这个语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">openOrCreate</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> (!exists()) createNewFile()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>卧槽！那个<code>if (!exists())</code>看起来就像是直接写在File类内部的方法一样啊！</p>
<p>其实这里是个小小的trick，编译器会这样处理它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">openOrCreate</span><span class="params">(receiver: <span class="type">File</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> (!receiver.exists()) receiver.createNewFile()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，如果将<code>fun openOrCreate(receiver: File)</code>写成<code>fun File.openOrCreate()</code>，<br>那么这个函数可以直接调用File类的方法，就像它自己也是一个File类的方法一样。编译过后它会被处理为对receiver的方法调用。</p>
<p>也就是说，这种扩展方法是不能调用private、protected以及internal的属性/方法的（因为它事实上就是一个普普通通的函数罢了）。</p>
<p>我们来看看它的调用吧：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> file = File(<span class="string">"./save.png"</span>)</div><div class="line">  file.openOrCreate()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是很有趣啊？</p>
<p>而且，在意识到了这只是一个普通方法后，你可能会问：能不能将它当成普通函数而不是方法运行呢？</p>
<p>当然。。。。。不可以：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> file = File(<span class="string">"./save.png"</span>)</div><div class="line">  openOrCreate(file) <span class="comment">// error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，你也可以在一个类里面对另一个类进行扩展：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(<span class="keyword">val</span> int: <span class="built_in">Int</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> A.<span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line">    println(int)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">anotherFunction</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> a = A()</div><div class="line">    a.someFunction()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这也是合法的。</p>
<p>在一个扩展函数内部，this所指向的就是receiver。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">openOrCreate</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.exists()) <span class="keyword">this</span>.createNewFile()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读者可以通过在扩展函数内部调用<code>println(this)</code>来验证。</p>
<h3 id="扩展Lambda"><a href="#扩展Lambda" class="headerlink" title="扩展Lambda"></a>扩展Lambda</h3><p>其实扩展还有一种用途，就是使一个Lambda成为“扩展Lambda”：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> extensionLambda = <span class="built_in">Int</span>.&#123; println(<span class="keyword">this</span>) &#125;</div><div class="line">  <span class="number">233.</span>extensionLambda() <span class="comment">// OK</span></div><div class="line">  extensionLambda(<span class="number">233</span>) <span class="comment">// OK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到了吗？Lambda表达式也可以被理解为是“对一个类进行扩展的Lambda”表达式。<br>也就是说，它也可以像扩展方法一样，从内部拿到一个特定的this，然后将它作为一个扩展使用。</p>
<p>扩展Lambda也可以作为一个函数的参数。</p>
<p>不同于扩展函数，扩展Lambda可以被当作一个非扩展Lambda。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">applyToFile</span><span class="params">(block: <span class="type">File</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  <span class="keyword">val</span> file = File()</div><div class="line">  file.block() <span class="comment">// OK</span></div><div class="line">  block(file) <span class="comment">// OK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么写，没人拦着你，我不会拦着你，编译器也不会拦着你。这个代码和上面的代码都是合法的Kotlin代码。</p>
<p>注意，以上代码仅为演示语法，是没有实际意义的。</p>
<p>我们还可以结合扩展函数和扩展Lambda：将一个扩展Lambda作为一个扩展函数的参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">run</span><span class="params">(block: <span class="type">File</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  <span class="keyword">this</span>.block() <span class="comment">// OK</span></div><div class="line">  block(<span class="keyword">this</span>) <span class="comment">// OK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>this一般可以省略，所以有：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">run</span><span class="params">(block: <span class="type">File</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  block()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还可以结合Kotlin的“expression body”：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">run</span><span class="params">(block: <span class="type">File</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) = block()</div></pre></td></tr></table></figure>
<p>在调用的时候，可以再结合一下Kotlin的Lambda参数语法糖：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> file = File(<span class="string">"./save.log"</span>)</div><div class="line">  file.run &#123;</div><div class="line">    <span class="keyword">if</span> (!exists()) createNewFile()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这相当于是给File类提供了一个run的工具函数，它可以把一个Lambda应用到file对象。</p>
<p>请读者确保自己能读懂以上代码，它用到了很多Kotlin的（比较）高级的特性：</p>
<ul>
<li>扩展函数</li>
<li>扩展Lambda</li>
<li>Lambda作为最后一个参数的简化写法</li>
</ul>
<p>到这里就结束了吗？</p>
<p>不，你可能已经相到了另一个JVM支持的特性，它和扩展结合起来能做到更优美。</p>
<p>还记得吗？这是JVM很早就引入的一个特性。</p>
<p><strong>泛型</strong>。</p>
<h3 id="泛型扩展"><a href="#泛型扩展" class="headerlink" title="泛型扩展"></a>泛型扩展</h3><p>首先考虑如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runWith</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  receiver.block()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数用泛型抽象了一个“runWith”的概念，也就是说传入一个对象和一个扩展给该对象的类型的Lambda，然后在这个对象上调用这个Lambda：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> file = File(<span class="string">"./save.svg"</span>)</div><div class="line">  runWith(file) &#123;</div><div class="line">    <span class="keyword">if</span> (!exists()) createNewFile()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> int = <span class="number">233</span></div><div class="line">  runWith(int) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> &lt;= <span class="number">100</span>) println(<span class="string">"smaller than 100, or equaled."</span>)</div><div class="line">    <span class="keyword">else</span> println(<span class="string">"bigger than 100."</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再结合扩展：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  block() <span class="comment">// OK</span></div><div class="line">  <span class="keyword">this</span>.block() <span class="comment">// OK</span></div><div class="line">  block(<span class="keyword">this</span>) <span class="comment">// OK</span></div><div class="line">  block.invoke(<span class="keyword">this</span>) <span class="comment">// OK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面展示了四种截然不同但是完全等价的调用block的方法，读者在抄代码的时候请只保留一个。</p>
<p>这个run变得更玄学了，可以直接在任意类型的任意对象上调用run方法了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  Random().nextInt(<span class="number">200</span>).run &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> &lt;= <span class="number">100</span>) println(<span class="string">"smaller than 100, or equaled."</span>)</div><div class="line">    <span class="keyword">else</span> println(<span class="string">"bigger than 100."</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还记得吗？接收Lambda对象的函数是被建议写为inline的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  block()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样省去了Lambda传递的开销，和朴素写法就<strong>完全</strong>等价了。</p>
<p>所以亲爱的读者，还记得之前提到的集合框架多出来的fold方法吗？这是内置在Kotlin标准库的扩展函数。</p>
<p>Kotlin的标准库，基本由扩展函数组成。它通过扩展，结合Java标准库本身已经有的一个非常强大的集合框架，<br>通过打包后仅仅700kb的jar作为标准库，却非比寻常的强大。</p>
<p>我们来看看其它JVM语言的做法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:right">做法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:right">做的再烂也是所有JVM语言的爸爸，想打我的人多了去了你算老几</td>
</tr>
<tr>
<td style="text-align:left">Scala</td>
<td style="text-align:right">自己从头造了一个集合框架，通过隐式转换实现和Java标准库的集合框架的无缝衔接，但是开销比较大，不仅仅是运行开销，还有debug开销</td>
</tr>
<tr>
<td style="text-align:left">Clojure</td>
<td style="text-align:right">自己造了一个Lisp风格的集合框架（序列框架），Lisp的语法自带扩展效果</td>
</tr>
<tr>
<td style="text-align:left">Groovy</td>
<td style="text-align:right">相当于是从rt.jar里面抄了一些代码改成Groovy风格的形式，和Java没有互操作</td>
</tr>
<tr>
<td style="text-align:left">JRuby/Mirah</td>
<td style="text-align:right">不存在交互问题，因为这两门语言本身就不适合用于上面几门语言的领域（其实也没有交互）</td>
</tr>
</tbody>
</table>
<p>相比之下，Kotlin这种做法是非常友善的（inline零开销，完美利用rt.jar，而且可以随心所欲地扩展）。</p>
<h3 id="关于扩展是否会污染原库的讨论"><a href="#关于扩展是否会污染原库的讨论" class="headerlink" title="关于扩展是否会污染原库的讨论"></a>关于扩展是否会污染原库的讨论</h3><p>曾经Kotlin社区有人询问过关于扩展函数是否会污染原库的问题。</p>
<p>JetBrains显然考虑到了这点，他们通过IDE插件将两种方法高亮成了不同颜色，完美区分了普通方法和扩展方法：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://coding.net/u/ice1000/p/Images/git/raw/master/blog-img/3/1.PNG" alt="ide" title="">
                </div>
                <div class="image-caption">ide</div>
            </figure>
<p>如果你是IntelliJ IDEA用户，那么应该早就注意到这一点了。</p>
<p>缺省设置是黄色，可以在这里调整：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://coding.net/u/ice1000/p/Images/git/raw/master/blog-img/3/2.PNG" alt="settings" title="">
                </div>
                <div class="image-caption">settings</div>
            </figure>
]]></content>
    
    <summary type="html">
    
      Kotlin functions for Kotlin Primer
    
    </summary>
    
      <category term="编程语言" scheme="http://www.Kotliner.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="函数式编程" scheme="http://www.Kotliner.cn/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[译]Kotlin 1.1 Event Report</title>
    <link href="http://www.Kotliner.cn/2017/04/06/Kotlin%201.1%20Event%20Report/"/>
    <id>http://www.Kotliner.cn/2017/04/06/Kotlin 1.1 Event Report/</id>
    <published>2017-04-06T15:21:00.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 1.1 版本发布在社区反响很好。为了演示 Kotlin 1.1 的新功能，JetBrains 提供了一个在线活动。所有感兴趣的人都可以观看 Andrey Breslav 的在线直播演示，并在 Q&amp;A 环节获得他们关心的问题的答案。<br>这激发了许多当地社区组织见面会：超过 30 个用户组在 21 个国家举办了线下活动。<br>你可以在这里找到完整的活动列表 <a href="http://kotlinlang.org/community/talks.html?time=kotlin" target="_blank" rel="external">Kotlin社区网页</a> 。活动当天有 3000 多人参加了线上直播。<br>演示和 Q&amp;A 视频可以在 YouTube 上查看：</p>

<p><iframe allowfullscreen="allowfullscreen" frameborder="0" height="450" src="https://www.youtube.com/embed/zpyJHSR-5ts" width="800"></iframe></p>


<p><span id="more-4802"></span></p>

<h2 id="Kotlin-1-1-活动反馈"><a href="#Kotlin-1-1-活动反馈" class="headerlink" title="Kotlin 1.1 活动反馈"></a>Kotlin 1.1 活动反馈</h2><p>如果你看了直播，我们想知道你的想法！请 <a href="https://docs.google.com/forms/d/e/1FAIpQLSdgKsJzwc1ToAusi-xpEiiE1O4t3HA5xjlbZXDU5Mg0i3qvNg/viewform" target="_blank" rel="external">填写此表格</a> 分享您的反馈。它只需要大约7-10分钟。您的投入对于帮助我们改进未来的 Kotlin 活动非常重要。</p>
<h2 id="Kotlin-未来特性调查"><a href="#Kotlin-未来特性调查" class="headerlink" title="Kotlin 未来特性调查"></a>Kotlin 未来特性调查</h2><p><img alt="future_features_collage_2" class="size-full wp-image-4907 aligncenter" src="https://d3nmt5vlzunoa1.cloudfront.net/kotlin/files/2017/04/collage_2.png" width="800"><br></p>
<p>我们还向所有社区提供了对 Kotlin 未来的影响。活动组织者收到了调查表，活动参与者可以在线下对最期望的功能发表看法。调查得到很多关注，我们现在已经把它放在网上，以听取更广泛的社区建议。现在你可以在线给 <a href="https://docs.google.com/forms/d/e/1FAIpQLSdnCgBonEV5pwN8L903BzdYb9Baf0dpwsJ5YrKnxLveiLFkEQ/viewform" target="_blank" rel="external"> Kotlin 的未来提供你的建议</a>  ！<br>请注意，你在 v1.2 中有很大可能看不到这些功能，但我们会在确定工作优先级时考虑您的意见。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 1.1 版本发布在社区反响很好。为了演示 Kotlin 1.1 的新功能，JetBrains 提供了一个在线活动。所有感兴趣的人都可以观看 Andrey Breslav 的在线直播演示，并在 Q&amp;amp;A 环节获得他们关心的问题的答案。&lt;br&gt;这激发了许多当
    
    </summary>
    
      <category term="官方动态" scheme="http://www.Kotliner.cn/categories/%E5%AE%98%E6%96%B9%E5%8A%A8%E6%80%81/"/>
    
    
  </entry>
  
  <entry>
    <title>[译]Kotlin 1.1 也适用于 Android 开发者</title>
    <link href="http://www.Kotliner.cn/2017/04/05/Kotlin%201.1%20is%20also%20for%20Android%20Developers/"/>
    <id>http://www.Kotliner.cn/2017/04/05/Kotlin 1.1 is also for Android Developers/</id>
    <published>2017-04-05T08:13:00.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 1.1的发布令人们感到非常兴奋。此版本包含的新功能对 Java 开发者非常有用，并将 引领 JVM 走向一个充满发展潜力的新世界。</p>
<p>但有些新功能，如 <a href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md" target="_blank" rel="external">coroutine</a> 和 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/type-aliases.md" target="_blank" rel="external">type alias</a>（下文有几个例子）对于 Android 开发者来说就像科幻小说。</p>
<p>我们仍然停留在几乎没有什么改进的古老 Java 6 中，迫使我们以其他平台已经被被遗忘的方式进行开发。</p>
<p>所以一个理所当然的问题是：Kotlin 团队能够保持与 Java 6 的兼容性，同时保留所有这些新功能吗？答案是：当然！</p>
<p><strong>所有新特性仍然兼容 Java 6 为 Android 开发者所用。</strong> 今天我想向您展示其中的一部分，看看它们是如何使你更容易的开发 Android 应用程式。</p>
<a id="more"></a>
<h1 id="type-alias-使你的-listener-更易读"><a href="#type-alias-使你的-listener-更易读" class="headerlink" title="type alias 使你的 listener 更易读"></a>type alias 使你的 listener 更易读</h1><p>当然 type alias 有很多不同的应用场景，不过我首先想到的是使用 lambda 作为 listener 的类型时会使代码更易读。</p>
<p>如果没接触过 <a href="https://github.com/Kotlin/KEEP/issues/4" target="_blank" rel="external">type alias</a> 的话，可以简单的理解为给复杂的类型名起个别名，使其更为可读。</p>
<p>例如你有个接收 listener 的 <code>RecyclerViewAdapter</code>。<code>RecyclerView</code> 没有 <code>ListView</code> 那样 标准的方式来处理条目点击事件，必须由开发者自己实现。</p>
<p>假如我们希望有一个可以访问 view 的 listener，那 adapter 可能如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span></span>(<span class="keyword">val</span> items: List&lt;Item&gt;, <span class="keyword">val</span> listener: (View) -&gt; <span class="built_in">Unit</span>) : RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;() &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而你的 <code>ViewHolder</code> 可能需要接收该 listener，才能将其分配给 view：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>, listener: (<span class="type">View</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        itemView.setOnClickListener(listener)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这不是一个复杂的例子，但是正如你所看到的我们需要重复定义这个 lambda ，会导致这段代码不太好阅读。</p>
<p>但是现在我们可以创建一个代表点击 listener 的 type alias：<br><code>typealias ClickListener = (View) -&gt; Unit</code><br>然后在需要的每一个地方使用它：<br><code>class MyAdapter(val items: List&lt;Item&gt;, val listener: ClickListener)</code><br>或者<br><code>fun bind(item: Item, listener: ClickListener) { ... }</code></p>
<h1 id="data-class-更强大了"><a href="#data-class-更强大了" class="headerlink" title="data class 更强大了"></a>data class 更强大了</h1><p>data class 可以为我们避免大量的样板代码，但是它不能继承其它类所以某些情况下不可用。</p>
<p>Kotlin 1.1 取消了这个限制，例如 data class 可以定义为 sealed class 的子类了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">UiOp</span> </span>&#123;</div><div class="line">    <span class="keyword">object</span> Show : UiOp()</div><div class="line">    <span class="keyword">object</span> Hide : UiOp()</div><div class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Translate</span></span>(<span class="keyword">val</span> axis: Axis, <span class="keyword">val</span> amount: <span class="built_in">Int</span>): UiOp()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时 <strong>sealed class 可以在父类之外定义</strong>，就像这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">UiOp</span></span></div><div class="line"><span class="keyword">object</span> Show : UiOp()</div><div class="line"><span class="keyword">object</span> Hide : UiOp()</div><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Translate</span></span>(<span class="keyword">val</span> axis: Axis, <span class="keyword">val</span> amount: <span class="built_in">Int</span>) : UiOp()</div></pre></td></tr></table></figure>
<h1 id="在-lambda-中使用-destructuring"><a href="#在-lambda-中使用-destructuring" class="headerlink" title="在 lambda 中使用 destructuring"></a>在 lambda 中使用 destructuring</h1><p>从 Kotlin 最早的版本开始 data class 就能够使用 destructuring declarations 了，因为它会自动生成 <code>componentX()</code> 方法，借助这些方法可以将 data class 对象拆分成若干变量，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span>(<span class="keyword">val</span> text: String, <span class="keyword">val</span> url: String)</div><div class="line"> </div><div class="line"><span class="keyword">val</span> (text, url) = item</div></pre></td></tr></table></figure>
<p>可是在 Kotlin 1.1 之前你并不能在 lambda 上这么做。不过等待结束了！现在可以这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> = item.let &#123; (text, url) -&gt;</div><div class="line">    textView.text = text</div><div class="line">    imageView.loadUrl(url)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个改进十分适用于操作 Pair 和 Map 等类型的对象</p>
<h1 id="适用与局部变量的-delegated-property"><a href="#适用与局部变量的-delegated-property" class="headerlink" title="适用与局部变量的 delegated property"></a>适用与局部变量的 delegated property</h1><p>delegated property 已被证明是非常有用的，可以为类中的 property 提供附加的能力。</p>
<p>例如最有用的一个是 <strong>lazy property</strong>，它会推迟赋值操作，直到变量第一次使用。</p>
<p>但其实 lazy 对于局部变量来说也是十分有用的，而之前 Kotlin 缺乏这个功能。</p>
<p>现在通过 delegated property，我们可以做到：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testLocalDelegation</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> database <span class="keyword">by</span> lazy &#123; createDatabase() &#125;</div><div class="line">    <span class="keyword">val</span> cache <span class="keyword">by</span> lazy &#123; createMemoryCache() &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (mustUseDatabase()) &#123;</div><div class="line">        database.use &#123; ... &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        cache.use &#123; ... &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这个例子可以在没有使用 lazy 的情况下解决，但它有助于理解这个概念。</p>
<p>有一些占用比较多的对象不一定会被使用，可以通过使用 lazy 延迟实例化，直到我们初次使用它。</p>
<p>这时大括号内的代码会被执行，并且将结果缓存下来以备稍后再次使用。</p>
<h1 id="再也不用在-lambda-中定义未使用的变量了"><a href="#再也不用在-lambda-中定义未使用的变量了" class="headerlink" title="再也不用在 lambda 中定义未使用的变量了"></a>再也不用在 lambda 中定义未使用的变量了</h1><p>在 lambda 中定义了变量但最终没使用情况很常见。</p>
<p>这是因为在 Kotlin 1.0 中没有办法丢弃 lambda 中未使用的参数。</p>
<p>例如使用 delegated property 更新 RecyclerView adapter，我使用了以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items: List&lt;Content&gt; <span class="keyword">by</span> Delegates.observable(emptyList()) &#123;</div><div class="line">    prop, old, new -&gt;</div><div class="line">    autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>prop 变量从未被使用过，这时我们就可以使用下划线来替换它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items: List&lt;Content&gt; <span class="keyword">by</span> Delegates.observable(emptyList()) &#123;</div><div class="line">    _, old, new -&gt;</div><div class="line">    autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有种更糟的情况，如果 lambda 有多个参数，即使你一个也不用还是需要写上所有参数。现在我们可以忽略它们了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items: List&lt;Item&gt; <span class="keyword">by</span> Delegates.observable(emptyList()) &#123;</div><div class="line">    _, _, _ -&gt;</div><div class="line">    notifyDataSetChanged()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不仅可以定义较少的变量，而且代码还变得更易读了，那些有用的变量一眼就能看到。</p>
<h1 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h1><p>coroutine 是 Kotlin 1.1 中最令人兴奋的特性。尽管在此版本中带着“实验性”的标签，<strong>但 coroutine 功能齐全，你完全可以开始在项目中使用它们</strong>。</p>
<p>coroutine 能让你以同步的方式编写异步代码，允许你在某些时候暂停执行并等待结果，同时写下顺序相连代码。</p>
<p>您可能已经知道在 Kotlin 中 coroutine 并不是指一个库或者具体的实现，<strong>而是一种能力，通过它能够创建具有 coroutine 特性的库</strong>。</p>
<p>因此尽管某些代码看起来可能相似，但重要的是要知道创建这些辅助线程并返回主线程的“齿轮”是什么，这在 Android 中非常重要。</p>
<p>幸运的是 Kotlin 社区的动作很快，已经有几个库引入了 coroutine 方便我们在 Android 上使用。</p>
<p>首先来看看 Jetbrains 官方提供的：</p>
<ul>
<li><a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/ui/kotlinx-coroutines-android" target="_blank" rel="external">kotlinx-coroutines-android</a> 提供了在 Android 上使用 coroutine 的实现。</li>
<li><a href="https://github.com/Kotlin/anko" target="_blank" rel="external">Anko</a> 在其最新的 beta 版中改写了部分框架引入 coroutine。</li>
</ul>
<p>还有许多其他第三方库实现了自己的 coroutine 版本：</p>
<ul>
<li><a href="https://github.com/nhaarman/AsyncAwait-Android" target="_blank" rel="external">AsyncAwait-Android by Niek Haarman</a></li>
<li><a href="https://github.com/metalabdesign/AsyncAwait" target="_blank" rel="external">Async / Await by Metalab</a></li>
<li>如果你在寻找 Retrofit 的 coroutine 版本，那么可以试试 <a href="https://github.com/gildor/kotlin-coroutines-retrofit" target="_blank" rel="external">kotlin-coroutines-retrofit by Andrey Mischenko</a></li>
</ul>
<p>建议你们使用的时候看看它们是如何实现的，这就是开源的好处。</p>
<h1 id="其它对-Android-开发者有用的东西"><a href="#其它对-Android-开发者有用的东西" class="headerlink" title="其它对 Android 开发者有用的东西"></a>其它对 Android 开发者有用的东西</h1><p>这个版本还有更多的改进，但是我更想强调一些侧重于 Android 开发的内容。</p>
<p>首先，现在可以通过使用以下配置来启用 Jack 编译器的支持了：<code>jackOptions {true}</code>。虽然 Google 已经宣布放弃 Jack 工具链了，但是如果你对 Java 8 有需求那么会有一点用处，然后等到 Android Studio 2.4 的正式版发布就可以彻底弃用 Jack 了。（从 Android Studio 2.4 Preview 4 版本开始支持所有 Java 7 语言特性，部分 Java 8 语言特性）</p>
<p>另外介绍一个小技巧，就是用 <code>@JvmOverloads</code> <strong>来实现自定义 View</strong> 的构造函数，在 Kotlin 中借助参数默认值一个构造函数就能满足自定义 View 的多种构造需求（嗯，很长的一个构造函数）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</div><div class="line">        context: Context, attrs: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></div><div class="line">) : View(context, attrs, defStyleAttr) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>Kotlin 1.1 带来了大量的新功能，不禁让人产生为什么还要使用 Java 的想法。</p>
<p>Kotlin 为 Android 开发者带来的好处是毋庸置疑的，从现在开始使用 Kotlin 编写你的 Android 应用吧。</p>
<p>如果你想从头开始学习使用 Kotlin 开发 Android 应用，那么你应该会对 <a href="https://antonioleiva.com/kotlin-android-developers-book/" target="_blank" rel="external">Kotlin for Android Developers</a> 这本书感兴趣。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 1.1的发布令人们感到非常兴奋。此版本包含的新功能对 Java 开发者非常有用，并将 引领 JVM 走向一个充满发展潜力的新世界。&lt;/p&gt;
&lt;p&gt;但有些新功能，如 &lt;a href=&quot;https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;coroutine&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/Kotlin/KEEP/blob/master/proposals/type-aliases.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;type alias&lt;/a&gt;（下文有几个例子）对于 Android 开发者来说就像科幻小说。&lt;/p&gt;
&lt;p&gt;我们仍然停留在几乎没有什么改进的古老 Java 6 中，迫使我们以其他平台已经被被遗忘的方式进行开发。&lt;/p&gt;
&lt;p&gt;所以一个理所当然的问题是：Kotlin 团队能够保持与 Java 6 的兼容性，同时保留所有这些新功能吗？答案是：当然！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有新特性仍然兼容 Java 6 为 Android 开发者所用。&lt;/strong&gt; 今天我想向您展示其中的一部分，看看它们是如何使你更容易的开发 Android 应用程式。&lt;/p&gt;
    
    </summary>
    
      <category term="官方动态" scheme="http://www.Kotliner.cn/categories/%E5%AE%98%E6%96%B9%E5%8A%A8%E6%80%81/"/>
    
    
      <category term="Coroutine" scheme="http://www.Kotliner.cn/tags/Coroutine/"/>
    
      <category term="Android" scheme="http://www.Kotliner.cn/tags/Android/"/>
    
      <category term="typealias" scheme="http://www.Kotliner.cn/tags/typealias/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin视频教程</title>
    <link href="http://www.Kotliner.cn/2017/04/05/Kotlin%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/"/>
    <id>http://www.Kotliner.cn/2017/04/05/Kotlin视频教程/</id>
    <published>2017-04-05T03:40:48.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin从入门到『放弃』系列-视频教程"><a href="#Kotlin从入门到『放弃』系列-视频教程" class="headerlink" title="Kotlin从入门到『放弃』系列 视频教程"></a><a href="https://github.com/enbandari/Kotlin-Tutorials" target="_blank" rel="external">Kotlin从入门到『放弃』系列 视频教程</a></h1><p>随着Kotlin越来越成熟稳定，我已经开始在生产环境中使用它。考虑到目前国内资料较少，我录制了一套视频教程，希望以此抛砖引玉，让 Kotlin 在国内火起来。</p>
<p>个人水平有限，不足之处欢迎大家发邮件到 <a href="mailto: bennyhuo@println.net" target="_blank" rel="external">bennyhuo@println.net</a>，谢谢大家！</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>视频从2016年10月初开始发布，更新至12月中旬完结。精力有限，后续暂时每周一通过公众号推送 Kotlin 及 Java 生态的一些文章，大家有选题也可以直接联系我，目前已经有两篇是基于大家的反馈撰写的，反馈也比较不错，谢谢大家的关注与支持。</p>
<p><a href="http://v.qq.com/boke/gplay/903446d6231d8612d198c58fb86eb4dc_t6d000101bd9lx1.html" target="_blank" rel="external">在线收看全部视频（腾讯视频）</a></p>
<p><a href="http://pan.baidu.com/s/1nvGYAfB" target="_blank" rel="external">下载全部视频（百度云）</a></p>
<p>关注微信公众号：Kotlin， 获取最新视频更新动态</p>
<p><img src="/arts/Kotlin.jpg" width="250px"></p>
<p>加入 QQ 群 Kotlin ，162452394：</p>
<p><img src="/arts/e_group.png" width="250px"></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h4 id="01-Kotlin-简介"><a href="#01-Kotlin-简介" class="headerlink" title="01 Kotlin 简介"></a><a href="http://v.qq.com/page/z/u/9/z0337i7a3u9.html" target="_blank" rel="external">01 Kotlin 简介</a></h4><p>　　简要介绍下什么是 Kotlin，新语言太多了，大家为什么要接触 Kotlin 呢？因为它除了长得与 Java 不太像以外，其他的都差不多~
　　</p>
<h4 id="02-Hello-World"><a href="#02-Hello-World" class="headerlink" title="02 Hello World"></a><a href="http://v.qq.com/page/h/n/m/h0337jfa5nm.html" target="_blank" rel="external">02 Hello World</a></h4><p>　　千里之行，始于Hello World！
　　</p>
<h4 id="03-使用Gradle编写程序简介（可选）"><a href="#03-使用Gradle编写程序简介（可选）" class="headerlink" title="03 使用Gradle编写程序简介（可选）"></a><a href="http://v.qq.com/page/b/p/l/b03372ox4pl.html" target="_blank" rel="external">03 使用Gradle编写程序简介（可选）</a></h4><p>　　这年头，写 Java 系的代码，不知道 Gradle 怎么行呢？
　　</p>
<h4 id="04-集合遍历-map"><a href="#04-集合遍历-map" class="headerlink" title="04 集合遍历 map"></a><a href="http://v.qq.com/page/s/q/c/s033707mdqc.html" target="_blank" rel="external">04 集合遍历 map</a></h4><p>　　放下 i++，你不知道 map 已经占领世界了么？以前我以为 map-reduce 很牛逼，后来才知道就是数据迭代处理嘛。
　　</p>
<h4 id="05-集合扁平化-flatMap"><a href="#05-集合扁平化-flatMap" class="headerlink" title="05 集合扁平化 flatMap"></a><a href="http://v.qq.com/page/h/u/7/h0337scgau7.html" target="_blank" rel="external">05 集合扁平化 flatMap</a></h4><p>　　这个可以说是 map 的一个加强版，返回的仍然是开一个可迭代的集合，用哪个您自己看需求~
　　</p>
<h4 id="06-枚举类型与When表达式"><a href="#06-枚举类型与When表达式" class="headerlink" title="06 枚举类型与When表达式"></a><a href="http://v.qq.com/page/t/0/9/t0337iacg09.html" target="_blank" rel="external">06 枚举类型与When表达式</a></h4><p>　　Kotlin 丢掉了 switch，却引进了 when，这二者看上去极其相似，不过后者却要强大得多。至于枚举嘛，还是 Java 枚举的老样子。</p>
<h4 id="07-在-RxJava-中使用-Lambda"><a href="#07-在-RxJava-中使用-Lambda" class="headerlink" title="07 在 RxJava 中使用 Lambda"></a><a href="http://v.qq.com/x/page/l0340boeng7.html" target="_blank" rel="external">07 在 RxJava 中使用 Lambda</a></h4><p>　　这一期通过一个统计文章中字符数的小程序进一步给大家呈现 Lambda 的威力，也向大家展示一下如何在 Kotlin 当中优雅地使用 RxJava。我不做教科书，所以如果大家对概念感兴趣，可以直接阅读官方 <a href="https://kotlinlang.org/docs/reference/lambdas.html" target="_blank" rel="external">API</a></p>
<p>　　<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a> 是一个非常流行的 Java Reactive 框架，函数式的数据操作使得 Lambda 表达式可以充分体现自己的优势，比起 Java 的冗长，你会看到一段非常漂亮简洁的代码。建议大家先阅读 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a> 的官方文章以对其有一些基本的认识。
　　</p>
<h4 id="08-使用-Retrofit-发送-GET-请求"><a href="#08-使用-Retrofit-发送-GET-请求" class="headerlink" title="08 使用 Retrofit 发送 GET 请求"></a><a href="http://v.qq.com/x/page/t0342thu1al.html" target="_blank" rel="external">08 使用 Retrofit 发送 GET 请求</a></h4><p>　　<a href="https://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a> 是 Square 的 Jake 大神开源的RESTful 网络请求框架，用它发送请求的感觉会让你感觉爽爆的。我这里还有几篇文章，以及一个我 hack 过的分支 <a href="https://github.com/enbandari/HackRetrofit" target="_blank" rel="external">HackRetrofit</a>，有兴趣的童鞋可以一起探讨下~</p>
<ul>
<li><p><a href="http://www.println.net/post/Android-Hack-Retrofit" target="_blank" rel="external">Android 下午茶：Hack Retrofit 之 增强参数</a>.</p>
</li>
<li><p><a href="http://www.println.net/post/Android-Hack-Retrofit-Mock-Server" target="_blank" rel="external">Android 下午茶：Hack Retrofit (2) 之 Mock Server</a></p>
</li>
<li><p><a href="http://www.println.net/post/deep-in-retrofit" target="_blank" rel="external">深入浅出 Retrofit，这么牛逼的框架你们还不来看看？</a></p>
</li>
</ul>
<h4 id="09-尾递归优化"><a href="#09-尾递归优化" class="headerlink" title="09 尾递归优化"></a><a href="http://v.qq.com/x/page/f0345wmuw2m.html" target="_blank" rel="external">09 尾递归优化</a></h4><p>　　尾递归，顾名思义，就是递归中调用自身的部分在函数体的最后一句。我们知道，递归调用对于栈大小的考验是非常大的，也经常会因为这个导致 StackOverflow，所以尾递归优化也是大家比较关注的一个话题。Kotlin 支持语法层面的尾递归优化，这在其他语言里面是不多见的。</p>
<h4 id="10-单例"><a href="#10-单例" class="headerlink" title="10 单例"></a><a href="https://v.qq.com/x/page/w03659ate6w.html" target="_blank" rel="external">10 单例</a></h4><p>　　单例大家一定都不陌生，只要你动手写一个程序，就免不了要设计出一些全局存在且唯一的对象，他们就适合采用单例模式编写。在 Java 里面，单例模式的写法常见的有好几种，虽然简单却也是涉及了一些有意思的话题，那么在 Kotlin 当中我们要怎么设计单例程序呢？</p>
<h4 id="11-Sealed-Class"><a href="#11-Sealed-Class" class="headerlink" title="11 Sealed Class"></a><a href="https://v.qq.com/x/page/f0350ioskzj.html" target="_blank" rel="external">11 Sealed Class</a></h4><p>　　枚举类型可以很好的限制一个类型的实例个数，比如 State 枚举有两种类型 IDLE 和 BUSY 两种状态，用枚举来描述再合适不过。不过，如果你想要设计子类个数有限的数据结构，比如指令，指令的类型通常是确定的，不过对于某些有参数的指令每一次都使用同一个实例反而不合适，这时候就需要 Sealed Class。
　　
　　</p>
<h4 id="12-Json数据引发的血案"><a href="#12-Json数据引发的血案" class="headerlink" title="12 Json数据引发的血案"></a><a href="https://v.qq.com/x/page/s035296s9nw.html" target="_blank" rel="external">12 Json数据引发的血案</a></h4><p>　　Json 数据可真是大红大紫一番，它实在是太容易理解了，随着 Js 的火爆它就更加『肆无忌惮』起来。我们在 Java/Kotlin 当中解析它的时候经常会用到 Gson 这个库，用它来解析数据究竟会遇到哪些问题？本期主要围绕 Json 解析的几个小例子，给大家展示一下 Java/Kotlin 的伪泛型设计的问题，以及不完整的数据的解析对语言本身特性的冲击。</p>
<h4 id="13-kapt-以及它的小伙伴们"><a href="#13-kapt-以及它的小伙伴们" class="headerlink" title="13 kapt 以及它的小伙伴们"></a><a href="https://v.qq.com/x/page/q035439xksx.html" target="_blank" rel="external">13 kapt 以及它的小伙伴们</a></h4><p>　　首先感谢 @CodingPapi，这一期的内容主要来自于他的建议。</p>
<p>　　Kotiln 对于注解的支持情况在今年（2016）取得了较大的成果，现在除了对 @Inherited 这个注解的支持还不够之外，试用了一下没有发现太大的问题。关于 kapt，官方的文章罗列下来，其中</p>
<ul>
<li><p><a href="https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/" target="_blank" rel="external">kapt: Annotation Processing for Kotlin
</a> 已经过时了，大家可以阅读下了解其中提到的三个方案</p>
</li>
<li><p><a href="https://blog.jetbrains.com/kotlin/2015/06/better-annotation-processing-supporting-stubs-in-kapt/" target="_blank" rel="external">Better Annotation Processing: Supporting Stubs in kapt
</a> 提到的实现其实基本上就是现在的正式版</p>
</li>
<li><p><a href="https://blog.jetbrains.com/kotlin/2016/09/kotlin-1-0-4-is-here/" target="_blank" rel="external">Kotlin 1.0.4 is here
</a>提到了 kapt 的正式发布，需要注意的是，kapt 的使用方法有些变化，需要 <code>apply plugin: &#39;kotlin-kapt&#39;</code></p>
</li>
</ul>
<p>　　本期主要通过一个简单的 <a href="https://google.github.io/dagger/" target="_blank" rel="external">Dagger2</a> 实例给大家展示了注解在 Kotlin 当中的使用，看上去其实与在 Java 中使用区别不大，生成的源码也暂时是 Java 代码，不过这都不重要了，反正是要编译成 class 文件的。</p>
<p>　　后面我们又简单分析了一下 Dagger2 以及 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的源码（有兴趣的话也可以看下我直接对后者进行分析和 Hack 的一篇文章：<a href="http://www.println.net/post/Deep-in-ButterKnife-3" target="_blank" rel="external">深入浅出 ButterKnife，听说你还在 findViewById？</a>），其实自己实现一个注解处理器是非常容易的，类似的框架还有<a href="https://github.com/androidannotations/androidannotations" target="_blank" rel="external">androidannotations</a>，它的源码大家可以自行阅读。</p>
<hr>
<p>通过这个例子，我们其实发现 kapt 还是有一些不完善的地方，主要是：</p>
<ol>
<li>不支持 @Inherited </li>
<li>生成的源码需要手动添加到 SourceSets 中 </li>
<li>编译时有时候需要手动操作一下 gradle 的 build 才能生成源码（这一点大家注意下就行了，我在视频中并没有提到）</li>
</ol>
<p>不过总体来讲，kapt 的现状还是不错的，相信不久的将来这些问题都将不是问题。</p>
<hr>
<h4 id="14-Kotlin-与-Java-共存-1"><a href="#14-Kotlin-与-Java-共存-1" class="headerlink" title="14 Kotlin 与 Java 共存 (1)"></a><a href="https://v.qq.com/x/page/c03579nzo8x.html" target="_blank" rel="external">14 Kotlin 与 Java 共存 (1)</a></h4><p>　　你想要追求代码简洁、美观、精致，你应该倾向于使用 Kotlin，而如果你想要追求代码的功能强大，甚至有些黑科技的感觉，那 Java 还是当仁不让的。</p>
<p>　　说了这么多，还是那句话，让他们共存，各取所长。</p>
<p>　　那么问题来了，怎么共存呢？虽然一说理论我们都知道，跑在 Jvm 上面的语言最终都是要编成 class 文件的，在这个层面大家都是 Java 虚拟机的字节码，可他们在编译之前毕竟还是有不少差异的，这可如何是好？</p>
<p>　　正所谓兵来将挡水来土掩，有多少差异，就要有多少对策，这一期我们先讲<strong>在 Java 中调用 Kotlin</strong>。</p>
<h4 id="15-Kotlin-与-Java-共存-2"><a href="#15-Kotlin-与-Java-共存-2" class="headerlink" title="15 Kotlin 与 Java 共存 (2)"></a><a href="https://v.qq.com/x/page/z0357ls85fe.html" target="_blank" rel="external">15 Kotlin 与 Java 共存 (2)</a></h4><p>　　上一期我们简单讨论了几个 Java 调用 Kotlin 的场景，这一期我们主要讨论相反的情况：如何在 Kotlin 当中调用 Java 代码。</p>
<p>　　除了视频中提到的点之外还有一些细节，比如异常的捕获，集合类型的映射等等，大家自行参考官方文档即可。在了解了这些之后，你就可以放心大胆的在你的项目中慢慢渗透 Kotlin，让你的代码逐渐走向简洁与精致了。</p>
<h1 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h1><p>录制这样一套视频确实是需要花费时间和心血的，如果您觉得它对您有帮助，可以通过微信和支付宝打赏，我将努力将视频做到最好！谢谢！</p>
<p><img src="/arts/contributes.jpg" width="450px"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin从入门到『放弃』系列-视频教程&quot;&gt;&lt;a href=&quot;#Kotlin从入门到『放弃』系列-视频教程&quot; class=&quot;headerlink&quot; title=&quot;Kotlin从入门到『放弃』系列 视频教程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github
    
    </summary>
    
      <category term="视频教程" scheme="http://www.Kotliner.cn/categories/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="视频教程" scheme="http://www.Kotliner.cn/tags/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 兼容 Java 遇到的最大的坑</title>
    <link href="http://www.Kotliner.cn/2017/04/03/Kotlin%20%E5%85%BC%E5%AE%B9%20Java%20%E9%81%87%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9A%84%E5%9D%91%20/"/>
    <id>http://www.Kotliner.cn/2017/04/03/Kotlin 兼容 Java 遇到的最大的坑 /</id>
    <published>2017-04-03T07:05:15.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<p>前言：上周我发了一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483908&amp;idx=1&amp;sn=0c072a630198d4a23a7d3aec700c138b&amp;chksm=e8a05d39dfd7d42f1494c5f0fcc0562112be6d8912e44fc51f17dee472f9ebdfaad7d930e3b1#rd" target="_blank" rel="external">Kotlin 遇到 MyBatis：到底是 Int 的错，还是 data class 的错？</a>讲如何解决群里面一兄弟遇到的 data class 与 MyBatis 相克的问题，其中提到了几种外门邪道的方法，也提到了官方的解决思路，有些朋友看了之后还是不太明白，甚至紧接着就有小伙伴在使用 Realm 的时候遇到了类似的问题，看来，我还是得再写一篇来进一步告诉大家，这究竟是个什么问题，以及该如何面对它。</p>
<p>本文源码在 <a href="https://github.com/enbandari/Kotlin-Tutorials" target="_blank" rel="external">Github：Kotlin-Tutorials</a> 这个项目当中，微信公众号无法添加外链，请大家点击“阅读原文”获取。</p>
<h2 id="一个-Realm-的小例子"><a href="#一个-Realm-的小例子" class="headerlink" title="一个 Realm 的小例子"></a>一个 Realm 的小例子</h2><p>Realm 在 2016 年与 RxJava、Retrofit 这样的框架一起，在 Android 开发领域内着实小小的火了一把，如果大家对它不了解，没关系，传送门 biu ~ <a href="https://realm.io/" target="_blank" rel="external">Realm</a></p>
<p>我们先按照官网的说明配置好 gradle 依赖，话说呀，这互联网发展这么快，新时代的框架一出来，逼格果断就体现在完善的构建和开发生态，你发布的东西还只是一个 jar 包，人家呢，早上了 maven 不说，还要搞几个 gradle 任务来方便你开发：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">buildscript &#123; </div><div class="line">    ext.kotlin_version = <span class="string">'1.1.1'</span> </div><div class="line">    repositories &#123; </div><div class="line">        jcenter() </div><div class="line">    &#125; </div><div class="line">    dependencies &#123; </div><div class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.3.0'</span> </div><div class="line">        <span class="comment">//这里将 realm 的 gradle 插件加入 gradle 构建的运行时 </span></div><div class="line">        classpath <span class="string">"io.realm:realm-gradle-plugin:3.0.0"</span> </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line">...</div></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span> </div><div class="line">apply <span class="string">plugin:</span> <span class="string">'realm-android'</span> <span class="comment">//应用插件，Realm 会在这里添加自己的一些构建任务 </span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>其实 gradle 插件开发也是一个很有意思的话题，如果大家有需要，我后面也可以写几篇文章介绍下（悄悄告诉你们，其实我早就想写了，这不是 kotlin 版的 gradle 还没有正式发布么！）。</p>
<p>有了这个我们就可以开始写个 Realm 的 demo 了。</p>
<p>小明：等等！我还有一事不明，你怎么不添加 realm 的依赖就要开始写 demo 了啊！</p>
<p>艾玛，要么说小明人家就是明白人呢，我前面写了一大堆，只不过是添加了 gradle 构建的依赖而已，而我们的程序想要使用 realm，必须依赖 realm 的运行时库才行。那这么说我是不是漏掉了什么？当然没有，怎么会呢，我这么聪（dou）明（bi）的人，我可是一步一步照着官网的步骤抄的！</p>
<p>其实呀，realm 的运行时依赖早在我们 apply plugin 的时候就已经添加进来的， realm-android 这个插件除了添加了一些它需要的 gradle 任务之外，也顺手帮我们把依赖添加了。嗯，就是酱紫，如果有那个同学学（xian）有（de）余（dan）力（teng），可以翻一翻 realm 插件的源码。</p>
<p>来来来，赶紧看 demo，不然有些人该内急了~</p>
<p>首先在 Application 当中初始化它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> : <span class="type">Application</span></span>() &#123; </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123; </div><div class="line">        <span class="keyword">super</span>.onCreate() </div><div class="line">        Realm.init(<span class="keyword">this</span>) </div><div class="line">        Realm.setDefaultConfiguration( </div><div class="line">                RealmConfiguration.Builder() </div><div class="line">                .deleteRealmIfMigrationNeeded() </div><div class="line">                .schemaVersion(<span class="number">1</span>) </div><div class="line">                .build()) </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义一个 User 类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="meta">@PrimaryKey</span> <span class="keyword">var</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String) : RealmObject()</div></pre></td></tr></table></figure>
<p>接着我们开始存数据和查数据啦：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">add.setOnClickListener &#123; </div><div class="line">    Realm.getDefaultInstance().use &#123; </div><div class="line">        it.beginTransaction() </div><div class="line">        <span class="keyword">val</span> d = it.createObject(User::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">it.where</span></span>(User::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>).<span class="title">count</span></span>()) </div><div class="line">        d.name = <span class="string">"User <span class="subst">$&#123;d.id&#125;</span>"</span> </div><div class="line">        it.commitTransaction() </div><div class="line">    &#125; </div><div class="line">　 </div><div class="line">&#125; </div><div class="line">　 </div><div class="line">query.setOnClickListener &#123; </div><div class="line">    Realm.getDefaultInstance().use &#123; </div><div class="line">        it.where(User::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>).<span class="title">findAll</span></span>().map &#123; </div><div class="line">            Log.d(TAG, it.toString()) </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想得挺美，结果呢？编译不通过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:A default public constructor with no argument must be declared in User if a custom constructor is declared.</div></pre></td></tr></table></figure>
<h2 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h2><p>这就让我想到上周的文章，那篇文章里面我们其实就发现症结根本不是什么 Int 和 Integer，而是无参构造方法。JavaBean 是 Java 的一个概念，我其实甚至有些觉得 Java 的设计者们通过 JavaBean 这样的概念来弥补语言本身的缺陷——不管怎样，JavaBean 是不能没有无参构造的，。</p>
<p>Kotlin 呢，语言层面就有类似于 JavaBean 的东西，那就是 data class，这俩孩子实在太像了，以至于大家经常把 data class 当做 JavaBean 来使。嗯，你信不信 Kotlin 的设计者也是这么想的呢？当然，用 data class 这样一个名正言顺的“亲儿子”数据类来替代 JavaBean 这么个语言层面没有任何支持和认可的“野孩子”，应该算是 JavaBean 莫大的荣幸了，可问题又出在 Java 语言本身构造方法滥用的潜在问题上了。在 Java 中，构造方法真心是一个很没有存在感的东西，大家总是根据自己的喜好来随意的定义很多个构造方法的版本，而最终忽视掉它们的内在联系，导致没有正常走完初始化逻辑的实例满天飞，这家伙如果是导弹，我估计也不需要解放军就可以直接把台湾给统一了。</p>
<p>说了这么多，我主要是想吐槽两个点：第一个就是 Java 本身语言设计层面几乎没有任何照顾到数据类的体现（可千万别说 clone 和 Serialize），第二个就是 Java 对其对象的实例化过程的把控太过于儿戏。</p>
<p>这两点呢，Kotlin 都做的很好，我现在写 Kotlin 经常被迫认真思考一个类该如何正确初始化，这显然对于我们的程序结构和逻辑梳理有莫大的好处。可是结果呢？Java 时代的那些框架们受不了了。Kotlin 背靠着 Java 这座大山，Java 就像它的父母一样，父母的观念再老再陈旧，Kotlin 也得做好自己该做的，一方面是向现在看来陈旧但在过去已经非常革命的观念致敬，另一方面嘛，如果 Java 不支持个几十万首付，Kotlin 能买得起房吗？</p>
<p>哇塞，我好能扯啊。</p>
<p>其实想要解决 default public constructor 这样的问题，Kotlin 官方已经想到了，那就是 noarg。嗯，我原以为我提一句 noarg 大家就会知道是什么了，看来是我想的简单了，毕竟这个东西在 1.0.6 才出来，当时我还在介绍这个版本的时候提到了它的使用方法，朋友们可能还没有接触过，没关系，下面我再贴一些写法，大家一看就明白：</p>
<p>首先你要做的就是定义一个注解：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">PoKo</span></span></div></pre></td></tr></table></figure>
<p>接着 gradle 配置一下脚本的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">buildscript &#123; </div><div class="line">... </div><div class="line">    dependencies &#123; </div><div class="line">		... </div><div class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version"</span> </div><div class="line">		... </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加了运行时环境，那么我们就可以使用 noarg 插件了：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin-noarg"</span> </div><div class="line">　 </div><div class="line">noArg &#123; </div><div class="line">    annotation(<span class="string">"net.println.kotlin.realm.PoKo"</span>) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置完之后，PoKo 这个注解就有了超能力，所有被它标注的类在编译时都会生成一个无参的构造方法，于是我们给 User 加一个 PoKo 的注解：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PoKo</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(...) : RealmObject()</div></pre></td></tr></table></figure>
<p>搞定，果断去编译一下！！</p>
<h2 id="final-还是不-final，这是个问题"><a href="#final-还是不-final，这是个问题" class="headerlink" title="final 还是不 final，这是个问题"></a>final 还是不 final，这是个问题</h2><p>本来兴高采烈的以为不就是个无参构造的问题嘛，结果编译的时候又爆出了新的问题：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:(<span class="number">31</span>, <span class="number">61</span>) error: cannot inherit from <span class="keyword">final</span> User</div></pre></td></tr></table></figure>
<p>好家伙，这究竟发生了什么。。原来 Realm 在编译的时候生成了一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealmProxy</span> <span class="keyword">extends</span> <span class="title">net</span>.<span class="title">println</span>.<span class="title">kotlin</span>.<span class="title">realm</span>.<span class="title">User</span> </span></div><div class="line">    <span class="keyword">implements</span> <span class="title">RealmObjectProxy</span>, <span class="title">UserRealmProxyInterface</span></div></pre></td></tr></table></figure>
<p>这个类要继承我这个 User 类，结果就报错了。</p>
<p>下面是理（che）论（dan）时间。我们说在 C++ 当中给合适的变量、函数参数、函数返回值甚至函数加上 const 是个好习惯，大家没有意见吧？同样的，Java 当中给那些不变的量、不能被继承的类、不能被覆写的方法加上 final 也是个好习惯，大家也没有意见吧？那么问题来了，大家有几个人这么干了？是不是不到万不得已，才懒得写那个 final 呢，五个字母呢，你是想累死宝宝啊？我就知道 Effective Java 这本书看了也白看，因为大家经常明知道什么是好习惯却还是要对着干，这个不是因为大家不喜欢好习惯，而是因为坚持好习惯需要成本！不瞒各位说，我中午为了坚持午休的好习惯，牺牲了跟组里面的小伙伴一起开黑上分的机会，还得装着拥护“人民ri报”关于“小学生打排位太坑”的评论，我容易么我。。</p>
<p>嗯，扯远了。还是说 final 的事儿，Kotlin 就做的很好，它默认所有的类、变量、方法都是 final 的，想要继承？来，过来申请我给你审批。。。你看，这样从根儿解决问题，我们再也不用为了坚持好习惯而发愁了，因为我们根本不需要坚持，难道你想要坚持坏习惯嘛？</p>
<p>可是 Java 及其框架们呢？原来到北京买房有钱就行，现在呢，商住都不让买了啊（什么？你说广州都不让卖了？）。那叫一个不适应，这可不是得闹事儿么。</p>
<p>Kotlin 官方考虑到 Java 帮它出首付买房的事儿，想了想算了，还是出个什么插件，解决下这个问题吧，于是 allopen 闪亮登场！allopen 的原理跟 noarg 极其类似，它是在编译器对指定的类进行去“final”化，你别看你写代码的时候 User 还是个 final 的类，不过编译成字节码之后这天呀可就变了。</p>
<p>关于 allopen 的使用，跟 noarg 简直不要太像，先定义一个注解：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">PoKo</span> // <span class="title">How</span> <span class="title">old</span> <span class="title">r</span> <span class="title">U</span>!</span></div></pre></td></tr></table></figure>
<p>可以跟 noarg 公用同一个注解，也可以自己另外单独定义一个，这个不要紧。</p>
<p>接着 gradle 配置搞起：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">buildscript &#123; </div><div class="line">	... </div><div class="line">    dependencies &#123; </div><div class="line">		... </div><div class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version"</span> </div><div class="line">		... </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着就是应用插件，配置注解一气呵成：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin-allopen"</span> </div><div class="line">　 </div><div class="line">allOpen &#123; </div><div class="line">    annotation(<span class="string">"net.println.kotlin.realm.PoKo"</span>) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行~</p>
<p>ps：如果加了 allopen 和 noarg 之后编译仍然提示原来的错误，记得狠狠地 clean 一下才行哈。</p>
<p>## </p>
<h2 id="认真脸：究竟什么是-“坑”"><a href="#认真脸：究竟什么是-“坑”" class="headerlink" title="认真脸：究竟什么是 “坑”"></a>认真脸：究竟什么是 “坑”</h2><p>前面说了 Kotlin 的两个 “坑”，都是关于 data class 的。有人认为这么说 Kotlin 不公平，毕竟人家 Kotlin 也是可以写出下面的代码的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123; </div><div class="line">	<span class="keyword">var</span> id: String? = <span class="literal">null</span> </div><div class="line">	<span class="keyword">var</span> name: String? = <span class="literal">null</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管你在为 Kotlin 打抱不平，不过如果你真要写这样的代码，我建议你还是用 Java 吧。你不属于 Kotlin。。。</p>
<p>Kotlin 这么美的语言，怎么能写这么丑陋的东西呢？这就好比有人说为什么空类型强转为非空类型一定要两个感叹号呢，用一个不就够了么，两个看起来好丑呀！</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user: User? = getUser() </div><div class="line">user!!.name = <span class="string">"小明"</span> <span class="comment">//小明，他们说你丑！</span></div></pre></td></tr></table></figure>
<p>有人回答说：明明这就是丑陋的东西，为什么要美化？掩盖事物的本质只能让事情变得更糟糕！</p>
<p>我们用 Kotlin 企图兼容 Java 的做法，本来就是权宜之计，兼容必然带来新旧两种观念的冲突以及丑陋的发生，这么说来，我倒是更愿意期待 Kotlin Native 的出现了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/arts/kotlin扫码关注.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：上周我发了一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;amp;mid=2247483908&amp;amp;idx=1&amp;amp;sn=0c072a630198d4a23a7d3aec700c13
    
    </summary>
    
      <category term="编程语言" scheme="http://www.Kotliner.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="AllOpen" scheme="http://www.Kotliner.cn/tags/AllOpen/"/>
    
      <category term="NoArg" scheme="http://www.Kotliner.cn/tags/NoArg/"/>
    
      <category term="Java" scheme="http://www.Kotliner.cn/tags/Java/"/>
    
      <category term="JavaBean" scheme="http://www.Kotliner.cn/tags/JavaBean/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 遇到 MyBatis：到底是 Int 的错，还是 data class 的错？</title>
    <link href="http://www.Kotliner.cn/2017/03/27/Kotlin%20%E9%81%87%E5%88%B0%20MyBatis%EF%BC%9A%E5%88%B0%E5%BA%95%E6%98%AF%20Int%20%E7%9A%84%E9%94%99%EF%BC%8C%E8%BF%98%E6%98%AF%20data%20class%20%E7%9A%84%E9%94%99/"/>
    <id>http://www.Kotliner.cn/2017/03/27/Kotlin 遇到 MyBatis：到底是 Int 的错，还是 data class 的错/</id>
    <published>2017-03-27T01:26:47.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h2><p>前不久刚刚应小伙伴的要求拉了个 QQ 群：162452394 (微信群可以加我微信 enbandari，邀大家进群)，上周一的时候在公众号推送了之后一下子就热闹起来了。</p>
<p><img src="/arts/e_group.png" width="250px"></p>
<p>话说有个哥们在群里面问了这么一个问题，他用 MyBatis 来接入数据库，有个实体类用 Kotlin 大概是这么写的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(<span class="keyword">var</span> id: <span class="built_in">Int</span>, <span class="keyword">var</span> username: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> passwd: String)</div></pre></td></tr></table></figure>
<p>它对应的数据库表是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> userinfo</div><div class="line">(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) PRIMARY <span class="keyword">KEY</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">    username <span class="built_in">VARCHAR</span>(<span class="number">45</span>),</div><div class="line">    age <span class="built_in">INT</span>(<span class="number">11</span>),</div><div class="line">    passwd <span class="built_in">VARCHAR</span>(<span class="number">45</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>字段顺序也都能对得上。</p>
<p>然后呢，他就配置了这么一条查询语句：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"net.println.kotlin.mybatis.UserMapper"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultType</span>=<span class="string">"net.println.kotlin.mybatis.User"</span>&gt;</span></div><div class="line">        select * from userinfo where id = #&#123;id&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对应的 UserMapper 代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</div><div class="line">    User selectUser(int id);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一切看上去似乎一点儿毛病都没有哇，可一旦他调用 selectUser 方法之后，程序开始抱怨了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">No constructor found in net.println.kotlin.mybatis.User matching [java.lang.Integer, java.lang.String, java.lang.Integer, java.lang.String]</div></pre></td></tr></table></figure>
<p>啥问题呢？找不到构造方法。当时看到这个问题的时候正好手里有活，没有仔细看，周末特意照着写了个 demo，果然。。嗯。。居然找不到构造方法，这就有意思了。</p>
<h2 id="问题探究-①-——-Kotlin-的类型映射"><a href="#问题探究-①-——-Kotlin-的类型映射" class="headerlink" title="问题探究 ① —— Kotlin 的类型映射"></a>问题探究 ① —— Kotlin 的类型映射</h2><p>按理说，我们的 data class 是有构造方法的，说找不到构造方法倒也有些不公平，应该确切的说是找不到合适的构造方法。前面那句错误信息告诉我们 MyBatis 想要找的构造方法是下面的签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init(java.lang.Integer, java.lang.String, java.lang.Integer, java.lang.String)</div></pre></td></tr></table></figure>
<p>我们的 data class 的构造方法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init(kotlin.Int, kotlin.String, kotlin.Int, kotlin.String)</div></pre></td></tr></table></figure>
<p>嗯，乍一看确实不一样哈，难怪找不到合适的构造方法。这样说对吗？我在之前有篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483762&amp;idx=1&amp;sn=c553cdd4b0bccd59e530a9f231037d73&amp;chksm=e8a05e4fdfd7d759a01eef26adae2ddf35f05f253e056490cc62972eda790f9601f23b2a8a23#rd" target="_blank" rel="external">为什么不直接使用 Array<int> 而是 IntArray ？</int></a>提到 过 Kotlin 的类型映射的问题，kotlin.String 编译之后毫无疑问的要映射成 java.lang.String，而 kotlin.Int 则有可能映射成 int 或是 java.lang.Integer，这么说来我们的 User 的构造方法签名可能是下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init(<span class="keyword">int</span>, java.lang.String, <span class="keyword">int</span>, java.lang.String)</div></pre></td></tr></table></figure>
<p>也可能是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init(java.lang.Integer, java.lang.String, java.lang.Integer, java.lang.String)</div></pre></td></tr></table></figure>
<p>现在通过刚才报的错误来看，映射后的签名毫无疑问的应该是前面那种了，毕竟这里 Int 并没有装箱的需求，为了追求效率，映射成 int 是再合适不过的了。也正是这个原因，MyBatis 才无法找到它想要的构造方法，无法构造出 User 对象，最终导致程序运行失败。</p>
<h2 id="问题探究-②-——-JavaBean-的无参构造"><a href="#问题探究-②-——-JavaBean-的无参构造" class="headerlink" title="问题探究 ② —— JavaBean 的无参构造"></a>问题探究 ② —— JavaBean 的无参构造</h2><p>JavaBean 是一个很有意思的概念，刚刚接触这个概念的时候都有点儿不敢相信自己的耳朵，一个在 JavaEE 当中举足轻重的概念居然就只是一个有无参构造方法、属性通过 Getter 和 Setter 访问、可序列化和反序列化的 POJO，就这么简单？说实在的，当时真觉得 JavaBean 也没什么了不起的，就像最开始学牛二定律的时候一样，一个只有 4 个字符的定律，料它也不能把洒家怎样——可是实际上呢，它确实把我给怎样了。。</p>
<p>刚刚我们分析错误的时候，很直接的分析了构造方法为什么不匹配的原因，却没有想想为什么要找这个构造方法，试想，如果你用 Java 写这段代码，你肯定会写出类似下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">	<span class="keyword">private</span> String username;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="keyword">private</span> String passwd;</div><div class="line">	</div><div class="line">	... 省略 getter 和 setter </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不纠结序列化的事儿，这个 User 就是个 JavaBean 是吧，你交给 MyBatis 使用的话也不会出现任何问题—— MyBatis 压根儿不需要找什么构造方法，因为人家根本不需要费那劲，有无参的默认构造方法的话，构造对象实例岂不是轻而易举？</p>
<p>对咯，MyBatis 其实想要的是一个 JavaBean，一个有默认无参构造方法的类，结果呢，你给人家塞了一个 data class 过去。。</p>
<h2 id="解决方案-①-——-我就用-Integer-了怎么着吧"><a href="#解决方案-①-——-我就用-Integer-了怎么着吧" class="headerlink" title="解决方案 ① —— 我就用 Integer 了怎么着吧"></a>解决方案 ① —— 我就用 Integer 了怎么着吧</h2><p>这个问题有一个最为直接的解决办法，那就是直接使用 Integer 而不是 kotlin.Int。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(<span class="keyword">var</span> id: Integer, <span class="keyword">var</span> username: String, <span class="keyword">var</span> age: Integer, <span class="keyword">var</span> passwd: String)</div></pre></td></tr></table></figure>
<p>不过，你一旦这么写了，你就没办法在 Kotlin 当中正常实例化这个类了（在 Java 中可以实例化），所以这种方案堪比七伤拳啊：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> user = User(<span class="number">1</span>,<span class="string">"root"</span>, <span class="number">30</span>,<span class="string">""</span>) <span class="comment">//error : The integer literal does not conform to the expected type Integer</span></div></pre></td></tr></table></figure>
<h2 id="解决方案-②-——-kotlin-Int-什么时候映射为-Integer"><a href="#解决方案-②-——-kotlin-Int-什么时候映射为-Integer" class="headerlink" title="解决方案 ② —— kotlin.Int 什么时候映射为 Integer"></a>解决方案 ② —— kotlin.Int 什么时候映射为 Integer</h2><p>如果 kotlin.Int 能够映射成 java.lang.Integer，那么这问题就彻底解了。试想一下，什么情况下 int 不好使，非得用 Integer？</p>
<ul>
<li>整型作为泛型参数的时候</li>
<li>可以为 null</li>
</ul>
<p>这两种情况显而易见的需要 Integer 出马了，比如你想将一堆整数放入 ArrayList 当中，你只能这么搞：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">...</div></pre></td></tr></table></figure>
<p>还有一种就是整型值可能为 null 的时候，毕竟作为基本类型的 int 连默认值都是 0，怎么会为 null 呢？</p>
<p>回到我们的问题，如果能让 data class 的 Int 映射为 Integer，那么构造方法应该是妥妥的了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(<span class="keyword">var</span> id: <span class="built_in">Int</span>?, <span class="keyword">var</span> username: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>?, <span class="keyword">var</span> passwd: String)</div></pre></td></tr></table></figure>
<p>我们把构造方法当中的 id 和 age 的类型做了修改，从不可为空的 Int 改为可为空的 Int？，这样编译之后就只好映射为 Integer了。</p>
<p>问题解决~</p>
<p>这个方案的优点就是几乎没有额外的依赖或者其他什么开销，只是后续编码时，你会总是被迫对 id、age 这几个属性进行是否为空的判断，这样看起来一点儿都不美。</p>
<h2 id="解决方案-③-——-默认参数"><a href="#解决方案-③-——-默认参数" class="headerlink" title="解决方案 ③ —— 默认参数"></a>解决方案 ③ —— 默认参数</h2><p>其实就像我们前面提到的，如果 User 这个类有个无参构造的话，后面查找其他构造方法的事儿就压根儿不会有。也就是说如果我们给 User 类加一个无参构造，这个问题也是可以解决的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> username: String</div><div class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> passwd: String</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这样写的话，我们就无法享受 data class 带来的书写便利了。。不过如果我们能够骗过 MyBatis 说我们这个类有无参构造，那么问题不就解决了？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(<span class="keyword">var</span> id: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">var</span> username: String = <span class="string">""</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">var</span> passwd: String = <span class="string">""</span>)</div></pre></td></tr></table></figure>
<p>我们为每一个参数加了默认值， 这样编译出来之后，字节码当中就真的会看到有无参构造方法了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;init&gt;()V</div><div class="line"> L0</div><div class="line">  ALOAD <span class="number">0</span> </div><div class="line">  ICONST_0</div><div class="line">  ACONST_NULL</div><div class="line">  ICONST_0</div><div class="line">  ACONST_NULL</div><div class="line">  BIPUSH <span class="number">15</span></div><div class="line">  ACONST_NULL</div><div class="line">  INVOKESPECIAL net/println/kotlin/mybatis/User.&lt;init&gt; (ILjava/lang/String;ILjava/lang/String;ILkotlin/jvm/<span class="keyword">internal</span>/DefaultConstructorMarker;)V</div><div class="line">  RETURN</div><div class="line"> L1</div><div class="line">  MAXSTACK = <span class="number">7</span></div><div class="line">  MAXLOCALS = <span class="number">1</span></div></pre></td></tr></table></figure>
<p>实际上我们也可以通过反射来获得到这个无参的构造方法，也正是因为如此，我们也可以直接用 newInstance 方法来构造 User 实例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">User::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">newInstance</span></span>()</div></pre></td></tr></table></figure>
<p>既然有了无参构造方法，MyBatis 就不需要绞尽脑汁还要找其他的构造方法，于是问题解决~</p>
<p>这个方案的优点是，比较简单，也没有上一个方案那样的副作用；缺点就是，万一某一个属性没有默认值，你该给它设置什么呢？</p>
<h2 id="解决方案-④-——-官方也认为有时候我们需要一个无参构造"><a href="#解决方案-④-——-官方也认为有时候我们需要一个无参构造" class="headerlink" title="解决方案 ④ —— 官方也认为有时候我们需要一个无参构造"></a>解决方案 ④ —— 官方也认为有时候我们需要一个无参构造</h2><p>早在 1.0.6 发版的时候，官方就增加了对无参构造的一种另类支持，即 noarg 插件。Kotlin 原本不需要这么做，但考虑到它与 Java 解不开理还乱的关系，Java 支持的一切代码的写法 Kotlin 也似乎有责任和义务来完全支持了。</p>
<p>这个方法其实是 Kotlin 编译插件在编译器通过字节码织入的方式向 class 文件中写入了一个无参构造方法，这个构造方法由于出现的时间比较晚，我们无法在代码中引用到它，不过却可以通过反射访问到它，这样就即保证了 Kotlin 的初心不变，如果你愿意用 data class 或者类似的实体类，那么你就要按照 Kotlin 的要求妥善处理好它的成员的初始化，也方便了一些框架的“出格”行为，显然一个聪明的框架需要对代码本身有足够的理解，对编码人员的限制对于框架本身来说就显得没有那么的重要了。</p>
<p>如果你遇到了这样的问题，我当然建议你采用官方的这个解决方案，原因很简单，除了要写一个注解之外，几乎没有任何副作用，另外，官方支持的方案自然也比较有保障啦。</p>
<h2 id="拓展延伸-——-不择手段创建实例"><a href="#拓展延伸-——-不择手段创建实例" class="headerlink" title="拓展延伸 —— 不择手段创建实例"></a>拓展延伸 —— 不择手段创建实例</h2><p>说起来我就要批评一下 MyBatis 了，一点儿都不如 Gson 流氓。我们前面虽然没有细说，不过大家基本上可以知道 MyBatis 是如何创建返回结果的实例的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> Object <span class="title">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix)</span></span></div><div class="line">     <span class="keyword">throws</span> SQLException &#123;</div><div class="line">...</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultType.isInterface() || metaType.hasDefaultConstructor()) &#123;</div><div class="line">     <span class="comment">//有无参构造方法的话走的是这个分支</span></div><div class="line">     <span class="keyword">return</span> objectFactory.create(resultType);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, <span class="keyword">false</span>)) &#123;</div><div class="line">     <span class="comment">//在这里查找与表结构匹配的构造方法，我们之前遇到的错误就在这个方法当中抛出</span></div><div class="line">     <span class="keyword">return</span> createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs, columnPrefix);</div><div class="line">   &#125;</div><div class="line">   ...</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>我们看到如果没有找到匹配的构造方法，也没有无参的构造方法，MyBatis 就叹了一口气，放弃了。这样的事情如果交给 Gson，你就会发现完全不一样。我曾在<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483683&amp;idx=1&amp;sn=41ca82c89ddccaf61a9c734e5976a62b&amp;chksm=e8a05e1edfd7d7086b84db34640043054b2288cc5e45bdc300cfab2ce16ffb84c66438a16dca#rd" target="_blank" rel="external">12 Json数据引发的血案</a>这一期当中介绍过 Gson 如何创建实例，它甚至可以让 Kotlin 的不可空类型“赋值”为 null，原因很简单，它在实例化对象的时候也跟 MyBatis 一样，先去找无参构造，找不到就用 Unsafe.allocateInstance 来创建对象，主要这个创建方法非常的底层，你可以简单的理解为只为实例化出来的 Java 对象开辟了对象存续需要的空间，而对应地它的成员没有一个会正常初始化。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">    init &#123;</div><div class="line">        println(<span class="string">"init"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</div><div class="line">        init &#123;</div><div class="line">            println(<span class="string">"cinit"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到这段代码，cinit 将在 Test 类加载时打印，init 将在 Test 实例化时打印。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> field = Unsafe::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">getDeclaredField</span></span>(<span class="string">"theUnsafe"</span>)</div><div class="line">field.isAccessible = <span class="literal">true</span></div><div class="line"><span class="keyword">val</span> unsafe = field.<span class="keyword">get</span>(<span class="literal">null</span>) <span class="keyword">as</span> Unsafe</div><div class="line">unsafe.allocateInstance(Test::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></div></pre></td></tr></table></figure>
<p>我们运行这样的程序，结果只有 cinit，难怪人家叫 Unsafe，都告诉你 Unsafe 了你还想要什么。。</p>
<p>不过这在 C++ 当中，简直不叫事儿，不信给你看一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkNum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">0</span>)</span></span>;</div><div class="line">&#125;;</div><div class="line">...</div><div class="line"><span class="keyword">int</span> Hello::getNum() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">12310</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ((Hello*)<span class="number">0</span>)-&gt;getNum() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们把一个 0 强转为 Hello 类型的指针，接着还调用人家的函数 getNum，结果你猜怎么着？运行结果还是对的！</p>
<p>如果你经常接触 Jni，你也经常会把 native 的指针传给 Java，Java 拿到的其实就是一个 long 类型的数，等 Java 需要调用 native 代码的时候，你就会发现这个整数传给 native 层会首先被 reinterpret_cast。</p>
<p>这有什么稀罕的，反正你创建的类也好，对象也好，最终都是数，严格的语法限制也不过是编译器给我们盖起的围墙，你通过围墙来保护你自己，同时也让围墙遮挡了你的眼睛。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/assets/2017.3.27/kotlin扫码关注.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/arts/kotlin扫码关注.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题出现&quot;&gt;&lt;a href=&quot;#问题出现&quot; class=&quot;headerlink&quot; title=&quot;问题出现&quot;&gt;&lt;/a&gt;问题出现&lt;/h2&gt;&lt;p&gt;前不久刚刚应小伙伴的要求拉了个 QQ 群：162452394 (微信群可以加我微信 enbandari，邀大家进群)，上周一
    
    </summary>
    
      <category term="编程语言" scheme="http://www.Kotliner.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="NoArg" scheme="http://www.Kotliner.cn/tags/NoArg/"/>
    
      <category term="JavaBean" scheme="http://www.Kotliner.cn/tags/JavaBean/"/>
    
  </entry>
  
  <entry>
    <title>[译]Kotlin 1.1 Event in Your City</title>
    <link href="http://www.Kotliner.cn/2017/03/21/Kotlin%201.1%20Event%20in%20Your%20City/"/>
    <id>http://www.Kotliner.cn/2017/03/21/Kotlin 1.1 Event in Your City/</id>
    <published>2017-03-21T13:51:00.000Z</published>
    <updated>2017-05-22T02:30:56.906Z</updated>
    
    <content type="html"><![CDATA[<p>我们将于2017年3月23日进行<a href="https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1-event-2/#more-4726" target="_blank" rel="external">Kotlin 1.1活动</a> 线上直播。您可以通过<a href="http://jb.gg/kotlinevent1_1" target="_blank" rel="external">JetBrains TV</a>观看<strong>Andrey Breslav的演讲</strong>，了解Kotlin 1.1的关键特性，包括协程(coroutines)，JavaScript后端等。您也可以使用#kotlinqa在twitter上提出问题，我们将在3月23日直播中的<strong>Q&amp;A环节</strong>进行解答。为适应不同的时区我们共准备了2个直播流，详情可在<a href="https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1-event-2/#more-4726" target="_blank" rel="external">博客日志</a>中参阅<strong>详细计划与指导</strong> 。从下图中了解您所在的城市是否有<strong>Kotlin 1.1活动</strong>，如果您所在的城市尚未出现在下图中，请单独加入直播。</p>
<p><a href="http://kotlinlang.org/community/talks.html?time=kotlin" target="_blank" rel="external"><img alt="Kotlin_1_1event_map" class="size-full wp-image-4794 aligncenter" data-recalc-dims="1" src="https://i1.wp.com/blog.jetbrains.com/kotlin/files/2017/03/Kotlin_1_1event_map.png?resize=640%2C451&amp;ssl=1"></a></p>


<p>请注意，美国的直播时间已经更改为PDT(太平洋夏季时间)时间。第一个直播流将于上午9点开始，第二个上午11点开始。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们将于2017年3月23日进行&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1-event-2/#more-4726&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kotlin 1
    
    </summary>
    
      <category term="官方动态" scheme="http://www.Kotliner.cn/categories/%E5%AE%98%E6%96%B9%E5%8A%A8%E6%80%81/"/>
    
    
  </entry>
  
</feed>
