<!DOCTYPE html>
<html>
<head>
    

    

    


<!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Baidu Push -->
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- End Baidu Push -->


    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="true">
    <meta name="baidu-site-verification" content="97dbRVWfVh" />
    <meta name="sogou_site_verification" content="AIePRXkUI4"/>
    
    
    <link rel="canonical" href="http://www.kotliner.cn/2017/02/20/高阶函数（一）/">
    
    
    <title>高阶函数（一） | Kotlin | 简洁、优雅，100% 兼容 Java</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="高阶函数,尾递归">
    <meta name="description" content="1 什么是高阶函数1.1 高阶函数的基本概念高阶函数其实看着挺吓人，不过就是把函数作为参数或者返回值的一类函数而已。其实这样的函数我们都见过很多了，来看个例子： 123public inline fun &amp;lt;T&amp;gt; Array&amp;lt;out T&amp;gt;.forEach(action: (T) -&amp;gt; Unit): Unit &amp;#123;     for (element in this">
<meta name="keywords" content="高阶函数,尾递归">
<meta property="og:type" content="article">
<meta property="og:title" content="高阶函数（一）">
<meta property="og:url" content="http://www.Kotliner.cn/2017/02/20/高阶函数（一）/index.html">
<meta property="og:site_name" content="Kotlin">
<meta property="og:description" content="1 什么是高阶函数1.1 高阶函数的基本概念高阶函数其实看着挺吓人，不过就是把函数作为参数或者返回值的一类函数而已。其实这样的函数我们都见过很多了，来看个例子： 123public inline fun &amp;lt;T&amp;gt; Array&amp;lt;out T&amp;gt;.forEach(action: (T) -&amp;gt; Unit): Unit &amp;#123;     for (element in this">
<meta property="og:image" content="http://www.kotliner.cn/arts/kotlin扫码关注.png">
<meta property="og:updated_time" content="2017-05-22T02:30:56.921Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高阶函数（一）">
<meta name="twitter:description" content="1 什么是高阶函数1.1 高阶函数的基本概念高阶函数其实看着挺吓人，不过就是把函数作为参数或者返回值的一类函数而已。其实这样的函数我们都见过很多了，来看个例子： 123public inline fun &amp;lt;T&amp;gt; Array&amp;lt;out T&amp;gt;.forEach(action: (T) -&amp;gt; Unit): Unit &amp;#123;     for (element in this">
<meta name="twitter:image" content="http://www.kotliner.cn/arts/kotlin扫码关注.png">
    
        <link rel="alternative" href="/atom.xml" title="Kotlin" type="application/atom+xml">
    
    <link rel="shortcut icon" href="/assets/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.5.2">
    <script>window.lazyScripts=[]</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/assets/img/Kotlin-logo.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Kotlin</h5>
          <a href="mailto:kotlin@kotliner.cn" title="kotlin@kotliner.cn" class="mail">kotlin@kotliner.cn</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.kotlincn.net"  >
                <i class="icon icon-lg icon-certificate"></i>
                官网
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                所有文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/authors"  >
                <i class="icon icon-lg icon-user"></i>
                所有作者
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-info"></i>
                关于我们
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/beijing/"  >
                <i class="icon icon-lg icon-map-marker beijing"></i>
                北京分会
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/chengdu/"  >
                <i class="icon icon-lg icon-map-marker chengdu"></i>
                成都分会
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://shanghai.kotliner.cn"  >
                <i class="icon icon-lg icon-map-marker shanghai"></i>
                上海分会
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">高阶函数（一）</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">高阶函数（一）</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-02-20T02:32:32.000Z" itemprop="datePublished" class="page-time">
  2017-02-20
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程语言/">编程语言</a></li></ul>

            
        </h5>
    </div>

    

</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-什么是高阶函数"><span class="post-toc-text">1 什么是高阶函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-高阶函数的基本概念"><span class="post-toc-text">1.1 高阶函数的基本概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-函数引用"><span class="post-toc-text">1.2 函数引用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-常见的内置高阶函数"><span class="post-toc-text">2 常见的内置高阶函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-map"><span class="post-toc-text">2.1 map</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-flatMap"><span class="post-toc-text">2.2 flatMap</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-fold-reduce"><span class="post-toc-text">2.3 fold / reduce</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-filter-takeWhile"><span class="post-toc-text">2.4 filter / takeWhile</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5-let"><span class="post-toc-text">2.5 let</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-6-apply-with"><span class="post-toc-text">2.6 apply / with</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-尾递归优化"><span class="post-toc-text">3 尾递归优化</span></a></li></ol>
        </nav>
    </aside>
    

<article id="post-高阶函数（一）"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">高阶函数（一）</h1>
        <div class="post-meta">
            <time class="post-time" title="2017年02月20日 10:32" datetime="2017-02-20T02:32:32.000Z"  itemprop="datePublished">2017-02-20</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程语言/">编程语言</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="1-什么是高阶函数"><a href="#1-什么是高阶函数" class="headerlink" title="1 什么是高阶函数"></a>1 什么是高阶函数</h2><h3 id="1-1-高阶函数的基本概念"><a href="#1-1-高阶函数的基本概念" class="headerlink" title="1.1 高阶函数的基本概念"></a>1.1 高阶函数的基本概念</h3><p>高阶函数其实看着挺吓人，不过就是把函数作为参数或者返回值的一类函数而已。其实这样的函数我们都见过很多了，来看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>.<span class="title">forEach</span><span class="params">(action: (<span class="type">T</span>)</span></span> -&gt; <span class="built_in">Unit</span>): <span class="built_in">Unit</span> &#123; </div><div class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) action(element) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是我们的老朋友了，forEach，传入了一个 Lambda 表达式，之后在迭代数组的时候调用这个 Lambda。你可千万别把 Lambda 不当函数，人家可是正儿八经的 FunctionN 的实例，这个我们在前面一篇文章<a href="http://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483881&amp;idx=1&amp;sn=ddbdddd97208556f9ed6af4fe834353b&amp;chksm=e8a05ed4dfd7d7c21014ba59b75201a601ea72734fcb1e725424ac34024e0a34c8757bd02bb1#rd" target="_blank" rel="external">细说 Lambda 表达式</a>已经介绍过了~</p>
<p>如果使用 forEach，我们就这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array.forEach&#123; </div><div class="line">	print(<span class="string">"<span class="subst">$it</span>, "</span>) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果就类似：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</div></pre></td></tr></table></figure>
<p>forEach 其实就是一个把函数当参数传入的高阶函数了。</p>
<h3 id="1-2-函数引用"><a href="#1-2-函数引用" class="headerlink" title="1.2 函数引用"></a>1.2 函数引用</h3><p>下面我们要来思考一个问题。为什么 Kotlin 可以有高阶函数？</p>
<p>其实这个问题，我们早就有答案了，因为在 Kotlin 当中，函数是“一等公民”，函数的引用可以自由传递，赋值，并在合适的时候调用。为什么这么说呢？难道仅仅是因为我们可以任性的定义 Lambda 表达式这种匿名函数，并把它赋值为一个变量，然后可以随便传递和调用吗？</p>
<p>当然不能完全是这样了。其实 Kotlin 当中的任何方法、函数都是有其名字和引用的，我们前面其实看到过一个 forEach 的例子，我再给大家拿出来：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array.forEach(::println)</div></pre></td></tr></table></figure>
<p>这个例子当中，我们其实是想要把元素挨个打印一遍，forEach 传入的是一个 (T) -&gt; Unit，这并不是说它只能传入一个符合参数和返回值的 Lambda，而是说符合参数和返回值定义的任意函数。println 有很多版本，其中有一个符合上面的条件：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">println</span><span class="params">(message: <span class="type">Any</span>?)</span></span> &#123; </div><div class="line">    System.<span class="keyword">out</span>.println(message) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我们可以把它当参数传入。这个意义上讲，::println 跟 Function1 是什么关系呢？很明显接口实现的关系了，同时 ::println 因为可以具名引用到一个函数，所以我们也把类似的写法叫做函数引用。</p>
<p>我们再来看一个类成员的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123; </div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">world</span><span class="params">()</span></span>&#123; </div><div class="line">        println(<span class="string">"Hello world."</span>) </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line">　 </div><div class="line"><span class="keyword">val</span> helloWorld: (Hello)-&gt; <span class="built_in">Unit</span> = Hello::world</div></pre></td></tr></table></figure>
<p>我们同样可以用 <typename>::<functionname> 的方式来引用类成员方法，当然扩展方法也是可以的。这个要怎么用呢？</functionname></typename></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">isOdd</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = <span class="keyword">this</span> % <span class="number">1</span> == <span class="number">0</span> </div><div class="line">　 </div><div class="line">... </div><div class="line"><span class="keyword">val</span> ints = intArrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>) </div><div class="line">ints.filter(<span class="built_in">Int</span>::isOdd)</div></pre></td></tr></table></figure>
<p>注意到 filter 的参数类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">filter</span><span class="params">(predicate: (<span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Boolean</span>): List&lt;<span class="built_in">Int</span>&gt; &#123; </div><div class="line">    <span class="keyword">return</span> filterTo(ArrayList&lt;<span class="built_in">Int</span>&gt;(), predicate) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟我们前面 Hello::World 的例子是不是一模一样呢？</p>
<p>不过相比包级函数，这种引用在 Kotlin 1.1 以前显得有些苍白，为什么这么说呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PdfPrinter</span></span>&#123; </div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">println</span><span class="params">(any: <span class="type">Any</span>?)</span></span>&#123; </div><div class="line">        println(any) </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line">　 </div><div class="line">... </div><div class="line">　 </div><div class="line">array.forEach(PdfPrinter::println) <span class="comment">//错误！！</span></div></pre></td></tr></table></figure>
<p>请问，这种情况下，我该如何像 <figure class="highlight plain"><figcaption><span>一样将 ```PdfPrinter::println``` 传递给 forEach 呢？我们知道，所有的类成员方法，它们其实都有一个隐含的参数，即类的实例本身，所以它的类型应该是下面这样：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```kotlin</div><div class="line"> val pdfPrintln: (PdfPrinter, Any?)-&gt; Unit = PdfPrinter::println</div></pre></td></tr></table></figure></p>
<p>那么，有人就会说，我干脆构造一个 PdfPrinter 的实例，然后这么写看看：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array.forEach(PdfPrinter()::println)<span class="comment">// Since Kotlin 1.1</span></div></pre></td></tr></table></figure>
<p>看着很不错了吧？可惜，这个在 1.1 才支持哦，不过距离 1.1 正式发布应该不久了！</p>
<h2 id="2-常见的内置高阶函数"><a href="#2-常见的内置高阶函数" class="headerlink" title="2 常见的内置高阶函数"></a>2 常见的内置高阶函数</h2><p>Kotlin 为我们内置了不少好用的高阶函数，这一节我们就给大家简要介绍一下。</p>
<h3 id="2-1-map"><a href="#2-1-map" class="headerlink" title="2.1 map"></a>2.1 map</h3><p>我们经常用 forEach 来迭代一个集合，如果我们想要把一个集合映射成另外一个集合的话，通常我们会这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>) </div><div class="line">　 </div><div class="line"><span class="keyword">val</span> newlist = ArrayList&lt;<span class="built_in">Int</span>&gt;() </div><div class="line">list.forEach &#123;  </div><div class="line">	<span class="keyword">val</span> newElement = it * <span class="number">2</span> + <span class="number">3</span> </div><div class="line">    newlist.add(newElement) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上去还是挺简单的，不过终究不够简洁，而且还在 Lambda 表达式内部访问了外部变量，这其实都不是很好的编程习惯。</p>
<p>map 其实就是对类似的操作做了一点封装，类似的集合映射的操作用 map 再合适不过了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> newlist  =  list.map &#123; </div><div class="line">    it * <span class="number">2</span> + <span class="number">3</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lambda 的参数是原集合的元素，返回值是对应位置的新集合的元素，新集合是 map 的返回值。我们再来看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> stringlist = list.map(<span class="built_in">Int</span>::toString)</div></pre></td></tr></table></figure>
<p>上面这个例子，我们把一个整型的集合映射成了一个字符串类型的集合。不管你做何种变换，map 的返回值始终是一个大小与原集合相同的集合。</p>
<h3 id="2-2-flatMap"><a href="#2-2-flatMap" class="headerlink" title="2.2 flatMap"></a>2.2 flatMap</h3><p>如果我手头有一个整型集合的集合，我想把他们打平，变成一个整型集合，用我们传统的方法就是两层循环。如果我还想要做点儿变换，那么这代码写起来就更丑了。</p>
<p>如果我们要用 flatMap，那么这个故事就直截了当得多：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> list = listOf( </div><div class="line">        <span class="number">1.</span><span class="number">.20</span>, </div><div class="line">        <span class="number">2.</span><span class="number">.5</span>, </div><div class="line">        <span class="number">100.</span><span class="number">.232</span> </div><div class="line">) </div><div class="line">　 </div><div class="line"><span class="keyword">val</span> flatList = list.flatMap &#123; it &#125; </div><div class="line">println(flatList)</div></pre></td></tr></table></figure>
<p>flatMap 后面的 Lambda 参数是 list 的元素，也就 1..20、2..5 这些 range，返回的值呢是一个 Iterable，flatMap 会把这些 Lambda 返回的 Iterable 统统添加到它自己的返回值也就是 flatList 当中，这样就相当于把 list 做了一次打平。</p>
<p>结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">106</span>, <span class="number">107</span>, <span class="number">108</span>, <span class="number">109</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">112</span>, <span class="number">113</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">118</span>, <span class="number">119</span>, <span class="number">120</span>, <span class="number">121</span>, <span class="number">122</span>, <span class="number">123</span>, <span class="number">124</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">127</span>, <span class="number">128</span>, <span class="number">129</span>, <span class="number">130</span>, <span class="number">131</span>, <span class="number">132</span>, <span class="number">133</span>, <span class="number">134</span>, <span class="number">135</span>, <span class="number">136</span>, <span class="number">137</span>, <span class="number">138</span>, <span class="number">139</span>, <span class="number">140</span>, <span class="number">141</span>, <span class="number">142</span>, <span class="number">143</span>, <span class="number">144</span>, <span class="number">145</span>, <span class="number">146</span>, <span class="number">147</span>, <span class="number">148</span>, <span class="number">149</span>, <span class="number">150</span>, <span class="number">151</span>, <span class="number">152</span>, <span class="number">153</span>, <span class="number">154</span>, <span class="number">155</span>, <span class="number">156</span>, <span class="number">157</span>, <span class="number">158</span>, <span class="number">159</span>, <span class="number">160</span>, <span class="number">161</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">164</span>, <span class="number">165</span>, <span class="number">166</span>, <span class="number">167</span>, <span class="number">168</span>, <span class="number">169</span>, <span class="number">170</span>, <span class="number">171</span>, <span class="number">172</span>, <span class="number">173</span>, <span class="number">174</span>, <span class="number">175</span>, <span class="number">176</span>, <span class="number">177</span>, <span class="number">178</span>, <span class="number">179</span>, <span class="number">180</span>, <span class="number">181</span>, <span class="number">182</span>, <span class="number">183</span>, <span class="number">184</span>, <span class="number">185</span>, <span class="number">186</span>, <span class="number">187</span>, <span class="number">188</span>, <span class="number">189</span>, <span class="number">190</span>, <span class="number">191</span>, <span class="number">192</span>, <span class="number">193</span>, <span class="number">194</span>, <span class="number">195</span>, <span class="number">196</span>, <span class="number">197</span>, <span class="number">198</span>, <span class="number">199</span>, <span class="number">200</span>, <span class="number">201</span>, <span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">205</span>, <span class="number">206</span>, <span class="number">207</span>, <span class="number">208</span>, <span class="number">209</span>, <span class="number">210</span>, <span class="number">211</span>, <span class="number">212</span>, <span class="number">213</span>, <span class="number">214</span>, <span class="number">215</span>, <span class="number">216</span>, <span class="number">217</span>, <span class="number">218</span>, <span class="number">219</span>, <span class="number">220</span>, <span class="number">221</span>, <span class="number">222</span>, <span class="number">223</span>, <span class="number">224</span>, <span class="number">225</span>, <span class="number">226</span>, <span class="number">227</span>, <span class="number">228</span>, <span class="number">229</span>, <span class="number">230</span>, <span class="number">231</span>, <span class="number">232</span>]</div></pre></td></tr></table></figure>
<p>那么这么直白的打平也不见得是我们的目标，比如我们要把这些数都做一些运算再打平，那么这个也简单：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> flatList = list.flatMap &#123; iterable -&gt;  </div><div class="line">    iterable.map &#123; element -&gt; </div><div class="line">        element * <span class="number">2</span> + <span class="number">3</span> </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只需要对 iterable 做一次 map 即可。</p>
<h3 id="2-3-fold-reduce"><a href="#2-3-fold-reduce" class="headerlink" title="2.3 fold / reduce"></a>2.3 fold / reduce</h3><p>其实 fold 就是折叠的意思嘛，把一个集合的元素折叠起来的并得到一个最终的结果，这就是 fold 要做的事情。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123; </div><div class="line">    <span class="keyword">val</span> ints = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) </div><div class="line">    <span class="keyword">val</span> r = ints.fold(<span class="number">5</span>)&#123; </div><div class="line">        sum, element -&gt; </div><div class="line">        println(<span class="string">"<span class="subst">$sum</span>, <span class="subst">$element</span>"</span>) </div><div class="line">        sum + element </div><div class="line">    &#125; </div><div class="line">    println(r) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果呢？就是从 5 开始，每次返回的结果又成了 sum，一直这么折叠下去，直到最后输出 20。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">5</span>, <span class="number">1</span> </div><div class="line"><span class="number">6</span>, <span class="number">2</span> </div><div class="line"><span class="number">8</span>, <span class="number">3</span> </div><div class="line"><span class="number">11</span>, <span class="number">4</span> </div><div class="line"><span class="number">15</span>, <span class="number">5</span> </div><div class="line"><span class="number">20</span></div></pre></td></tr></table></figure>
<p>当然，对于fold来说，我们还可以得到其他类型的结果，不一定要与集合的元素类型相同：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> r1 = ints.fold(StringBuilder())&#123; </div><div class="line">    sb, element-&gt; </div><div class="line">    sb.append(element).append(<span class="string">","</span>) </div><div class="line">&#125; </div><div class="line">　 </div><div class="line">println(r1)</div></pre></td></tr></table></figure>
<p>大家看到，我们的初始值实际上是一个 StringBuilder，后续一直在做字符串追加的操作，最后得到的 r1 其实就是一个追加了所有元素的 StringBuilder，我们把它打印出来：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</div></pre></td></tr></table></figure>
<p>我们再来看下 reduce。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> r2 = ints.reduce &#123; sum, element -&gt; sum + element &#125; </div><div class="line">println(r2)</div></pre></td></tr></table></figure>
<p>输出的最终结果是 15，也即元素之和。显然，reduce 每次求值的结果都作为下一次迭代时传入的 sum，这个看上去跟 fold 极其的类似，只不过 reduce 没有额外的初始值，并且返回值类型也需要保持与集合的元素相同。</p>
<p>如果我们要求一个数的阶乘，那代码其实很容易写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">factorial</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123; </div><div class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> </div><div class="line">    <span class="keyword">return</span> (<span class="number">1.</span>.n).reduce &#123; factorial, element -&gt; factorial * element &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-4-filter-takeWhile"><a href="#2-4-filter-takeWhile" class="headerlink" title="2.4 filter / takeWhile"></a>2.4 filter / takeWhile</h3><p>如果我们有一个很大的集合，想要过滤掉其中的一些元素，那么通常的做法也是构造一个新集合来，然后遍历原集合。</p>
<p>显然，我们有更好的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> evens = (<span class="number">1.</span><span class="number">.100</span>).filter &#123;  </div><div class="line">    it % <span class="number">2</span> == <span class="number">0</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>找出 1 到 100 之间的所有偶数，我们只需要用 filter，并传入判断条件，那么符合条件的元素就会被保留到返回的集合当中。</p>
<p>类似的，takeWhile 则返回的集合是原集合中从第一个元素开始到第一个不符合条件的元素之前的所有元素。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">println((<span class="number">1.</span><span class="number">.10</span>).takeWhile &#123; it % <span class="number">5</span> != <span class="number">0</span> &#125;)</div></pre></td></tr></table></figure>
<p>这表明，从 1..10 当中取元素，只要遇到一个是 5 的倍数的元素，那么立即返回，即结果为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
<h3 id="2-5-let"><a href="#2-5-let" class="headerlink" title="2.5 let"></a>2.5 let</h3><p>let 实际上比较简单，我们先来看下它的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R = block(<span class="keyword">this</span>)</div></pre></td></tr></table></figure>
<p>我们看到 let 实际上传入了一个 Lambda，而这个 Lambda 传入的参数就是 let 的调用者本身，返回值随便你。这个 let 有什么用呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> person: Person? = findPerson()</div></pre></td></tr></table></figure>
<p>我们看到 person 这个变量是可空的，我们需要做一些判断才能对其进行操作。通常的写法可能是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person?.name = <span class="string">"张三"</span> </div><div class="line">person?.age = <span class="number">18</span> </div><div class="line">...</div></pre></td></tr></table></figure>
<p>不过，这种问好满天飞的写法，看着其实并不是很让人舒服。</p>
<p>我们还可以这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(person != <span class="literal">null</span>)&#123; </div><div class="line">	person.name = <span class="string">"张三"</span> <span class="comment">// person 被智能转换成 Person 类型 </span></div><div class="line">	person.age = <span class="number">18</span> </div><div class="line">	... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，我们还有一种写法就是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">person?.let&#123; </div><div class="line">	it.name = <span class="string">"张三"</span> </div><div class="line">	it.age = <span class="number">18</span> </div><div class="line">	... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>let 比较简单，其用法也是很灵活的，大家可以自行发挥。</p>
<h3 id="2-6-apply-with"><a href="#2-6-apply-with" class="headerlink" title="2.6 apply / with"></a>2.6 apply / with</h3><p>下面我们来看 apply。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; block(); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</div></pre></td></tr></table></figure>
<p>注意到 apply 传入的 Lambda 也是 apply 的调用者的扩展方法，所以，apply 相当于给了我们一个灵活切换上下文的机会，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Options</span></span>&#123; </div><div class="line">    <span class="keyword">var</span> scale: <span class="built_in">Float</span> = <span class="number">1</span>f </div><div class="line">    <span class="keyword">var</span> offsetX: <span class="built_in">Double</span> = <span class="number">0.0</span> </div><div class="line">    <span class="keyword">var</span> offsetY: <span class="built_in">Double</span> = <span class="number">0.0</span> </div><div class="line">    <span class="keyword">var</span> rotationX: <span class="built_in">Float</span> = <span class="number">0</span>f </div><div class="line">    <span class="keyword">var</span> rotationY: <span class="built_in">Float</span> = <span class="number">0</span>f </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设我们有这么一个类，我们在操作一个地图变换的时候需要传入这个东西，告诉地图该怎么变换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mapView.animateChange(Options().apply &#123;  </div><div class="line">	<span class="comment">//Options 的作用域 </span></div><div class="line">    scale = <span class="number">2</span>f </div><div class="line">    rotationX = <span class="number">180</span>f </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>而 with 呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; R): R = receiver.block()</div></pre></td></tr></table></figure>
<p>跟 apply 比较类似，不同之处在与 Lambda 返回值。with 只是单纯的获取 receiver 的上下文，而 apply 则同时也把它本身返回了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> br = BufferedReader(FileReader(<span class="string">"hello.txt"</span>)) </div><div class="line">with(br)&#123; </div><div class="line">    <span class="keyword">var</span> line: String? </div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123; </div><div class="line">        line = readLine()?: <span class="keyword">break</span> </div><div class="line">    &#125; </div><div class="line">    close() </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到在 with 当中，readLine 和 close 方法可以直接调用。</p>
<p>内置高阶函数其实非常多，这几个比较常用，剩下的大家可以自行学习。</p>
<h2 id="3-尾递归优化"><a href="#3-尾递归优化" class="headerlink" title="3 尾递归优化"></a>3 尾递归优化</h2><p>递归大家都熟悉，一说递归大家都容易哆嗦：你可别递归的层次太深了啊，不然小心 StackOverflow！没错，StackOverflow 这个异常实在是太常见了，所以你最熟悉的程序员社交网站当中就有一个叫 StackOverflow 的。</p>
<p>其实大家肯定也都知道，递归能实现的，用迭代也基本上能实现，这个感觉就好像做小学数学题，用递归就好比设个 x，列个方程求解；而用迭代呢，就好比用算式生生的去把结果给算出来。前者思考起来比较直接，编写起来也自然更符合人的思维模式，后者呢往往编写困难，代码可读性差。</p>
<p>如果有一天，我能写出递归程序，编译器呢，却能够按照迭代的方式给我运行，那么我岂不是既能获得递归的简洁性，又不失迭代的运行效率，那该。。。想得美啊。</p>
<p>我们今天就要给大家看一种特定条件下的编译优化措施。其实前面我们的设想并不是完全做不到，对于某些比较简单的场景，编译器是可以直接把我们的递归代码翻译成迭代代码的，而这种场景其实就是“尾递归”。</p>
<p>什么叫“尾递归”？函数在调用自己之后，没有任何操作的情形就是尾递归。</p>
<p>比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>, <span class="keyword">var</span> next: ListNode?) </div><div class="line">　 </div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head: <span class="type">ListNode</span>?, value: <span class="type">Int</span>)</span></span>: ListNode?&#123; </div><div class="line">    head?: <span class="keyword">return</span> <span class="literal">null</span> </div><div class="line">    <span class="keyword">if</span>(head.value == value) <span class="keyword">return</span> head </div><div class="line">    <span class="keyword">return</span> findListNode(head.next, value) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们随便定义了一个链表，ListNode 是它的元素，findListNode 目的是找到对应值的元素。我们看到最后一行只有 findListNode 的调用，没有其他任何操作，这就是尾递归。</p>
<p>我们再来看几个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">factorial</span><span class="params">(n: <span class="type">Long</span>)</span></span>: <span class="built_in">Long</span>&#123; </div><div class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>求阶乘，因为 factorial 调用之后还有乘以 n 的操作，所以这个不是尾递归。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)&#123; </div><div class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span> </div><div class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span> </div><div class="line">&#125; </div><div class="line">　 </div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findTreeNode</span><span class="params">(root: <span class="type">TreeNode</span>?, value: <span class="type">Int</span>)</span></span>: TreeNode?&#123; </div><div class="line">    root?: <span class="keyword">return</span> <span class="literal">null</span> </div><div class="line">    <span class="keyword">if</span>(root.value == value) <span class="keyword">return</span> root </div><div class="line">    <span class="keyword">return</span> findTreeNode(root.left, value) ?: <span class="keyword">return</span> findTreeNode(root.right, value) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个算不算尾递归呢？好像最后一行的两个 return 都是之调用了 findTreeNode，没有其他操作了啊，这个应该是尾递归吧？答案当然不是。。因为第一个 findTreeNode 的结果拿到之后，我们要看下他是不是为 null，实际上这个判断操作在 findTreeNode 之后，所以不能算尾递归。对于不是尾递归的情况，编译器是没有办法做优化的。</p>
<p>而对于尾递归的情况，我们该如何启用编译器优化呢？</p>
<p>要说告诉编译器需要尾递归优化，其实非常简单，加一个关键字即可：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tailrec <span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head: <span class="type">ListNode</span>?, value: <span class="type">Int</span>)</span></span>: ListNode?&#123; </div><div class="line">    head?: <span class="keyword">return</span> <span class="literal">null</span> </div><div class="line">    <span class="keyword">if</span>(head.value == value) <span class="keyword">return</span> head </div><div class="line">    <span class="keyword">return</span> findListNode(head.next, value) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个看起来真的很简单，简单到没有说服力。我们看一段小程序：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> MAX_NODE_COUNT = <span class="number">100000</span> </div><div class="line"><span class="keyword">val</span> head = ListNode(<span class="number">0</span>) </div><div class="line"><span class="keyword">var</span> p = head </div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.MAX_NODE_COUNT)&#123; </div><div class="line">    p.next = ListNode(i) </div><div class="line">    p = p.next!! </div><div class="line">&#125; </div><div class="line"><span class="comment">//前面先构造了一个链表，节点个数有 10 万个 </span></div><div class="line"><span class="comment">//后面进行查找，查找值为 MAX_NODE_COUNT - 2 的节点 </span></div><div class="line">println(findListNode(head, MAX_NODE_COUNT - <span class="number">2</span>)?.value)</div></pre></td></tr></table></figure>
<p>对于没有 tailrec 关键字的版本，结果非常抱歉：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.StackOverflowError </div><div class="line">	at net.println.kotlin.RecursiveKt.findListNode(Recursive.kt:<span class="number">34</span>) </div><div class="line">	at net.println.kotlin.RecursiveKt.findListNode(Recursive.kt:<span class="number">34</span>)</div></pre></td></tr></table></figure>
<p>而对于有 tailrec 的版本，结果是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">99998</span></div></pre></td></tr></table></figure>
<p>显然，对于尾递归优化的版本，即使你递归再多的层次，都不会有 StackOverflow，原因也很简单，编译器其实已经把这种递归编译成迭代来运行了，迭代怎么会有 StackOverflow 呢？</p>
<p>接着我们再来讨论一下非尾递归代码可以改写为尾递归代码的条件。大家仔细观察我们前面给出的两个例子，一个是求阶乘，一个是超找树的节点。二者最后一句：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> findTreeNode(root.left, value) ?: <span class="keyword">return</span> findTreeNode(root.right, value)</div></pre></td></tr></table></figure>
<p>虽然都不是尾递归，但还是有差异的。前者在调用完自己之后进行了跟调用自己无关的运算；后者调用完一次自己之后，还有可能调用一次自己。注意，如果调用完自己，又进行了其他操作，也即没有再次调用自己，那么这种递归其实有希望转换为尾递归代码，下面我们就改写一下求阶乘的代码，让它变成尾递归代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">factorial</span><span class="params">(n: <span class="type">Long</span>)</span></span>: <span class="built_in">Long</span>&#123; </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>(<span class="keyword">var</span> value: <span class="built_in">Long</span>) </div><div class="line">　 </div><div class="line">    tailrec <span class="function"><span class="keyword">fun</span> <span class="title">factorial0</span><span class="params">(n: <span class="type">Long</span>, result: <span class="type">Result</span>)</span></span>&#123; </div><div class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123; </div><div class="line">            result.value *= n </div><div class="line">            factorial0(n - <span class="number">1</span>, result) </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">val</span> result = Result(<span class="number">1</span>) </div><div class="line">    factorial0(n, result) </div><div class="line">    <span class="keyword">return</span> result.value </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子当中有一些比较有意思的概念哈，我们在一个函数当中定义了一个函数和一个类，它们被称作“本地函数”和“本地类”，由于定义在函数内部，因此在外部无法使用它们。接着我们对内部的 factorial0 加了 tailrec 关键字，由于最后一行只有对自己的调用，因此符合尾递归优化的条件。</p>
<p>我们看到，之前 n * 的这部分操作通过 Result 携带的中间结果被移到了自身调用的前面，这样做让原本的递归代码符合了尾递归优化的条件，却也让代码本身复杂了许多。而对于此类操作，我个人更倾向于直接使用迭代。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">factorial</span><span class="params">(n: <span class="type">Long</span>)</span></span>: <span class="built_in">Long</span>&#123; </div><div class="line">    <span class="keyword">var</span> result: <span class="built_in">Long</span> = <span class="number">1</span> </div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n)&#123; </div><div class="line">        result *= i </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> result </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代的代码显然也直截了当得多。</p>
<p>总而言之，使用递归是为了让我们的代码更直接，更自然，使用迭代往往是为了追求效率（空间效率）。对于类似查找链表节点这样的场景，它很自然的就是一个尾递归的结构，我们可以使用尾递归优化来提升它的性能；而对于求阶乘这样的场景，它本来就不是尾递归的结构，我们尽管可以通过某种方式改写它，但这样做其实根本没必要；而对于查找树节点这样的场景，尾递归基本上是无能无力了。</p>
<p>##4 闭包</p>
<p>对象是要携带状态的。比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> string = <span class="string">"HelloWorld"</span></div></pre></td></tr></table></figure>
<p>string 这个对象它有值，这个值就是它的状态。那么同样作为对象的函数，它有什么状态呢？我们看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeFun</span><span class="params">()</span></span>: ()-&gt;<span class="built_in">Unit</span>&#123; </div><div class="line">    <span class="keyword">var</span> count = <span class="number">0</span> </div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123; </div><div class="line">        println(++count) </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line">　 </div><div class="line">... </div><div class="line">　 </div><div class="line"><span class="keyword">val</span> x = makeFun() </div><div class="line">x() </div><div class="line">x() </div><div class="line">x() </div><div class="line">x()</div></pre></td></tr></table></figure>
<p>输出的结果会是什么呢？从函数当中返回一个函数，这在 Java 当中简直不能想象，不过这在函数为“一等公民”的 Groovy、JavaScript 当中确实寻常可见。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> </div><div class="line"><span class="number">2</span> </div><div class="line"><span class="number">3</span> </div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>每次调用 x，打印的值都不一样，这说明函数也是可以保存状态的。受到这个启发，我们是不是可以继续写出这样的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fibonacci</span><span class="params">()</span></span>: ()-&gt;<span class="built_in">Long</span>&#123; </div><div class="line">    <span class="keyword">var</span> first = <span class="number">0</span>L </div><div class="line">    <span class="keyword">var</span> second = <span class="number">1</span>L </div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">()</span></span>: <span class="built_in">Long</span>&#123; </div><div class="line">        <span class="keyword">val</span> result = second </div><div class="line">        second += first </div><div class="line">        first = second - first </div><div class="line">        <span class="keyword">return</span> result </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line">... </div><div class="line">　 </div><div class="line"><span class="keyword">val</span> next = fibonacci() </div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>)&#123; </div><div class="line">    println(next()) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> </div><div class="line"><span class="number">1</span> </div><div class="line"><span class="number">2</span> </div><div class="line"><span class="number">3</span> </div><div class="line"><span class="number">5</span> </div><div class="line"><span class="number">8</span> </div><div class="line"><span class="number">13</span> </div><div class="line"><span class="number">21</span> </div><div class="line"><span class="number">34</span> </div><div class="line"><span class="number">55</span></div></pre></td></tr></table></figure>
<p>我们干脆再进一步吧：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fibonacciGenerator</span><span class="params">()</span></span>: Iterable&lt;<span class="built_in">Long</span>&gt;&#123; </div><div class="line">    <span class="keyword">var</span> first = <span class="number">0</span>L </div><div class="line">    <span class="keyword">var</span> second = <span class="number">1</span>L </div><div class="line">    <span class="keyword">return</span> Iterable &#123; </div><div class="line">        <span class="keyword">object</span> : LongIterator()&#123; </div><div class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span> = <span class="literal">true</span> </div><div class="line">　 </div><div class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextLong</span><span class="params">()</span></span>: <span class="built_in">Long</span> &#123; </div><div class="line">                <span class="keyword">val</span> result = second </div><div class="line">                second += first </div><div class="line">                first = second - first </div><div class="line">                <span class="keyword">return</span> result </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line">　 </div><div class="line">... </div><div class="line">　 </div><div class="line"><span class="keyword">for</span>(x <span class="keyword">in</span> fibonacciGenerator())&#123; </div><div class="line">    println(x) </div><div class="line">    <span class="keyword">if</span>(x &gt; <span class="number">100</span>) <span class="keyword">break</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子我们干得更彻底，通过返回一个 Iterable，我们甚至可以用 for 循环迭代这个结果。</p>
<p>不管我们怎么写，请注意，每次调用同一个函数的结果都不一样，而承载返回结果的 first 和 second 这两个变量是定义在最外层的函数当中的，按说这个函数一旦运行完毕，它所在的作用域就会被回收，如果真是那样，前面的这两段代码一定是我们产生的幻觉。如果不是幻觉，那只能说明一个问题：这个作用域没有被回收。</p>
<p>这个作用域包含了所有函数运行的状态，包括变量、本地类、本地函数等等，那这个作用域其实就是闭包。</p>
<p>我们再来看个好玩的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(x: <span class="type">Int</span>)</span></span> = <span class="function"><span class="title">fun</span><span class="params">(y: <span class="type">Int</span>)</span></span> = x + y </div><div class="line">　 </div><div class="line">... </div><div class="line"><span class="keyword">val</span> add5 = add(<span class="number">5</span>) </div><div class="line">println(add5(<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>很显然，结果是 7，这个 add 的定义其实写得有些令人迷惑，我把它改写一下给大家看：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(x: <span class="type">Int</span>)</span></span>: (<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span>&#123; </div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123; </div><div class="line">        <span class="keyword">return</span> x + y </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很显然，当我们调用 add(5) 返回 add5 这个函数时，它是持有了 add 函数的运行环境的，不然它怎么知道 x 的值是多少呢？</p>
<p>通过这几个小例子，相信大家对闭包有了一定的了解。闭包其实就是函数运行的环境。</p>
<blockquote>
<p>下周我们还会继续跟大家讨论函数编程相关的一些话题，谢谢大家的关注~</p>
</blockquote>
<p><img src="/arts/kotlin扫码关注.png" alt=""></p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-05-22T02:30:56.921Z" itemprop="dateUpdated">2017年5月22日 10:30</time>
</span><br>


        
        转载请注明出处：<a href="/2017/02/20/高阶函数（一）/ " target="_blank" rel="external">http://www.Kotliner.cn/2017/02/20/高阶函数（一）/</a>
        
    </div>
    <footer>
        <div>
            <a href="/authors/bennyhuo/">
                
                <img src="/assets/img/Kotlin-logo.png" alt="Kotlin">
                
                bennyhuo
                
            </a>
            
        </div>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/尾递归/">尾递归</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高阶函数/">高阶函数</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.Kotliner.cn/2017/02/20/高阶函数（一）/&title=《高阶函数（一）》 — Kotlin&pic=http://www.Kotliner.cn/assets/img/Kotlin-logo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.Kotliner.cn/2017/02/20/高阶函数（一）/&title=《高阶函数（一）》 — Kotlin&source=Kotlin 是一门由 JetBrains 公司开发的运行在 JVM、Android、前端的静态语言，它 100% 兼容 Java，并且开始逐步支持 Na..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.Kotliner.cn/2017/02/20/高阶函数（一）/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《高阶函数（一）》 — Kotlin&url=http://www.Kotliner.cn/2017/02/20/高阶函数（一）/&via=http://www.Kotliner.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.Kotliner.cn/2017/02/20/高阶函数（一）/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/02/20/Kotlin 1.1：我们在路上/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Kotlin 1.1：我们在路上</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/02/17/Kotlin 1.1 Release Candidate is Here/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">[译]Kotlin 1.1 候选版本来啦</h4>
      </a>
    </div>
  
</nav>



    










<div class="comments" id="comments">
<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
</div>
<script>
    var cloudTieConfig = {
        url: document.location.href,
        sourceId: "",
        productKey: "0263eabe3b1b46709556eda1c39750be",
        target: "cloud-tie-wrapper"
    };
</script>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        Have a nice Kotlin!
        <i class="icon icon-quote-right"></i>
    </h3>
    <ul class="reward-items">
        
        
        <li>
            <img src="/assets/img/wechat.jpg" title="微信打赏二维码" alt="微信打赏二维码">
            <p>微信</p>
        </li>
        

        
        <li>
            <img src="/assets/img/alipay.jpg" title="支付宝打赏二维码" alt="支付宝打赏二维码">
            <p>支付宝</p>
        </li>
        
    </ul>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            <span>博客内容遵循 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p>
            <span class="copyright-text">京ICP备16022265号-2&nbsp;</span>
            <span>Kotlin &copy; 2017</span>
        </p>
        <p>
            本站由<a style="display:inline" href="https://account.ucloud.cn/cas/register?utm_source=kotliner&utm_medium=content_pic_pc&utm_campaign=zanzhu&ytag=kotliner">UCloud 提供赞助 - 注册即送 50 元代金券</a>
        </p>
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.Kotliner.cn/2017/02/20/高阶函数（一）/&title=《高阶函数（一）》 — Kotlin&pic=http://www.Kotliner.cn/assets/img/Kotlin-logo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.Kotliner.cn/2017/02/20/高阶函数（一）/&title=《高阶函数（一）》 — Kotlin&source=Kotlin 是一门由 JetBrains 公司开发的运行在 JVM、Android、前端的静态语言，它 100% 兼容 Java，并且开始逐步支持 Na..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.Kotliner.cn/2017/02/20/高阶函数（一）/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《高阶函数（一）》 — Kotlin&url=http://www.Kotliner.cn/2017/02/20/高阶函数（一）/&via=http://www.Kotliner.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.Kotliner.cn/2017/02/20/高阶函数（一）/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIUlEQVR42u3ay3KDMAwF0Pz/T6fbdlrolQSZwT6sMik4PixU6/F6xdf79Dq65/v3v+85X/l1x4WBgfFYRr7F86eO/nr+TfIKIioGBsYGjKMIlvzk+Z1J2E2o/+wZAwMDI146CcTJ6Q4DAwOjx5hsInm2+sowMDB2Y/RKadVjX/JSbs/FMTAwHsjIq+6f/3xLfwMDA+NRjHfxOj+c9QJ3Hl4Pn8XAwFia0WthzpPValktSmUxMDA2YOTls6T1mJ/lkgNotAIGBsaWjGrgS5C9w2JUsMPAwNiAUU1Wr6r29cI3BgbGPowkCPZaib32ZO9gioGBsTbj2iR2sma+DgYGxm6Ma5PJefMgX/nHZwwMjA0Yva3kKe6kLRoFfQwMjKUZ5dBW3G5vhCIfO8PAwNiNkYTIakF/crgsj3FgYGAszeiNYU3aA9XhMAwMDIxyuhiE7DwQ98LrqB+LgYHxKEY1gOZbrx5D83X+2CcGBsbSjOSmfMCih6wOhGFgYOzJqP7khFctw+XDGRgYGPswqqW0ali8b3QDAwNjbUYeCpPCXFKwqybM5UMnBgbGQox38ZoPVUyao83MGwMD4+GMapjrHfiuaoiOZkkwMDAezugF2by5WC3S5QEXAwNjN8ZkMKJ6iJz8B4jybwwMjO0ZedtgMpZRBmNgYGCMmwGTMI2BgYExSWJ7wTdPa8szIxgYGIsyLpvUaBXmkiS5nNBiYGCsw/gCvWj1G9eduiwAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };



lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1261686164&web_id=1261686164')

</script>

<script src="/js/main.min.js?v=1.5.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.5.2" async></script>





<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'Kotlin 博客';
            clearTimeout(titleTime);
        } else {
            document.title = 'Kotlin 博客';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



</body>
</html>
