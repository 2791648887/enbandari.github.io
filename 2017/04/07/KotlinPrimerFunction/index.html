<!DOCTYPE html>
<html>
<head>
    

    

    


<!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Baidu Push -->
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- End Baidu Push -->


    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="true">
    <meta name="baidu-site-verification" content="97dbRVWfVh" />
    <meta name="sogou_site_verification" content="AIePRXkUI4"/>
    
    
    <link rel="canonical" href="http://www.kotliner.cn/2017/04/07/KotlinPrimerFunction/">
    
    
    <title>Kotlin Primer草稿 函数 | Kotlin | 简洁、优雅，100% 兼容 Java</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="函数式编程">
    <meta name="description" content="Kotlin functions for Kotlin Primer">
<meta name="keywords" content="Kotlin">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin Primer草稿 函数">
<meta property="og:url" content="https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/index.html">
<meta property="og:site_name" content="Kotlin">
<meta property="og:description" content="Kotlin functions for Kotlin Primer">
<meta property="og:image" content="https://coding.net/u/ice1000/p/Images/git/raw/master/blog-img/3/1.PNG">
<meta property="og:image" content="https://coding.net/u/ice1000/p/Images/git/raw/master/blog-img/3/2.PNG">
<meta property="og:updated_time" content="2017-05-22T02:30:56.906Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin Primer草稿 函数">
<meta name="twitter:description" content="Kotlin functions for Kotlin Primer">
<meta name="twitter:image" content="https://coding.net/u/ice1000/p/Images/git/raw/master/blog-img/3/1.PNG">
    
        <link rel="alternative" href="/atom.xml" title="Kotlin" type="application/atom+xml">
    
    <link rel="shortcut icon" href="/assets/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.5.2">
    <script>window.lazyScripts=[]</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/assets/img/Kotlin-logo.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Kotlin</h5>
          <a href="mailto:kotlin@kotliner.cn" title="kotlin@kotliner.cn" class="mail">kotlin@kotliner.cn</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.kotlincn.net"  >
                <i class="icon icon-lg icon-certificate"></i>
                官网
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                所有文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/authors"  >
                <i class="icon icon-lg icon-user"></i>
                所有作者
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-info"></i>
                关于我们
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/beijing/"  >
                <i class="icon icon-lg icon-map-marker beijing"></i>
                北京分会
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/chengdu/"  >
                <i class="icon icon-lg icon-map-marker chengdu"></i>
                成都分会
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://shanghai.kotliner.cn"  >
                <i class="icon icon-lg icon-map-marker shanghai"></i>
                上海分会
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Kotlin Primer草稿 函数</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Kotlin Primer草稿 函数</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-04-07T01:10:11.000Z" itemprop="datePublished" class="page-time">
  2017-04-07
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程语言/">编程语言</a></li></ul>

            
        </h5>
    </div>

    

</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数"><span class="post-toc-text">函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#普通函数"><span class="post-toc-text">普通函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#声明"><span class="post-toc-text">声明</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#内部函数"><span class="post-toc-text">内部函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#方法"><span class="post-toc-text">方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#中缀表达式"><span class="post-toc-text">中缀表达式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#操作符重载"><span class="post-toc-text">操作符重载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Lambda表达式"><span class="post-toc-text">Lambda表达式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#调用"><span class="post-toc-text">调用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#内联函数"><span class="post-toc-text">内联函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#crossinline与noinline"><span class="post-toc-text">crossinline与noinline</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#扩展函数"><span class="post-toc-text">扩展函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#普通的扩展函数"><span class="post-toc-text">普通的扩展函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#扩展Lambda"><span class="post-toc-text">扩展Lambda</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#泛型扩展"><span class="post-toc-text">泛型扩展</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#关于扩展是否会污染原库的讨论"><span class="post-toc-text">关于扩展是否会污染原库的讨论</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<article id="post-KotlinPrimerFunction"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Kotlin Primer草稿 函数</h1>
        <div class="post-meta">
            <time class="post-time" title="2017年04月07日 9:10" datetime="2017-04-07T01:10:11.000Z"  itemprop="datePublished">2017-04-07</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程语言/">编程语言</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>本章节主要介绍Kotlin中的函数相关的概念。</p>
<h2 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>即使Kotlin是一门面向对象的编程语言，它也是有函数的概念的——而不像Java那样，仅仅有“方法”。</p>
<p>Java中有静态方法来代替函数的作用，但是Kotlin的函数比Java的静态方法自由度大很多。<br>我们先来看几个例子。</p>
<p>函数声明使用fun保留字，语法比较类似Scala：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">()</span></span> &#123;</div><div class="line">  println(<span class="string">"This is a function"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你需要一个有参数的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionWithParams</span><span class="params">(obj: <span class="type">Any</span>?)</span></span> &#123;</div><div class="line">  println(<span class="string">"You have passed an object to this function: <span class="subst">$obj</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的函数有一个Any?类型的参数。类似的例子还有程序的入口main函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你需要一个返回值的话：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionWithReturnValue</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">  <span class="keyword">return</span> Random().nextInt()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个函数不返回东西，你可以不写返回值。也可以让它显示返回Unit：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionReturnsUnit</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个函数不会返回（也就是说只要调用这个函数，那么在它返回之前程序肯定GG了（比如一定会抛出异常的函数）），<br>因此你也不知道返回值该写啥，那么你可以让它返回Nothing：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionReturnsNothing</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> &#123;</div><div class="line">  <span class="keyword">throw</span> RuntimeException(<span class="string">""</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个函数也可以拥有Java风格的泛型参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">functionWithGenericsParam</span><span class="params">(t: <span class="type">T</span>)</span></span>: T &#123;</div><div class="line">  <span class="keyword">return</span> t</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Kotlin中的泛型概念和Java基本相同，这里不再展开讨论。关于型变、协变等Java中没有的复杂泛型概念将在下文讨论。</p>
<p>函数参数可以有默认值（关于这个函数中for循环的中缀语法下文会提到，这里可以先忽略）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionWithDefaultParams</span><span class="params">(limit: <span class="type">Int</span> = <span class="number">10</span>)</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.limit step <span class="number">2</span>) println(i)</div><div class="line">  <span class="keyword">return</span> limit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是你不再需要像Java那样为了默认参数而写一大长串重载函数了。当然，Kotlin也支持重载。</p>
<p>如果一个函数的函数体只需要一个表达式就可以计算出来，比如考虑如下函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionReturningIncreasedInteger</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">  <span class="keyword">return</span> num + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以直接使用这种语法（expression function body）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionReturningIncreasedInteger</span><span class="params">(num: <span class="type">Int</span>)</span></span> = num + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>第二种语法省略了返回值类型（编译器可以根据后面的表达式推导出返回类型），以及大括号。</p>
<p>同理，比如说我们有一个求平方的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">square</span><span class="params">(int: <span class="type">Int</span>)</span></span> = int * int</div></pre></td></tr></table></figure>
<p>如果一个函数是空函数，比如Swing的ActionListener强制要求重载但是又不需要使用的函数，可以通过这种方式来表达：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> input = JTextField()</div><div class="line">  input.addKeyListener(<span class="keyword">object</span> : KeyListener &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">keyTyped</span><span class="params">(e: <span class="type">KeyEvent</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">keyReleased</span><span class="params">(e: <span class="type">KeyEvent</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">keyPressed</span><span class="params">(e: <span class="type">KeyEvent</span>?)</span></span> &#123;</div><div class="line">      <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.keyCode == KeyEvent.VK_ENTER) &#123;</div><div class="line">        output.append(<span class="string">"<span class="subst">$&#123;input.text&#125;</span>\n"</span>, Color(<span class="number">0x467CDA</span>))</div><div class="line">        repl.handle(input.text, sl)</div><div class="line">        input.text = <span class="string">""</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中， <code>fun xxx() = Unit</code> 表示这是一个空函数。</p>
<p>如果一个函数不返回Unit或者Nothing，那么<strong>尽可能让它成为一个<a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="external">纯函数</a></strong>（即没有<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science" target="_blank" rel="external">副作用</a>)的函数）。<br>这是<strong><a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">函数式编程</a></strong>的约定。</p>
<blockquote>
<p>关于函数式编程：<br><br>函数式编程是一种学院派的编程范式，与之对应的是“命令式编程”。它常常与数学中的范畴论（category theory）结合，追求编写更易维护、并发性更好的程序。业界对它褒贬不一，笔者倾向于将它与面向对象编程结合。</p>
</blockquote>
<p>虽然Hadi Hariri曾经在JetBrains中国开发者日上说过Kotlin不是函数式编程语言，但是Kotlin有大量的（看起来非常）函数式的特性、约定、标准库函数。<br>因此我们可以默认它是追求函数式编程的，那么就应该尽可能遵循函数式法则。</p>
<blockquote>
<p>为什么返回Unit或者Nothing就不需要纯了呢？</p>
</blockquote>
<p>既然一个函数没有返回值，那么对它讨论<a href="https://en.wikipedia.org/wiki/Referential_transparency" target="_blank" rel="external">引用透明</a>也就没有意义了。<br>如果一个返回Unit或者Nothing的函数没有副作用，那么它的存在也将没有意义。</p>
<p>更多关于函数式编程的知识不在本书讨论范围内，读者可以自行查询相关资料。</p>
<h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>函数里面也可以定义函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionWithAnotherFunctionInside</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> valuesInTheOuterScope = <span class="string">"Kotlin is awesome!"</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">theFunctionInside</span><span class="params">(int: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</div><div class="line">    println(valuesInTheOuterScope)</div><div class="line">    <span class="keyword">if</span> (int &gt;= <span class="number">5</span>) theFunctionInside(int - <span class="number">1</span>)</div><div class="line">  &#125;</div><div class="line">  theFunctionInside()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部函数可以直接访问外部函数的局部变量、常量，Java是做不到这点的哦。</p>
<p>递归也没有任何问题。如上面的代码所示。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是一种特殊的函数，它必须通过类的实例调用，也就是说每个方法可以在方法内部拿到这个方法的实例。这是方法和函数的不同之处。</p>
<p>方法和函数几乎一模一样，唯一的区别就是方法必须声明在类里面。下面是一个方法和一个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">thisIsAFunction</span><span class="params">()</span></span> = <span class="built_in">Unit</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisIsAClass</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">thisIsAMethod</span><span class="params">()</span></span> = <span class="built_in">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>可能你会好奇上面给出的一个例子中有一个for循环使用的诡异语法，即中缀表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span> step <span class="number">20</span>) &#123;</div><div class="line">    println(i)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个step是什么意思呢？</p>
<p>其实是Kotlin方法的一种语法糖，一个方法如果在声明时有一个infix修饰符，那么它可以使用中缀语法调用。</p>
<p>所谓中缀语法就是不需要点和括号的方法调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">infixFunction</span><span class="params">(b: <span class="type">B</span>)</span></span> &#123;</div><div class="line">    <span class="comment">// codes</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = A()</div><div class="line">  a infixFunction b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，我们只需要给一个类增加一个中缀的step方法就可以实现上面的语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">step</span><span class="params">(step: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = A()</div><div class="line">  a step <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个功能基本就是用于将代码变得“更易阅读”。<br>Scala所有函数缺省支持中缀表达式，Kotlin需要单独声明。</p>
<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>中缀表达式可以在一定程度上简化函数调用的代码。如果说中缀表达式还不够简洁，那么你一定需要操作符重载了。</p>
<p>Kotlin的操作符重载的规则是：</p>
<ol>
<li>该方法使用operator修饰符</li>
<li>该方法的方法名必须被声明为特定的名称，以将对应的操作符映射为这个函数的调用</li>
<li>参数必须符合该操作符的规定，比如+的重载就不能有多于一个（不含）的参数，也不能为空参数。</li>
</ol>
<p>举个例子，我们要重载A类的+运算符。注意三个规定（函数名、参数得符合规矩，加operator修饰）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">A</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"invoking plus"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是对+的重载了。我们可以这样调用这个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = A() + A()</div></pre></td></tr></table></figure>
<p>此处的+就是对plus方法的调用了。我们可以运行上面的代码，看到输出：”invoking plus”。</p>
<p>当然，操作符重载也可以被替换为函数调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = A().plus(A())</div></pre></td></tr></table></figure>
<p>这段代码和上面那段完全相同。</p>
<p>还有不少操作符的重载，下面给出一系列例子（仅作为函数名的实例，实现全部为空/false/0（因为部分操作符重载要求返回Int/Boolean））：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">times</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">div</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rem</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="meta">@Suppress(<span class="meta-string">"DEPRECATED_BINARY_MOD"</span>)</span></div><div class="line">  <span class="meta">@Deprecated(<span class="meta-string">"mod should be replaced with rem"</span>, ReplaceWith(<span class="meta-string">"rem"</span>)</span>)</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">mod</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rangeTo</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">Any</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>, value: <span class="type">Any</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">  </div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(obj: <span class="type">Any</span>?)</span></span></div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">inc</span><span class="params">()</span></span> = A()</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">dec</span><span class="params">()</span></span> = A()</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryPlus</span><span class="params">()</span></span> = A()</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryMinus</span><span class="params">()</span></span> = A()</div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Any</span>?)</span></span> = <span class="number">0</span></div><div class="line">  <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span> = <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">Any</span>?)</span></span> = <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span> = <span class="keyword">object</span> : Iterator&lt;Any&gt; &#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span> = <span class="literal">false</span></div><div class="line">    <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span> = <span class="built_in">Unit</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是最基本的操作符，它们对应的操作符和注释中的一一对应：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// +</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// -</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">times</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// *</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">div</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// /</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rem</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// %</span></div><div class="line"></div><div class="line">  <span class="meta">@Suppress(<span class="meta-string">"DEPRECATED_BINARY_MOD"</span>)</span></div><div class="line">  <span class="meta">@Deprecated(<span class="meta-string">"mod should be replaced with rem"</span>, ReplaceWith(<span class="meta-string">"rem"</span>)</span>)</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">mod</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// %，和rem一样</span></div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">rangeTo</span><span class="params">(a: <span class="type">A</span>)</span></span> = <span class="built_in">Unit</span> <span class="comment">// ..</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>倒数第二个mod是特殊的操作符重载——它在Kotlin1.1中被标记为过时（Deprecated）的。<br>在1.1中，使用了rem（remainder）来代替mod，符合java.math.BigInteger的命名。</p>
<p>关于最后那个rangeTo有些不符合人的直觉，下面讲到contains的时候会一起提到，读者可以暂时放下这个问题。</p>
<p>然后是下标访问操作符：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">Any</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>, value: <span class="type">Any</span>?)</span></span> = <span class="built_in">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get接收任意数量的int参数，假设它们是index1, index2, index3（以此类推），<br>那么对应的操作符就是对应维数个下标的访问。比如以下例子，操作符对应的方法调用写在行尾注释里了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = A()</div><div class="line">  a[<span class="number">1</span>] <span class="comment">// a.get(1)</span></div><div class="line">  a[<span class="number">1</span>][<span class="number">2</span>] <span class="comment">// a.get(1, 2)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的set接收任意数量个int，以及一个任意类型的对象，表示将下标访问作为左值并赋值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = A()</div><div class="line">  a[<span class="number">1</span>] = <span class="number">233</span> <span class="comment">// a.set(1, 233)</span></div><div class="line">  a[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"666"</span> <span class="comment">// a.set(1, 2, "666")</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>invoke方法允许你把一个Kotlin对象当作Lambda表达式来使用。关于什么是Lambda表达式下文会专门介绍。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(obj: <span class="type">Any</span>?)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = A()</div><div class="line">  a(obj) <span class="comment">// 实际上调用了 a.invoke(obj)</span></div><div class="line">  <span class="comment">// 还可以</span></div><div class="line">  A()(obj)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自增自减运算符就更简单了，它们必须返回自己所在类的子类型。这里直接在注释里面写出对应的操作符表达：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设a是A的一个实例</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">inc</span><span class="params">()</span></span> = A() <span class="comment">// a++</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">dec</span><span class="params">()</span></span> = A() <span class="comment">// a--</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryPlus</span><span class="params">()</span></span> = A() <span class="comment">// ++a</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryMinus</span><span class="params">()</span></span> = A() <span class="comment">// --a</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有比较运算符，这是一个特殊的操作符重载，一个函数将会生成一组操作符。有一个特殊情况，就是相等的判断。</p>
<p>考虑以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Any</span>?)</span></span> = <span class="number">0</span></div><div class="line">  <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span> = <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当一个类只有compareTo没有equals的时候，所有的六个比较运算符（\&lt;, >, \&lt;=, >=, ==, !=）会被全部代理给compareTo函数的返回值和0的大小比较：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  A() &gt; A() <span class="comment">// A().compareTo(A()) &gt; 0</span></div><div class="line">  A() &lt; A() <span class="comment">// A().compareTo(A()) &gt; 0</span></div><div class="line">  A() &gt;= A() <span class="comment">// A().compareTo(A()) &gt;= 0</span></div><div class="line">  A() &lt;= A() <span class="comment">// A().compareTo(A()) &lt;= 0</span></div><div class="line">  A() == A() <span class="comment">// A().compareTo(A()) == 0</span></div><div class="line">  A() != A() <span class="comment">// A().compareTo(A()) != 0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有equals，==和!=两个操作符会被代理给equals方法，其余不变。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  A() == A() <span class="comment">// A().equals(A())</span></div><div class="line">  A() != A() <span class="comment">// !A().equals(A())</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有一个操作符，这个操作符不是严格意义上的“操作符”，但它比起其它的操作符重载，它还多了一个特权。它就是in操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">Any</span>?)</span></span> = <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它要求返回Boolean，传入一个参数。调用的话使用in：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> ls = listOf(<span class="number">12</span>, <span class="number">233</span>, <span class="number">43</span>)</div><div class="line">  println(<span class="number">233</span> <span class="keyword">in</span> ls)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的in就是调用了ls的contains方法。这里你可能要问了：既然是使用in这个符合Kotlin函数命名规范的表达，为什么不使用中缀表达式呢？</p>
<p>想清楚了，我们暂且不说in其实是Kotlin保留字这个问题，中缀表达式的语法是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  a.func(b)</div><div class="line">  <span class="comment">// 变成</span></div><div class="line">  a func b</div><div class="line">  <span class="comment">// 它不能变成</span></div><div class="line">  <span class="comment">// b func a</span></div><div class="line">  <span class="comment">// 上面那个是错的，会变成b.func(a)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是a in b其实是调用了b的一个方法，因此中缀表达式无法实现这个in。</p>
<p>前面说到contains操作符有一个特权，我们来看看这个特权。还记得when语句吗？它非常灵活，比Java风格的switch不知道高到哪里去了。这里先看一个基本用法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = Random(System.currentTimeMillis()).nextInt()</div><div class="line">  <span class="keyword">when</span> (a) &#123;</div><div class="line">    <span class="number">1</span> -&gt; &#123; <span class="comment">/* codes */</span> <span class="number">233</span> &#125;</div><div class="line">    <span class="number">2</span> -&gt; <span class="number">233</span></div><div class="line">    <span class="keyword">else</span> -&gt; <span class="number">666</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它可以配合contains方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = Random(System.currentTimeMillis()).nextInt()</div><div class="line">  <span class="keyword">when</span> (a) &#123;</div><div class="line">    <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span> -&gt; <span class="number">233</span></div><div class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; <span class="number">2333</span></div><div class="line">    <span class="keyword">else</span> -&gt; <span class="number">666</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到了吗？in还可以这样写哦。</p>
<p>还有一组运算符，它们将被编译为相同的一个操作符，也是in，只不过场合不同。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span> = <span class="built_in">Unit</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span> = <span class="literal">false</span></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span> = <span class="built_in">Unit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个in是用于for-in循环的。上面例子中的for循环使用的是这个in操作符。</p>
<p>一个标准的Kotlin风格的for循环应该是下面这样的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它和下面的代码完全等价：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> range = <span class="number">1.</span><span class="number">.10</span></div><div class="line">  <span class="keyword">val</span> item = range.iterator()</div><div class="line">  <span class="keyword">while</span> (item.hasNext()) &#123;</div><div class="line">    println(item.next())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还记得那个step吗？它其实是对1..100调用了一个中缀的方法step。这下读者对于前面遗留的疑问就全部解决了。</p>
<p>Kotlin关于操作符重载的内容确实比较繁杂，但是比起C++的操作符重载还是要强大那么一点点的（C++没有in这种操作符）。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>好了这是函数式编程的重头戏——<a href="https://en.wikipedia.org/wiki/Lambda_expression" target="_blank" rel="external">Lambda表达式</a>。</p>
<p>Lambda表达式俗称匿名函数，熟悉Java的大家应该也明白这是个什么概念。Kotlin的Lambda表达式更“纯粹”一点，<br>因为它是真正把Lambda抽象为了一种类型，而Java只是单方法匿名接口实现的语法糖罢了。</p>
<p>Lambda在Java中非常常用，这里不再单独介绍它。</p>
<p>Lambda表达式最常用的地方之一是为GUI控件设置监听器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> button = JButton(<span class="string">"Clear screen"</span>)</div><div class="line">  button.addActionListener &#123;</div><div class="line">    output.text = <span class="string">""</span></div><div class="line">    output.append(<span class="string">"Repl.HINT"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有调用集合框架抽象出来的<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">高阶函数</a>（Higher Order Function）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  (<span class="number">1.</span><span class="number">.10</span>).forEach &#123;</div><div class="line">    println(it)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码可能会令读者产生疑惑，那个it是什么鬼？</p>
<p>it是Kotlin为单参数的Lambda钦定的默认参数名。单参数的Lambda可以省去参数的声明，转而使用it这个名字。</p>
<p>首先，我们有无参数的Lambda表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以直接把它写在外面，并且把它当成对象使用。Lambda对象有缺省的invoke函数的实现，也就是调用这个Lambda：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  &#123; println(<span class="string">"invoking lambda"</span>) &#125;.invoke()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以使用操作符重载的方式调用invoke函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  &#123; println(<span class="string">"invoking lambda"</span>) &#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个Lambda有参数，那么需要使用这样的语法声明：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="comment">// &#123;参数名:参数类型 -&gt; Lambda体&#125;()</span></div><div class="line">  &#123; str: String -&gt; println(str) &#125;(<span class="string">"the deep dark fantasy"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有多个参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="comment">// &#123;参数名:参数类型, 参数名:参数类型 -&gt; Lambda体&#125;()</span></div><div class="line">  &#123; str: String, num: <span class="built_in">Int</span> -&gt;</div><div class="line">    println(<span class="string">"num = <span class="subst">$num</span>, str = <span class="subst">$str</span>"</span>)</div><div class="line">  &#125;(<span class="string">"the deep dark fantasy"</span>, <span class="number">233</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lambda变量的签名不需要写参数名，只需要写类型。Lambda的返回值就是最后一个表达式的返回值。就像这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="comment">// 只需要写类型，我没骗你吧</span></div><div class="line">  <span class="keyword">val</span> value: (String, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span></div><div class="line">  value = &#123; str: String, num: <span class="built_in">Int</span> -&gt;</div><div class="line">    println(<span class="string">"num = <span class="subst">$num</span>, str = <span class="subst">$str</span>"</span>)</div><div class="line">    num</div><div class="line">  &#125;</div><div class="line">  value(<span class="string">"the deep dark fantasy"</span>, <span class="number">233</span>) + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果Lambda的参数、返回值类型不匹配，互相赋值是会报错的哦。</p>
<p>当然，Lambda经常作为函数参数使用。</p>
<ul>
<li>如果一个Lambda是一个函数的最后一个参数，Kotlin为这种情况专门提供了一个语法糖。</li>
<li>Lambda在作为匿名变量传递给函数时，不需要显式声明参数类型（因为可以根据函数参数那里的类型签名推导）。</li>
</ul>
<p>上面两句话如何理解呢？比如你有一个自定义UI控件：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinButton</span> : <span class="type">View</span></span>() &#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(block: (<span class="type">View</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">    <span class="comment">// set</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后调用的时候就可以使用这个语法糖了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(save: <span class="type">Bundle</span>?)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> a = KotlinButton()</div><div class="line">    <span class="comment">// 原本是：</span></div><div class="line">    <span class="comment">// a.setOnClickListener(&#123; view -&gt;</span></div><div class="line">    <span class="comment">//   toast("Clicked")</span></div><div class="line">    <span class="comment">// &#125;)</span></div><div class="line">    <span class="comment">// 语法糖省去了表示参数的括号，直接写Lambda</span></div><div class="line">    a.setOnClickListener &#123; view -&gt;</div><div class="line">    <span class="comment">// 编译器的类型推导省去了 view: View 的类型声明</span></div><div class="line">      toast(<span class="string">"Clicked"</span>)</div><div class="line">      view.text = <span class="string">"Oh my god"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面那段代码是Android的，熟悉的API看出来了吗？</p>
<p>你甚至还可以把那个view参数的声明给省了，因为只有一个参数，可以使用it代替：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  a.setOnClickListener &#123;</div><div class="line">    toast(<span class="string">"Hia hia"</span>)</div><div class="line">    it.text = <span class="string">"clicked"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个函数不只是有一个参数，但是最后一个参数（依然符合条件），那么可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  a.callSomeMethods(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &#123;</div><div class="line">    <span class="comment">// do something</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它完全等价于：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    a.callSomeMethods(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;</div><div class="line">      <span class="comment">// do something else</span></div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你不需要用到那个参数，又不想为它命名，那么使用下划线代替它吧。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  a.setOnClickListener &#123; _ -&gt;</div><div class="line">    toast(<span class="string">"LOL LOL LOL"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时你可能会问：上面那个代码完全可以把整个<code>_ -&gt;</code>给省掉啊？不是说单参数可以省吗？</p>
<p>因为多参数是不能省的（多参数Lambda不写参数会报错），所以它还是很有用的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).forEachIndexed &#123; _, _ -&gt;</div><div class="line">    println(<span class="string">"Looping!"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后说的这个下划线的特性是Kotlin1.1才引入的。</p>
<p><strong>请读者注意不要混淆上面的两个“多参数”，第一处说的是函数多参数，第二处说的是Lambda多参数。</strong></p>
<p>我们可以通过Lambda表达式来勉强地实现函数的<a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="external">柯里化</a>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(a: <span class="type">Int</span>)</span></span> = &#123; b: <span class="built_in">Int</span> -&gt; a + b &#125;</div></pre></td></tr></table></figure>
<p>调用就可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  println(plus(<span class="number">233</span>)(<span class="number">666</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这有什么用呢？可以实现一个函数的<a href="https://en.wikipedia.org/wiki/Partial_application" target="_blank" rel="external">部分应用</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> a = plus(<span class="number">233</span>)</div><div class="line">  <span class="comment">// 然后呱啦呱啦呱啦一堆东西</span></div><div class="line">  <span class="keyword">val</span> pluser2 = getIntFromSomewhere()</div><div class="line">  println(a(pluser2))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和泛型结合之后可以泛化出上面那个函数的抽象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B, C&gt;</span> <span class="params">((a: <span class="type">A</span>, b: <span class="type">B</span>)</span></span> -&gt; C).curry() =</div><div class="line">    &#123; a: A -&gt; &#123; b: B -&gt; invoke(a, b) &#125; &#125;</div></pre></td></tr></table></figure>
<p>plus就可以这样被抽象出来：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> plusOrigin = &#123; a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span> -&gt;</div><div class="line">    a + b</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">val</span> a = plusOrigin.curry()</div><div class="line">  a(<span class="number">233</span>)(<span class="number">666</span>) <span class="comment">// 和上面那个就是一样的了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还可以做出多参数的柯里化的抽象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B, C, D, E, F, G&gt;</span></span></div><div class="line"> ((a: A, b: B, c: C, d: D, e: E, f: F) -&gt; G).curry() =</div><div class="line">     &#123; a: A -&gt; &#123; b: B -&gt; &#123; c: C -&gt; &#123; d: D -&gt; &#123; e: E -&gt;</div><div class="line">     &#123; f: F -&gt; invoke(a, b, c, d, e, f) &#125; &#125; &#125; &#125; &#125; &#125;</div></pre></td></tr></table></figure>
<p>这样的抽象可以用于更多参数的函数的柯里化：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> makeString = &#123; a: <span class="built_in">Int</span>,</div><div class="line">                     b: <span class="built_in">Short</span>,</div><div class="line">                     c: String,</div><div class="line">                     d: File,</div><div class="line">                     e: URL,</div><div class="line">                     f: <span class="built_in">Double</span> -&gt;</div><div class="line">    <span class="string">"<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span> <span class="subst">$d</span> <span class="subst">$e</span> <span class="subst">$f</span>"</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">val</span> a = makeString.curry()</div><div class="line">  <span class="comment">// 调用方法一</span></div><div class="line">  a(<span class="number">233</span>)(<span class="number">666</span>)(<span class="string">"Gensokyo"</span>)(File(<span class="string">"./README.md"</span>))(URL(</div><div class="line">  <span class="string">"https://github.com/ice1000"</span>))(<span class="number">1.0</span>)</div><div class="line">  <span class="comment">// 调用方法二</span></div><div class="line">  a(<span class="number">233</span>)</div><div class="line">      .invoke(<span class="number">666</span>)</div><div class="line">      .invoke(<span class="string">"Gensokyo"</span>)</div><div class="line">      .invoke(File(<span class="string">"./README.md"</span>))</div><div class="line">      .invoke(URL(<span class="string">"https://github.com/ice1000"</span>))</div><div class="line">      .invoke(<span class="number">1.0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是这样。</p>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>函数调用写法和Java几乎完全一样，比如调用上面声明的几个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  functionWithGenericsParam(<span class="number">233</span>)</div><div class="line">  functionReturnsNothing()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>已经说过了Lambda的invoke写法所以这里不再提及。</p>
<p>当你需要调用一个接收了“有返回值的Lambda”的函数时，这样的写法是会报错的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  function &#123;</div><div class="line">    println(<span class="string">"Hi there!"</span>)</div><div class="line">    <span class="comment">// 下面这句会报错！</span></div><div class="line">    <span class="comment">// return 233</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为这样的return语句在被inline之后，编译器不知道你是要return掉main函数还是这个Lambda。</p>
<p>因此你需要显式声明return的作用域：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  function &#123;</div><div class="line">    println(<span class="string">"Hi there!"</span>)</div><div class="line">    <span class="keyword">return</span><span class="symbol">@function</span> <span class="number">233</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这叫做“Label return”，其中<code>return@</code>后面的标签（Label）是你要return的Lambda所传递给的函数名（比如上面就是function）。</p>
<p>如果你的函数名是kotlinIsAwesome，那么你就需要这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  kotlinIsAwesome &#123;</div><div class="line">    <span class="keyword">return</span><span class="symbol">@kotlinIsAwesome</span> <span class="number">233</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你使用IntelliJ IDEA，它会告诉你你需要写什么标签。</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>顾名思义，就是把函数体给内联到调用处。这对程序的逻辑是没有影响的，只是对一些无关逻辑的因素有影响，比如：</p>
<ul>
<li>运行效率</li>
<li>目标文件体积</li>
<li>重构上的优越性</li>
</ul>
<p>等等。</p>
<p>比如标准库的一堆函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Prints the given message to the standard output stream. */</span></div><div class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</div><div class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(message: <span class="type">Any</span>?)</span></span> &#123;</div><div class="line">    System.<span class="keyword">out</span>.print(message)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内联函数最好的好处就是直接内联Lambda，不产生匿名内部类对象。这是一个非常黑的黑科技，<br>减少Lambda对象的数量可以既保证函数式的优美代码，又不必为Lambda对象的开销买单。</p>
<p>如果一个内联函数没有内联到Lambda表达式，那么Kotlin编译器会给出一个警告——<br>因为inline本身就只是为了inline掉Lambda而准备的特性，标准库会有一些专门用于内联的函数（后面会讲到）。<br>inline一些无关紧要的函数反而会导致无谓的体积增加（JVM本身就会在运行时内联不少函数）。</p>
<p>Kotlin-discussion曾经出现过一个帖子，楼主说他太喜欢inline这个功能了，<br>以至于把大量的大型函数inline的到处都是，最后导致了jar体积的肥大。</p>
<h3 id="crossinline与noinline"><a href="#crossinline与noinline" class="headerlink" title="crossinline与noinline"></a>crossinline与noinline</h3><p>crossinline是一种比普通inline更高级的inline方法，它只能修饰Lambda参数，<br>用于处理一些奇怪的Lambda的内部return（有时你只是想return掉Lambda，但是内联后会导致return掉外部context）。</p>
<p>Kotlin编译器使用了一些奇怪的方法来复用内联Lambda产生的参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">crossInlineFunction</span><span class="params">(<span class="keyword">crossinline</span> f: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  f.invoke()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>noinline也只能用于修饰Lambda参数，表示在内联这个函数的情况下，不对这个Lambda进行内联优化<br>（即：依然针对Lambda产生一个匿名内部类对象，开销和Java的就一样了。<br>有些情况编译器无法内联这个Lambda，只能提示你加上noinline。这里不再展开讲解）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">noInlineFunction</span><span class="params">(<span class="keyword">noinline</span> f: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  f.invoke()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，请读者尽可能遵循标准规定：仅对接收Lambda的函数使用内联。</p>
<h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>扩展可谓是Kotlin的“killer feature”，它只是一个语法糖，却是一个（有时）难以理解的语法糖，一般黑带Kotlin程序员会谨慎并大量地使用它。</p>
<p>在IDE的帮助下，扩展对原库的污染已经不再是污染，因为扩展和原方法会被高亮给清晰地区分开。</p>
<p>下文中，有时会把扩展函数称为扩展方法，指的实际上是同一个概念。</p>
<h3 id="普通的扩展函数"><a href="#普通的扩展函数" class="headerlink" title="普通的扩展函数"></a>普通的扩展函数</h3><p>说了这么多，扩展到底是什么呢？</p>
<blockquote>
<p>就是使用一些语法糖来假装给一些类添加方法，并像真正的方法一样调用它。</p>
</blockquote>
<p>为什么要“假装给类添加方法”呢？</p>
<blockquote>
<p>你有种给java.io.File类添加一个openOrCreate方法啊？</p>
</blockquote>
<p>（以上调侃并不适用于rt.jar开发人员）</p>
<p>你可能还是不能理解这是什么，那么看看下面的例子吧：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> ls = java.util.ArrayList&lt;<span class="built_in">Int</span>&gt;()</div><div class="line">  ls.add(<span class="number">233</span>)</div><div class="line">  ls.add(<span class="number">666</span>)</div><div class="line">  ls.add(<span class="number">555</span>)</div><div class="line">  ls.add(<span class="number">1024</span>)</div><div class="line">  <span class="keyword">val</span> sum = ls.fold(<span class="number">0</span>) &#123; sum, value -&gt;</div><div class="line">    sum + value</div><div class="line">  &#125;</div><div class="line">  println(sum)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码使用Kotlin1.1第一个正式版编译器编译通过。在JRE1.8_101上完美运行。</p>
<p>你肯定知道，java.util.ArrayList是没有fold这个方法的。</p>
<p>那上面的代码是怎么回事？为什么我可以在ls对象上调用一个它本来没有的方法呢？</p>
<p>这完全符合刚才的定义：</p>
<blockquote>
<p>像真正的方法一样调用它。</p>
</blockquote>
<p>那么我们来看看这个方法怎么实现吧。这里不使用集合框架，而是使用另一个例子：给File类增加一个openOrCreate方法。</p>
<p>首先，我们可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">openOrCreate</span><span class="params">(file: <span class="type">java</span>.<span class="type">io</span>.<span class="type">File</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> (!file.exists()) file.createNewFile()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后这样调用它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  openOrCreate(File(<span class="string">"./save.txt"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果我们希望一种更优美的方式，我们可以使用这个语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">openOrCreate</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> (!exists()) createNewFile()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>卧槽！那个<code>if (!exists())</code>看起来就像是直接写在File类内部的方法一样啊！</p>
<p>其实这里是个小小的trick，编译器会这样处理它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">openOrCreate</span><span class="params">(receiver: <span class="type">File</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> (!receiver.exists()) receiver.createNewFile()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，如果将<code>fun openOrCreate(receiver: File)</code>写成<code>fun File.openOrCreate()</code>，<br>那么这个函数可以直接调用File类的方法，就像它自己也是一个File类的方法一样。编译过后它会被处理为对receiver的方法调用。</p>
<p>也就是说，这种扩展方法是不能调用private、protected以及internal的属性/方法的（因为它事实上就是一个普普通通的函数罢了）。</p>
<p>我们来看看它的调用吧：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> file = File(<span class="string">"./save.png"</span>)</div><div class="line">  file.openOrCreate()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是很有趣啊？</p>
<p>而且，在意识到了这只是一个普通方法后，你可能会问：能不能将它当成普通函数而不是方法运行呢？</p>
<p>当然。。。。。不可以：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> file = File(<span class="string">"./save.png"</span>)</div><div class="line">  openOrCreate(file) <span class="comment">// error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，你也可以在一个类里面对另一个类进行扩展：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(<span class="keyword">val</span> int: <span class="built_in">Int</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> A.<span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line">    println(int)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">anotherFunction</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> a = A()</div><div class="line">    a.someFunction()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这也是合法的。</p>
<p>在一个扩展函数内部，this所指向的就是receiver。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">openOrCreate</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.exists()) <span class="keyword">this</span>.createNewFile()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读者可以通过在扩展函数内部调用<code>println(this)</code>来验证。</p>
<h3 id="扩展Lambda"><a href="#扩展Lambda" class="headerlink" title="扩展Lambda"></a>扩展Lambda</h3><p>其实扩展还有一种用途，就是使一个Lambda成为“扩展Lambda”：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> extensionLambda = <span class="built_in">Int</span>.&#123; println(<span class="keyword">this</span>) &#125;</div><div class="line">  <span class="number">233.</span>extensionLambda() <span class="comment">// OK</span></div><div class="line">  extensionLambda(<span class="number">233</span>) <span class="comment">// OK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到了吗？Lambda表达式也可以被理解为是“对一个类进行扩展的Lambda”表达式。<br>也就是说，它也可以像扩展方法一样，从内部拿到一个特定的this，然后将它作为一个扩展使用。</p>
<p>扩展Lambda也可以作为一个函数的参数。</p>
<p>不同于扩展函数，扩展Lambda可以被当作一个非扩展Lambda。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">applyToFile</span><span class="params">(block: <span class="type">File</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  <span class="keyword">val</span> file = File()</div><div class="line">  file.block() <span class="comment">// OK</span></div><div class="line">  block(file) <span class="comment">// OK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么写，没人拦着你，我不会拦着你，编译器也不会拦着你。这个代码和上面的代码都是合法的Kotlin代码。</p>
<p>注意，以上代码仅为演示语法，是没有实际意义的。</p>
<p>我们还可以结合扩展函数和扩展Lambda：将一个扩展Lambda作为一个扩展函数的参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">run</span><span class="params">(block: <span class="type">File</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  <span class="keyword">this</span>.block() <span class="comment">// OK</span></div><div class="line">  block(<span class="keyword">this</span>) <span class="comment">// OK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>this一般可以省略，所以有：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">run</span><span class="params">(block: <span class="type">File</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  block()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还可以结合Kotlin的“expression body”：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">run</span><span class="params">(block: <span class="type">File</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) = block()</div></pre></td></tr></table></figure>
<p>在调用的时候，可以再结合一下Kotlin的Lambda参数语法糖：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> file = File(<span class="string">"./save.log"</span>)</div><div class="line">  file.run &#123;</div><div class="line">    <span class="keyword">if</span> (!exists()) createNewFile()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这相当于是给File类提供了一个run的工具函数，它可以把一个Lambda应用到file对象。</p>
<p>请读者确保自己能读懂以上代码，它用到了很多Kotlin的（比较）高级的特性：</p>
<ul>
<li>扩展函数</li>
<li>扩展Lambda</li>
<li>Lambda作为最后一个参数的简化写法</li>
</ul>
<p>到这里就结束了吗？</p>
<p>不，你可能已经相到了另一个JVM支持的特性，它和扩展结合起来能做到更优美。</p>
<p>还记得吗？这是JVM很早就引入的一个特性。</p>
<p><strong>泛型</strong>。</p>
<h3 id="泛型扩展"><a href="#泛型扩展" class="headerlink" title="泛型扩展"></a>泛型扩展</h3><p>首先考虑如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runWith</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  receiver.block()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数用泛型抽象了一个“runWith”的概念，也就是说传入一个对象和一个扩展给该对象的类型的Lambda，然后在这个对象上调用这个Lambda：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> file = File(<span class="string">"./save.svg"</span>)</div><div class="line">  runWith(file) &#123;</div><div class="line">    <span class="keyword">if</span> (!exists()) createNewFile()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> int = <span class="number">233</span></div><div class="line">  runWith(int) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> &lt;= <span class="number">100</span>) println(<span class="string">"smaller than 100, or equaled."</span>)</div><div class="line">    <span class="keyword">else</span> println(<span class="string">"bigger than 100."</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再结合扩展：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  block() <span class="comment">// OK</span></div><div class="line">  <span class="keyword">this</span>.block() <span class="comment">// OK</span></div><div class="line">  block(<span class="keyword">this</span>) <span class="comment">// OK</span></div><div class="line">  block.invoke(<span class="keyword">this</span>) <span class="comment">// OK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面展示了四种截然不同但是完全等价的调用block的方法，读者在抄代码的时候请只保留一个。</p>
<p>这个run变得更玄学了，可以直接在任意类型的任意对象上调用run方法了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  Random().nextInt(<span class="number">200</span>).run &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> &lt;= <span class="number">100</span>) println(<span class="string">"smaller than 100, or equaled."</span>)</div><div class="line">    <span class="keyword">else</span> println(<span class="string">"bigger than 100."</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还记得吗？接收Lambda对象的函数是被建议写为inline的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  block()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样省去了Lambda传递的开销，和朴素写法就<strong>完全</strong>等价了。</p>
<p>所以亲爱的读者，还记得之前提到的集合框架多出来的fold方法吗？这是内置在Kotlin标准库的扩展函数。</p>
<p>Kotlin的标准库，基本由扩展函数组成。它通过扩展，结合Java标准库本身已经有的一个非常强大的集合框架，<br>通过打包后仅仅700kb的jar作为标准库，却非比寻常的强大。</p>
<p>我们来看看其它JVM语言的做法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">语言</th>
<th style="text-align:right">做法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Java</td>
<td style="text-align:right">做的再烂也是所有JVM语言的爸爸，想打我的人多了去了你算老几</td>
</tr>
<tr>
<td style="text-align:left">Scala</td>
<td style="text-align:right">自己从头造了一个集合框架，通过隐式转换实现和Java标准库的集合框架的无缝衔接，但是开销比较大，不仅仅是运行开销，还有debug开销</td>
</tr>
<tr>
<td style="text-align:left">Clojure</td>
<td style="text-align:right">自己造了一个Lisp风格的集合框架（序列框架），Lisp的语法自带扩展效果</td>
</tr>
<tr>
<td style="text-align:left">Groovy</td>
<td style="text-align:right">相当于是从rt.jar里面抄了一些代码改成Groovy风格的形式，和Java没有互操作</td>
</tr>
<tr>
<td style="text-align:left">JRuby/Mirah</td>
<td style="text-align:right">不存在交互问题，因为这两门语言本身就不适合用于上面几门语言的领域（其实也没有交互）</td>
</tr>
</tbody>
</table>
<p>相比之下，Kotlin这种做法是非常友善的（inline零开销，完美利用rt.jar，而且可以随心所欲地扩展）。</p>
<h3 id="关于扩展是否会污染原库的讨论"><a href="#关于扩展是否会污染原库的讨论" class="headerlink" title="关于扩展是否会污染原库的讨论"></a>关于扩展是否会污染原库的讨论</h3><p>曾经Kotlin社区有人询问过关于扩展函数是否会污染原库的问题。</p>
<p>JetBrains显然考虑到了这点，他们通过IDE插件将两种方法高亮成了不同颜色，完美区分了普通方法和扩展方法：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://coding.net/u/ice1000/p/Images/git/raw/master/blog-img/3/1.PNG" alt="ide" title="">
                </div>
                <div class="image-caption">ide</div>
            </figure>
<p>如果你是IntelliJ IDEA用户，那么应该早就注意到这一点了。</p>
<p>缺省设置是黄色，可以在这里调整：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://coding.net/u/ice1000/p/Images/git/raw/master/blog-img/3/2.PNG" alt="settings" title="">
                </div>
                <div class="image-caption">settings</div>
            </figure>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-05-22T02:30:56.906Z" itemprop="dateUpdated">2017年5月22日 10:30</time>
</span><br>


        
        转载请注明出处：<a href="http://ice1000.org/2017/03/09/KotlinPrimerFunction/ " target="_blank" rel="external">http://ice1000.org/2017/03/09/KotlinPrimerFunction/</a>
        
    </div>
    <footer>
        <div>
            <a href="/authors/千里冰封/">
                
                <img src="/assets/img/Kotlin-logo.png" alt="Kotlin">
                
                千里冰封
                
            </a>
            
        </div>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/&title=《Kotlin Primer草稿 函数》 — Kotlin&pic=https://enbandari.github.io/assets/img/Kotlin-logo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/&title=《Kotlin Primer草稿 函数》 — Kotlin&source=Kotlin 是一门由 JetBrains 公司开发的运行在 JVM、Android、前端的静态语言，它 100% 兼容 Java，并且开始逐步支持 Na..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Kotlin Primer草稿 函数》 — Kotlin&url=https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/&via=https://enbandari.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/04/10/Kotlin Native：本周又搞了个大事情/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Kotlin Native：本周又搞了个大事情</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/04/06/Kotlin 1.1 Event Report/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">[译]Kotlin 1.1 Event Report</h4>
      </a>
    </div>
  
</nav>



    










<div class="comments" id="comments">
<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
</div>
<script>
    var cloudTieConfig = {
        url: document.location.href,
        sourceId: "",
        productKey: "0263eabe3b1b46709556eda1c39750be",
        target: "cloud-tie-wrapper"
    };
</script>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>




</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            <span>博客内容遵循 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p>
            <span class="copyright-text">京ICP备16022265号-2&nbsp;</span>
            <span>Kotlin &copy; 2017</span>
        </p>
        <p>
            本站由<a style="display:inline" href="https://account.ucloud.cn/cas/register?utm_source=kotliner&utm_medium=content_pic_pc&utm_campaign=zanzhu&ytag=kotliner">UCloud 提供赞助 - 注册即送 50 元代金券</a>
        </p>
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/&title=《Kotlin Primer草稿 函数》 — Kotlin&pic=https://enbandari.github.io/assets/img/Kotlin-logo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/&title=《Kotlin Primer草稿 函数》 — Kotlin&source=Kotlin 是一门由 JetBrains 公司开发的运行在 JVM、Android、前端的静态语言，它 100% 兼容 Java，并且开始逐步支持 Na..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Kotlin Primer草稿 函数》 — Kotlin&url=https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/&via=https://enbandari.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://enbandari.github.io/2017/04/07/KotlinPrimerFunction/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACG0lEQVR42u3aS47CMBAFQO5/aeYEZN5rB6TYlVWEkOPyouX+vF7x8w6e6/9fr/npl5sfDAyMxzKSzV3/vo6/fk8ODgMD4wTGp00k210Pzdch+HpvGBgYGCtBcHbtw8DAwPgGow2XSbDGwMDAmCWxydKzsJsnzzfk4hgYGA9k5KHw9+9f6W9gYGA8ivEun3a1tnkw3BUGBsbWjDzAJWMT+eWvTlCT/WBgYGzKWBnqyktybVHvOg0uzhgDA2M7Rvvh9hI5O7LomDAwMA5grJT720ZC0vhsr4kYGBinMfIUtA2+7cVxOC2CgYGxKaNd7jdNgjwoY2Bg7M243mheIEvWmW2xOGIMDIxNGW3AvStNXbl6Ri1MDAyMAxjtdbANrG1zNJoWwcDA2JSRYFYaA1HyGYfdYdENAwNjI0Z+4VvZbr5mPUCGgYGxKaMNrG1Z7bZxirYLgYGBsRGjbVuuNy9nTYWoVYCBgbE1465ifVvCi+6t7cAHBgbGpoxZsKvPKU5ihzwMDIwDGHkp7a739itR1RADA+MYxqz0Nmt85kW3fxJpDAyMTRnv8skHttb/X1AxMDC2Zsyane2YRXso7fAHBgbGCYw2yOZjE7Mzaw8IAwPjHEZSxM9bArPy2RISAwMDY1Qaazc0G7zAwMDAyIckkvGv9aGKmwMuBgbGoxht+GsLbUkgbktvGBgY5zDy1LEN0G3Ibr+OgYFxAOMPEFtqmJQKhQ4AAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };



lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1261686164&web_id=1261686164')

</script>

<script src="/js/main.min.js?v=1.5.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.5.2" async></script>





<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'Kotlin 博客';
            clearTimeout(titleTime);
        } else {
            document.title = 'Kotlin 博客';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



</body>
</html>
