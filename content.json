{"meta":{"title":"Kotlin","subtitle":"简洁、优雅，100% 兼容 Java","description":"Kotlin 是一门由 JetBrains 公司开发的运行在 JVM、Android、前端的静态语言，它 100% 兼容 Java，并且开始逐步支持 Native 编译。","author":"Kotlin","url":"http://www.Kotliner.cn"},"posts":[{"title":"Kotlin：forEach也能break和continue","slug":"KotlinForEachBreakContinue","date":"2017-05-22T02:30:56.906Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/05/22/KotlinForEachBreakContinue/","link":"","permalink":"http://www.Kotliner.cn/2017/05/22/KotlinForEachBreakContinue/","excerpt":"","text":"昨天在BennyHuo的Kotlin裙里看到有人在讨论关于 如何在forEach中跳出循环 这样的问题。也就是说，他们想用forEach而不是for循环，因为这很fp，很洋气（我也喜欢），但是他们又想使用break和continue，也就是普通的流程控制语句中的控制语句。 这很不fp，因为原本有filter是用于完成这个工作的，还有flapMap。BennyHuo在他发的文章里面也说的是这种方法。 filter很fp，但是会导致两次遍历，这样的话给人一股效率很低的赶脚。而Java8的Stream API就只会遍历一次，而且很fp。但是它会有lambda对象的产生而且实现超复杂（我没看过，不清楚），而Kotlin的集合框架可是能inline掉lambda的，少产生了多少对象啊，怎么能和辣鸡Java同流合污呢？ 有人提到使用label return，比如： 123456fun main(ags: Array&lt;String&gt;) &#123; (0..100).forEach &#123; if (50 &lt;= it) return@forEach println(it) &#125;&#125; 但是他做了实验之后发现这玩意只能相当于continue，也就是说你只能跳出当前循环，然后还是会继续下一轮。 讲道理这个你仔细想想就可以发现。为了搞清楚其中的道理，我们自己实现一个forEach。 123fun Pair&lt;Int, Int&gt;.forEach(block: (Int) -&gt; Unit) &#123; for (i in first..second) block.invoke(i)&#125; 然后调用一下： 1Pair(1, 100).forEach(::println) 没毛病老铁。 然后你会发现，你在函数体内对block产生了(second - first)次调用，不论你怎么return，都只会跳出这个block，它并不影响你之后继续调用这个block，也就是说这个for循环不受block行为的影响。 看起来无解了，那怎么办呢？ 那么就让我来拯救你们吧。 12345678fun main(ags: Array&lt;String&gt;) &#123; run outside@ &#123; (0..20).forEach inside@ &#123; if (10 &lt;= it) return@outside println(it) &#125; &#125;&#125; 编译之后运行结果： 1234567891011120123456789Process finished with exit code 0 呐，跳出去了。 把label的名字起的清真一点，就是这样： 123456run breaking@ &#123; (0..20).forEach continuing@ &#123; if (10 &lt;= it) return@breaking println(it) &#125;&#125; 上面这是break，运行结果就上面那样。 下面这是continue，运行结果就是continue的效果。为了让效果表现的明显，我把println复制了一下，分别在if前后，这样可以很清楚地看到效果。 1234567run breaking@ &#123; (0..20).forEach continuing@ &#123; print(it) if (10 &lt;= it) return@continuing println(it) &#125;&#125; 运行一下： 123456789101112001122334455667788991011121314151617181920Process finished with exit code 0 而且只进行了一次迭代，非常清真，效率看起来也比较高。 如何证明只有一次迭代？我使用jd-gui逆向了刚才的代码，结果： 1234567891011121314151617181920public final class _5Kt&#123; public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, \"args\"); int $i$a$1$run; Iterable $receiver$iv = (Iterable)new IntRange(0, 20); int $i$f$forEach; for (Iterator localIterator = $receiver$iv.iterator(); localIterator.hasNext();) &#123; int element$iv = ((IntIterator)localIterator).nextInt();int it = element$iv; int $i$a$1$forEach; System.out.print(it); if (10 &lt;= it) &#123; break; &#125; System.out.println(it); &#125; &#125;&#125; 确实只有一次，而且jd-gui直接把我的行为反编译为break了。服不服？ 无fuck说","raw":null,"content":null,"categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://www.Kotliner.cn/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://www.Kotliner.cn/tags/Kotlin/"}]},{"title":"成都 Kotlin 线下聚会报告及科技汇总","slug":"2017-5-13-KotlinMeetupChengDu","date":"2017-05-22T02:30:56.890Z","updated":"2017-05-22T02:30:56.890Z","comments":true,"path":"2017/05/22/2017-5-13-KotlinMeetupChengDu/","link":"","permalink":"http://www.Kotliner.cn/2017/05/22/2017-5-13-KotlinMeetupChengDu/","excerpt":"","text":"上星期我组织了成都的一次主题为 Kotlin 的线下聚会（也可以说是沙龙），来的人不到十个，却代表了三代人啊。 为何线下聚会不知道 活动内容早上 9:30 ~ 10:00 基本把成员接到。 上午大概的内容： 千里冰封聊 Kotlin DSL 的原理 CharlieJiang 聊 Kotlin JNI 调用 CharlieJiang 介绍项目 Laplacian ， JVM 音乐播放器内核 清水河学渣介绍 Kotlin Web 开发 清水河学渣介绍自己写的 IntelliJ 高亮插件 MultiHighlight 大家一起讨论 Kotlin 的花样玩法。 然后午饭就在旁边一破地方吃的，优格还说他来过这地方（汗），吃到一半，迎风尿，腿不抖被公司召唤而去。members.size.dec()。 下午，优格拿出了他的任天堂 switch，然后一发而不可收拾。。 清水河学渣暴露身份，实际上是清水河学神。 有个挤牛奶的游戏，玩起来动作很像撸管 最年轻的查理江同学全程打守望先锋 大家都笑得像个孩子 这次聚会我反正学到了新东西，很开心。希望别人也如此。 这里总结一下我觉得值得一提的聚会中聊到的科技。这两天我又有新发现，下次活动说。 黑科技汇总假构造方法模拟 Factory（by 清水河学渣） 重载 companion object 的操作符模仿构造方法，还能做到完全模拟 Factory ： 12345678910111213141516171819202122232425262728/** * 直线，使用解析式表示 * ax + by + c = 0 */class Line(val a: Int, val b: Int, val c: Int) &#123;// constructor(point1: Pair&lt;Int, Int&gt;, point2: Pair&lt;Int, Int&gt;) : this()// 上面这样写，通过两点计算 a b c 表达式会很复杂，可读性并不好（虽然我不觉得）// 但是你必须在第一时间调用 primary constructor ，在此之前不能进行// 任何变量声明或者流程控制// 怎么办呢 companion object Factory &#123; // 于是可以通过这个解决 // 这个求 a b c 的写法其实并不优雅，只是为了展示例子 // 这个方法调用起来和构造方法语法完全相同 // 但是这样写，可以在调用构造方法之前进行一些流程控制或者变量声明 operator fun invoke(one: Pair&lt;Int, Int&gt;, two: Pair&lt;Int, Int&gt;): Line &#123; val a = two.second - one.second val b = one.first - two.first val c = two.first * one.second - one.first * two.second return Line(a, b, c) &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val a = Line(1, 1, 1) // 调用构造方法 val b = Line(Pair(1, 2), Pair(3, 4)) // 调用操作符重载&#125; 非常规函数的 JNI 声明（by CharlieJiang） 非常规函数的 JNI 声明，以及通过注解确保编译器不改名 比如 getter setter 以及改名的函数。 12345678class A &#123; var a: Int external get external set @JvmName(\"myNameIsVan\") external fun myNameIsVan()&#125; JvmMultifileClass（by 千里冰封） 将多个文件的内容编译到同一个类里面 文件 1： 123456// file 1.kt@file:JvmName(\"Fuck\")@file:JvmMultifileClassval shit = \"fuck\"val fuck = \"shit\" 文件 2： 1234567// file 2.kt@file:JvmName(\"Fuck\")@file:JvmMultifileClassfun GameObject.destroy() &#123; isAlive = true&#125; 编译之后只会生成一个类 ‘Fuck.class’ ，里面有 shit fuck destroy 三个成员。 模拟 Null safety（by 千里冰封） 代数数据类型模拟 Null safety 这是个函数式编程的概念，这里用了 when+is 模拟模式匹配。 这个我在讲的时候代码写错了，后来我想到了原因，是因为没加泛型的协变。 关于我当时举的例子（用 ADT 处理除法的除数为 0 的情况），正确的代码是这样的： 123456sealed class Option&lt;out T&gt;()class Some&lt;out T&gt;(val obj: T) : Option&lt;T&gt;()object None : Option&lt;Nothing&gt;()fun div(a: Int, b: Int) : Option&lt;Int&gt; = if (b == 0) None else Some(a / b) 调用： 12345678fun main(args: Array&lt;String&gt;) &#123; val io = Scanner(System.`in`) val res = div(io.nextInt(), io.nextInt()) println(when (res) &#123; is Some -&gt; println(\"result: $&#123;res.obj&#125;\") // smart cast is None -&gt; println(\"nothing here\") &#125;)&#125; 我觉得还行。 三代人两个 00 后，两个 80 后，三个 90 后，我感觉没有任何代沟，最后一起嗨起来。 也许这就是单纯吧.jpg 集体照随便 po 两张上来： 如果你有兴趣加入我们，请直接关注公众号 Kotlin ，并且加 QQ 群：162452394 联系我们。","raw":null,"content":null,"categories":[{"name":"线下活动","slug":"线下活动","permalink":"http://www.Kotliner.cn/categories/线下活动/"}],"tags":[{"name":"线下活动","slug":"线下活动","permalink":"http://www.Kotliner.cn/tags/线下活动/"}]},{"title":"Kotlin 一个很厉害的 DSL 写法","slug":"2017-5-11-KotlinDSL2","date":"2017-05-22T02:30:56.890Z","updated":"2017-05-22T02:30:56.890Z","comments":true,"path":"2017/05/22/2017-5-11-KotlinDSL2/","link":"","permalink":"http://www.Kotliner.cn/2017/05/22/2017-5-11-KotlinDSL2/","excerpt":"","text":"好久没写博客了，今天发几个最近在各个地方看到的一些碉堡了的 Kotlin DSL。本文先介绍一种 DSL 写法，再推荐几个 DSL 项目。 超厉害的 DSL之前在 KotlinTest 上看到一个很牛逼的写法（我把 README 里的实例改了下）： 1234567891011121314class StringSpecExample : StringSpec() &#123; init &#123; \"should add\" &#123; forAll(table( headers(\"a\", \"b\", \"result\"), row(1, 2, 3), row(1, 1, 2) )) &#123; a, b, result -&gt; a + b shouldBe result &#125; &#125; &#125;&#125; 这其中涉及了好几个 DSL 要素。我一一列举： 字符串后面跟一个代码块这个东西的原理你只要看了源码就知道了，很简单，但是你不看就是想不到（这也是我厨 Kotlin 的原因之一，它很简单，但是可以玩出很多花样来）。 12inline operator fun String.invoke(block: () -&gt; Unit) &#123;&#125; 就这样你可以利用这个 extension 写出字符串后面跟一个代码块的 DSL 。此处使用的语言特性有： extension （万 DSL 基于 extension） 操作符重载 最后一个参数是 Lambda ，不需要写调用的括号 明白了吧。 使用举个例子，把他作为一个 URL 的 utility ： 12345678910inline operator fun String.invoke(block: (URL) -&gt; Unit) &#123; block(URL(this))&#125;\"ice1000.org\" &#123; url -&gt; File(\"download.html\").run &#123; if (!exists()) createNewFile() writeText(url.readText()) &#125;&#125; 表格字面量就是形如 12345678val a = listOf( listOf(-1, 0, 1), listOf(0, 1), listOf(1), listOf(1, 2), listOf(1, 2, 3), listOf(1, 2, 3, 4)) 这样的东西（上面的代码纯粹搞起耍，请不要在意）。 这个就更简单了我觉得你们应该都知道： 1fun &lt;T&gt; listOf(vararg vars: T) = LinkedList(vars.size).apply &#123; addAll(*vars) &#125; 无非就是变长参数。 形如 &quot;(+ 1 1)&quot; shouldBe 2 的测试这个也很简单，我在小标题里写的就是我在 lice 里使用的测试。 首先，假定我们有以下测试： 123fun test() &#123; assertEquals(\"ass we can\", trie[\"key\"])&#125; 我们希望写成： 123fun test() &#123; trie[\"key\"] shouldBe \"ass we can\"&#125; 很简单，可以有： 1infix inline fun &lt;T&gt; T?.shouldBe(expected: T?) = assertEquals(expected, this) 就是一个中缀表达式而已。这有什么难的？ 一些特定情况我给我的 lice 写的测试中直接把运行字符串的那一步给包含进去了： 1infix inline fun Sting.shouldBe(expected: T?) = assertEquals(expected, Lice.run(this)) 看到没有，运行 lice 代码就是这么简单，还能返回最后一个表达式的值 （喂 注意事项任何长得类似这样的 DSL 都有一个缺点，就是缩进膨胀（字面意思）。 Scala 为了解决这个问题，推荐用户使用 Tab size 2 的缩进（喂。 于是我也建议读者使用 2 空格缩进。 几个厉害的 DSL 项目根据推荐程度排序： Anko传送门，不说了，最强的 Kotlin DSL 框架，想必大家早已有所耳闻： 1234567891011121314151617override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) verticalLayout &#123; padding = dip(30) editText &#123; hint = \"Name\" textSize = 24f &#125; editText &#123; hint = \"Password\" textSize = 24f &#125; button(\"Login\") &#123; textSize = 26f &#125; &#125;&#125; 厉害吧。这个框架是用于 Android 的，用于描述 UI 。有一点要说一下，现在的预览插件挂了。 弹窗： 1234alert(\"Hi, I'm Roy\", \"Have you tried turning it off and on again?\") &#123; yesButton &#123; toast(\"Oh…\") &#125; noButton &#123;&#125;&#125;.show() 还有一些非 UI 的吊炸天的代码块，比如异步： 123456doAsync &#123; // Long background task uiThread &#123; result.text = \"Done\" &#125;&#125; 两个基于 Swing 的 DSLGensokyo传送门，一个刚出来的项目，它长这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374fun main(args: Array&lt;String&gt;) &#123; systemLookAndFeel() frame (title = \"Test\", show = true) &#123; size(500, 500) exitOnClose menuBar &#123; subMenu(\"File\") &#123; item(\"Open\") &#123; listenAction &#123; println(\"BOOM!\" &#125; &#125; separator subMenu(\"Recent\") &#123; item(\"nanimo arimasen\") &#123; listenAction &#123; println(\"SHIT!\") &#125; &#125; &#125; separator item(\"Exit\") &#123; listenAction &#123; println(\"NOPE! SHIT!\") exitProcess(0) &#125; &#125; &#125; &#125; gridLayout &#123; row &#123; button(\"Hello!\") &#123; listenAction &#123; println(\"click!\") hide &#125; &#125; // gap &#125; row &#123; button(\"Another Hello!\") &#123; listenAction &#123; println(\"another click!\") hide &#125; &#125; // gap &#125; row &#123; container &#123; gridLayout &#123; row &#123; button(\"Oh Boy♂Next♂Door!\") &#123; listenAction&#123; println(\"Ahh fuck you\") hide &#125; &#125; button(\"change the boss of the gym!\") &#123; listenActionWithEvent &#123; source, _, _, _ -&gt; println(\"Ahh FA♂Q $source\") hide this@frame.hide &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; Swing 其实没那么垃圾，只要配上 DSL ，啥 GUI 代码都变得好看了。 FriceEngine DSL这是我之前弄的那个游戏引擎的 DSL 系统，传送门，它长这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859fun main(args: Array&lt;String&gt;) &#123; game &#123; bounds(500, 500, 800, 750) showFPS = false whenExit &#123; closeWindow() &#125; whenUpdate &#123; if (800.elapsed()) &#123; rectangle &#123; x = elapsed / 10.0 y = elapsed / 10.0 color = PINK &#125; &#125; &#125; every(1000) &#123; oval &#123; x = elapsed / 10.0 y = elapsed / 10.0 color = ORANGE &#125; log(\"1 second has past.\") &#125; rectangle &#123; name(\"rectangle\") x = 100.0 y = 100.0 width = 100.0 &#125; oval &#123; x = 0.0 y = 85.0 accelerate &#123; x = 10.0 &#125; whenColliding(\"rectangle\") &#123; stop() x -= 5 accelerate &#123; x = -2.0 y = 10.0 &#125; &#125; &#125; image &#123; file(\"C:/frice.png\") x = 200.0 y = 300.0 velocity &#123; x = -5.5 &#125; &#125; &#125;&#125; 我自己觉得做的还不错。我还为它搞了个中文版，比较粗鄙，用于讽刺中文编程，请前往同项目的 README 查看。 官方教程里的 HTML DSL传送门，它长这样： 123456789101112window.setInterval(&#123; val myDiv = document.create.div(\"panel\") &#123; p &#123; +\"Here is \" a(\"http://kotlinlang.org\") &#123; +\"official Kotlin site\" &#125; &#125; &#125; document.getElementById(\"container\")?.let &#123; it.appendChild(myDiv) it.append &#123; div &#123; +\"added it\" &#125; &#125; &#125;&#125;, 1000L) 这代码也是我从 README 里面改过的，原文太瘦了，我改的胖一点。 官方给的例子，非常给力（当时也是看这个的源码搞懂了 anko 的原理）。 JavaFX DSL传送门，它长这样： 123456789101112131415class MyView : View() &#123; private val persons = FXCollections.observableArrayList( Person(1, \"Samantha Stuart\", LocalDate.of(1981, 12, 4)), Person(2, \"Tom Marks\", LocalDate.of(2001, 1, 23)), Person(3, \"Stuart Gills\", LocalDate.of(1989, 5, 23)), Person(3, \"Nicole Williams\", LocalDate.of(1998, 8, 11)) ) override val root = tableview(persons) &#123; column(\"ID\", Person::id) column(\"Name\", Person::name) column(\"Birthday\", Person::birthday) column(\"Age\", Person::age) columnResizePolicy = SmartResize.POLICY &#125;&#125; 我个人觉得很不错了已经。 嘛。祝大家玩 Kotlin 开心。 如果你有兴趣加入我们，请直接关注公众号 Kotlin ，并且加 QQ 群：162452394 联系我们。","raw":null,"content":null,"categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://www.Kotliner.cn/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://www.Kotliner.cn/tags/Kotlin/"}]},{"title":"Google 力挺 Kotlin，这是怎么回事！","slug":"Kotlin-on-Android-Now-official","date":"2017-05-17T23:38:18.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/05/18/Kotlin-on-Android-Now-official/","link":"","permalink":"http://www.Kotliner.cn/2017/05/18/Kotlin-on-Android-Now-official/","excerpt":"","text":"困死梦中惊坐起，Google 力挺 Kotlin ！ 话说洒家梦中化身鲁肃，正准备跟孔明去草船借箭呢，突然好友微信发来则消息：Google 将 Kotlin 列为 Android 官方开发语言，据称 IO 大会上提到这一点的时候，下面的掌声如雷鸣般不绝于耳~ 艾玛，这掌声，台上讲话的确定不是毛爷爷？ 话说听到这一消息之后，群里的小伙伴们都炸了，嗯？这么多夜猫子！ 好啦，不说别的，就说说这一消息能给我们带来什么影响呢？ 不敢用 Kotlin？要知道，在 Google 大大在背后撑腰之前，我们在 Android 当中写 Kotlin 都算是野路子，没有人认可这事儿的，出了问题也还要自己负责，代码移交的时候也会带来一堆麻烦（毕竟大家大多数人不愿意学这个东西啊）。 现在好了，你就可以理直气壮的说，哇塞，Kotlin 是官方语言了，这么好的东西你们都不用，都不愿意去用，你们迟早要被遗忘在历史的车轮印里面的那个小缝缝里面！ 想用 Lambda？要说 Kotlin 最早用在写 Android 上，让人感觉最爽的就是可以任性的使用 Lambda，当然这在 Java 8 中也得到了支持（虽然还是支持得很诡异），于是 Google 就差人去折腾个 Jack&amp;Jill，折腾了两年，有一天有个人一进门就冲着 J&amp;J 的开发者们喊了一句 “Hi, Jack!”，于是这个项目就 Deprecated 了。嗯，Android 开发者们想用 Lambda 指望 Google 看来是要等到猴年马月了，而且按照之前的尿性，估计也得等到某个 api 版本才会支持，这就尴尬了。 谁能拯救你？当然是 Kotlin 啊！函数是头等公民的 Kotlin，支持函数式编程都毫无压力，Lambda 的体验更是不在话下，哎呀，不说了，我要去写 Kotlin 了~ 想用 Coroutine？最近在封装 Camera api。用过的小伙伴肯定都知道，Camera 有两套 api，老 api 基本是是同步调用的接口，只有拍照、对角这两个有回调；新 api 呢，所有的指令都类似于 http 请求一样异步发出去，回调呢，运行在我们发请求时传入的一个 Handler 所在的线程上，这样看来，回调恶魔的大戏就要上演了。 遇到这样的 api，我也很绝望啊。。 开发当中类似回调套回调的写法不在少数，我们该如何写出一段看上去是同步执行的代码，实际上却自己处理了异步请求呢？当然是 Coroutine 啊。 开发过 Unity 的朋友肯定会想到这个，去年有个同事去搞了一段时间游戏，对 Coroutine 的用法大为赞赏，它的主要优点有哪些呢？ 代码看上去直观，易懂 异常处理简单（一个 try … catch 就解决问题） 资源消耗少（比起你动不动就搞十个八个线程池来说，Coroutine 简直太经济啦） 好，最关键的是什么呢？这在 Kotlin 1.1 当中，Coroutine 已经非常完善了，尽管还被标记为 Experimental，但 Kotlin 1.2 的时候目测也不会有大改动，想想以后的 Android 代码还会有这样的东西，真的感觉世界都很美好呢！ 哎呀，咋又说这么多，我要去写 Kotlin 了！ WTFUtils每次都要提这个东西。你的代码里面一定一堆堆的 StringUtils/ImageUtils/BitmapUtils/LogUtils 这样的东西吧！ 更搞笑的是，每个人都有自己的 LogUtils，当然也不排除有些人用的是 LogUtil，结果呢，我在 as 当中 double-shift 输入 LogUti 之后出来一堆，天呐，你们让我选哪一个啊。。 曾经有一次组里面的 iOS 大哥做分享，叫“手把手教 Android 开发写 iOS”，里面特别提到了动态修改方法的特性，以及扩展方法的特性，艾玛，看得我眼馋的不要不要的，想着哪天我也可以给 String 加个什么 util 方法的，该多好。 后来遇到了 Kotlin，Android 的小伙伴们，来吧，删掉你的 XXUtils 或者 XXUtil 吧，让那些不堪回首的往事都随风而去吧。 空指针异常？听说你用 Java 写的 Android 代码经常出空指针异常啊？是不是辛辛苦苦大半月，一跑就挂千百遍？千百遍，还每次都是那个空指针，急得你直把眼泪掉，哎，这TM是什么破逻辑，模板代码数不尽，查着查着就懵逼。 Kotlin，安全类型来帮你，从此不怕空指针。 。。。 好人就做到这里，剩下的你们自己关注公众号 Kotlin 翻看以前的文章自己体会 ~ 哈哈，我去写 Kotlin 了，别拦着我。 如果你有兴趣加入我们，请直接关注公众号 Kotlin ，或者加 QQ 群：162452394 联系我们。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"Kotlin 官方参考文档翻译完毕","slug":"kotlin-reference-translated","date":"2017-05-17T03:13:15.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/05/17/kotlin-reference-translated/","link":"","permalink":"http://www.Kotliner.cn/2017/05/17/kotlin-reference-translated/","excerpt":"","text":"非常高兴跟大家宣布：Kotlin 官方文档的参考部分已翻译校对完毕、且与官网同步，这也是目前唯一完整且最新的官方参考文档翻译。 打开 Kotlin 语言中文站，点学习即是，或者直接打开这个链接：https://www.kotlincn.net/docs/reference/。为了便于离线阅读，还可以从 GitBook 项目 gitbook.com/book/hltj/kotlin-reference-chinese 下载对应电子书。今后官方文档有更新时，中文站和 GitBook 也会及时同步并更新翻译，关注 Kotlin 语言的同学请保持关注。 Kotlin 是什么？Kotlin 中文站首页（https://www.kotlincn.net/）已经用很醒目的字眼回答了这个问题。而我觉得这样介绍会更充分一些：Kotlin 是一门支持多范式、多平台的现代静态编程语言。Kotlin 支持面向对象、泛型与函数式等编程范式，它支持 JVM、Android、JavaScript 目标平台，而原生（Native）平台的 Kotlin 几天前也发布了 0.2 版本。而且 Kotlin 具有很多现代（也有称下一代的）静态语言特性：如类型推断、多范式支持、可空性表达、扩展函数、模式匹配等。因此上面描述毫不夸张，它是一门非常有潜力的新兴语言。 另外 100% 的 Java 互操作性，，使 Kotlin 能够与既有工具/框架如 Dagger、Spring、Vert.x 等集成，也能让既有的基于 Java 的服务端与 Android 项目逐步迁移到 Kotlin。详情参见Kotlin 用于服务器端与Kotlin 用于 Android。了解更多关于 Kotlin 的内容，请关注 Kotlin 中文站与 Kotlin 中文博客。 Kotlin 中文站针对 Kotlin 官方参考文档的翻译有很多支系，而只有 Kotlin 中文站 能够与官网及时同步且最终完成全部参考文档翻译。 这当然离不开创始人晓_晨DEV和我（灰蓝天际）以及所有参与翻译的同学的共同努力。我从 2016 年 2 月开始参与 Kotlin 中文站的翻译，Kotlin 1.0 就是那时正式发布的，时隔一年多又亲历了它 1.1 版的发布，见证它成长的同时，也在不断校对和补充官方参考文档的翻译。而晓_晨DEV更是在 2015 年就开了 Kotlin 中文站的翻译，并且组织带动社区参与者一起翻译。在 Kotlin 中文站版本库的贡献者统计图中可以看到晓_晨DEV与我分别提交了近 4000 行与近 6000 行的改动，已经同官方文档的撰写者一起排进了前十。 contributors.png 与官方站及时同步Kotlin 中文站之所以能够与官网内容同步，在于创始人晓_晨DEV采用了科学的翻译方式，其实也是开源界普遍采用的 fork-修改模式，只是 Kotlin 中文站直接 fork 了官方的英文源站。这样做的显著优势是官方站有任何更新可以及时合并进来。尽管这可能会引入冲突解决的环节，并且合并新的英文原版内容会降低翻译完整度。 2016 年 2 月当我评估各个翻译组潜力的时候，就发现了这个问题，当时虽然 Kotlin 中文站的完成度不是最高的，但是其他的翻译组都不具备与官网及时同步的能力，于是果断加入了 Kotlin 中文站翻译。 GitBook 避免重复工作Kotlin 网站最初是基于 Jekyll 的网站，目前是使用 Jinjia2 模版引擎的类 Jekyll 网站，并不能直接拿来制作 GitBook。为了能够方便提供 ePUB 版和 Moby 版电子书，我在 gitbook.com/book/hltj/kotlin-reference-chinese 项目中采用了引入语法，在 GitBook 项目中只维护目录、章节等基本结构，内容都是引用的 Kotlin 中文站版本库的，当然其中用了一些具体的技巧来处理不兼容问题。这样在避免重复工作的同时，也避免出现同步脱节的问题。 参与和改进后续 Koltin 中文站会继续翻译教程部分以及参考部分的更新内容。参与翻译请直接 fork github.com/hltj/kotlin-web-site-cn 并提 Pull Request 过来。 关于网站与 PDF 有任何问题请在这里反馈；关于 ePUB 与 Mobi 有任何问题请在这里反馈。 关于我多年互联网研发从业者。Kotlin 中文站维护人。欢迎关注 Github：https://github.com/hltj 微博：灰蓝天际","raw":null,"content":null,"categories":[{"name":"社区动态","slug":"社区动态","permalink":"http://www.Kotliner.cn/categories/社区动态/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://www.Kotliner.cn/tags/Kotlin/"},{"name":"中文","slug":"中文","permalink":"http://www.Kotliner.cn/tags/中文/"},{"name":"官网","slug":"官网","permalink":"http://www.Kotliner.cn/tags/官网/"}]},{"title":"成都线下活动成功举行，Kotliner 获得 Ucloud 赞助","slug":"Good-news-chengdu_meetup-ucloud_support","date":"2017-05-15T03:13:15.000Z","updated":"2017-05-22T02:30:56.890Z","comments":true,"path":"2017/05/15/Good-news-chengdu_meetup-ucloud_support/","link":"","permalink":"http://www.Kotliner.cn/2017/05/15/Good-news-chengdu_meetup-ucloud_support/","excerpt":"","text":"本文来自：www.kotliner.cn 下面是近期我们组织和参与的一些活动，希望 Kotlin 社区在国内站稳脚跟，发扬光大~ Kotliner 获得 Ucloud 赞助Ucloud 云计算的相关负责人在了解了我们的 Kotliner 网站之后决定赞助我们一台云服务器，简直不能更赞。Ucloud 还为我们的站点提供了注册优惠，大家可以阅读原文点击注册，注册立即赠送 50 元代金券~ 那么，我们终于可以将托管在 Github 以及 Coding.net 上面的静态站点迁到自己独立的服务器上面了，后续我们也将推出更多有价值的内容，帮助大家迅速了解和掌握 Kotlin，并切实享受到新时代不可阻挡的开发体验。 成都线下活动成功举行目前国内使用 Kotlin 的小伙伴们越来越多，在我们 Kotlin 的布道师千里冰封的组织下，成都的小伙伴们都按捺不住率先搞了一波线下聚会，这个事情对我们的触动也不小，北京地区也将在 6月初举办一次线下活动，有兴趣的同学可以加群联系我们。 线下活动 Kotlin 官方表示支持就在我们如火如荼的瞎折腾的时候，我们收到了官方的慰问邮件，他们表示要给我们寄文化衫过来(虽然有点儿远，但是我们可以等！)，北京地区和成都地区的链接也挂到了官网。 腾讯云近期举办 Kotlin 分享腾讯云将在近期举办 Kotlin 直播分享，届时主讲人将为大家带来自己在 Kotlin 方面的学习以及实战经历。具体分享的时间和参与形式我们将在微信公众号 Kotlin 中第一时间为大家推送，敬请关注。 如果你有兴趣加入我们，请直接关注公众号 Kotlin ，并且加 QQ 群：162452394 联系我们。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://www.Kotliner.cn/tags/Kotlin/"},{"name":"Native","slug":"Native","permalink":"http://www.Kotliner.cn/tags/Native/"}]},{"title":"[译]Kotlin/Native v0.2 is out","slug":"Kotlin_Native v0.2 is out","date":"2017-05-12T03:08:00.000Z","updated":"2017-05-22T01:47:46.391Z","comments":true,"path":"2017/05/12/Kotlin_Native v0.2 is out/","link":"","permalink":"http://www.Kotliner.cn/2017/05/12/Kotlin_Native v0.2 is out/","excerpt":"","text":"我们很高兴地宣布Kotlin / Native v0.2 发布啦，这是 Kotlin / Native 技术预览版的一次功能更新和 Bug 修复。这次更新增加了对协程和跨模块内联函数的支持，以及整体上的问题修复和优化。这次更新包括了一个演示如何使用 并发非阻塞IO协同程序 的示例， 一个 使用GTK的GUI应用程序 ，以及一个由Julius Kunze贡献的TensorFlow机器学习框架 客户端。 诸如下面的代码： 12345678910111213141516171819var connectionId = 0acceptClientsAndRun(listenFd) &#123; memScoped &#123; val bufferLength = 100L val buffer = allocArray&lt;ByteVar&gt;(bufferLength) val connectionIdString = \"#$&#123;++connectionId&#125;: \".cstr val connectionIdBytes = connectionIdString.getPointer(this) try &#123; while (true) &#123; val length = read(buffer, bufferLength) if (length == 0L) break write(connectionIdBytes, connectionIdString.size.toLong()) write(buffer, length) &#125; &#125; catch (e: IOException) &#123; println(\"I/O error occurred: $&#123;e.message&#125;\") &#125; &#125;&#125; 可用于使用协程处理并发 Socket IO，各个用户的请求将得到并发处理。 下面的这段代码则演示了如何创建一个带有事件监听的GTK按钮： 1234val button = gtk_button_new_with_label(\"Click me!\")!!g_signal_connect(button, \"clicked\", staticCFunction &#123; _: CPointer&lt;GtkWidget&gt;?, _: gpointer? -&gt; println(\"Hi from Kotlin\") &#125;) 简单地说，Kotlin Native v0.2 能够支持我们编写一些功能完善而精巧的程序了。 另外，Kotlin Native 编译和运行时性能均有明显改善，编译生成的可执行程序体积也进一步得到了缩减。 完整更新内容请参考 更新日志。 点击后面的链接即可下载 Linux 和 MacOS 版本的编译器。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"[译]Kotlin 1.1.2 is out","slug":"Kotlin 1.1.2 is out","date":"2017-04-25T13:19:00.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/04/25/Kotlin 1.1.2 is out/","link":"","permalink":"http://www.Kotliner.cn/2017/04/25/Kotlin 1.1.2 is out/","excerpt":"","text":"我们很高兴宣布Kotlin 1.1.2正式发布了，这也是Kotlin 1.1的第二次 Bug 修复和工具更新。此次更新不仅提升了编译器和 IntelliJ IDEA 插件的性能，同时也在工具中增加了新的特性，当然还有各方面的问题修复。 此外，Kotlin 1.1.2也提升了与Android Gradle插件版本2.4.0-alpha的兼容性。本次发布版本的所有更新可在更新日志中查看。在这里要感谢所有外部的贡献者，他们提交的pull request也包含于该版本中：Yoshinori Isogai，Jonathan Leitschuh和Kirill Rakhman 。感谢所有尝试EAP构建并向我们发送反馈意见的人！ 迁移说明Kotlin编译器现在也需要基于JDK 8运行。但您应该不需要在意这一点改变，因为大多数其他Java开发工具（比如Gradle和Android工具）也需要JDK 8，因此您肯定已经安装了JDK 8。对于由编译器生成的代码，仍然默认兼容Java 1.6，而且我们也没有计划要放弃对生成的Java 1.6兼容性字节码的支持。 内部类当中不能再声明 object，因为这个 object 将能够访问外部类的实例，我们知道 object 始终是一个单例，因此这在理论上是行不通的。同样的，内部密封类也是不被允许的。然而这只是临时方案，在我们添加了在其外部类而非内部类中声明内部密封类的子类的可能性时，将会删除该限制。(KT-16232，KT-16233） 现在使用一个名称完全由下划线字符组成的声明时将必须使用反引号。(KT-16264） Maven增量编译从Kotlin 1.1.2开始，以前用于IntelliJ IDEA和Gradle构建的增量编译现在也支持Maven。启用该功能时，需要使用-D命令行参数或proterties标记设置kotlin.compiler.incremental属性为true： 123&lt;properties&gt; &lt;kotlin.compiler.incremental&gt;true&lt;/kotlin.compiler.incremental&gt;&lt;/properties&gt; Maven注解处理现在可以从Maven构建中调用Kotlin的注解处理工具kapt了，只需要在compile前，从kotlin-maven-plugin中添加kapt的执行目标： 1234567891011121314151617181920&lt;execution&gt; &lt;id&gt;kapt&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;kapt&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt; &lt;sourceDir&gt;src/main/kotlin&lt;/sourceDir&gt; &lt;sourceDir&gt;src/main/java&lt;/sourceDir&gt; &lt;/sourceDirs&gt; &lt;annotationProcessorPaths&gt; &lt;!-- Specify your annotation processors here. --&gt; &lt;annotationProcessorPath&gt; &lt;groupId&gt;com.google.dagger&lt;/groupId&gt; &lt;artifactId&gt;dagger-compiler&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;/annotationProcessorPath&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt;&lt;/execution&gt; 在这里查看具有Java-Kotlin代码支持和测试的POM文件完整示例。 请注意，IntelliJ IDEA自己的构建系统仍然不支持kapt。当您要重新运行注解处理时，需要从“Maven Projects”工具栏中启动构建。 内联方法重构我们终于在Kotlin代码中实现了Inline方法（Function）的支持。 其他IDE改进在1.1.x时间范围内，我们很大一部分的工作是致力于提高IntelliJ IDEA插件的性能。在此次发布的1.1.2版本中，我们对几项主要性能进行了改进，主要涉及输入响应，同时我们也已经为后续1.1.3版本进行了额外的重大改进。 除此之外，我们还在此版本中进行了大量新的检测，快速解决方案和小型IDE功能。特别值得一提的是，在编辑器中支持折叠Android String资源引用，以及新的用于处理Android API版本问题的问题解决方案。 如何更新要更新IDEA插件，在菜单栏中依次选择 Tools | Kotlin | Configure Kotlin Plugin Update，然后点击“Check for updates now”按钮。另外，不要忘记在Maven和Gradle构建脚本中更新编译器和标准库版本 命令行编译器可以从 Github发布页面 页面下载。像往常一样，如果您在新版本中遇到任何问题，您可以在 论坛 中寻求帮助，在Slack(获取邀请)、或者在问题追踪器提出问题 。让我们来吧！","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"如何正确终止 forEach","slug":"如何正确终止-forEach","date":"2017-04-23T15:18:52.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/04/23/如何正确终止-forEach/","link":"","permalink":"http://www.Kotliner.cn/2017/04/23/如何正确终止-forEach/","excerpt":"","text":"问题背景话说周六下午团建回来，看到群里的小伙伴们在纠结一个问题，如何退出 forEach 循环，或者说有没有终止 forEach 循环的方法，就像 break 那样。我们来看个例子： 12345val list = listOf(1,3,4,5,6,7,9)for(e in list)&#123; if(e &gt; 3) break println(e)&#125; 如果 e 大于 3，那么循环终止，这是传统的写法，那么问题来了，我们现在追求更现代化的写法，要把代码改成 forEach 的函数调用，那么我们会怎么写呢？ 1234list.forEach &#123; if(it &gt; 3) ??? println(it)&#125; 就像上面这样吗？感觉应该是这样，不过大于 3 的时候，究竟该怎么办才能退出这个循环呢？ return 还是 return@forEach ？作为基本上等价于匿名函数的 Lambda 表达式，我们可能希望它能够提前返回，这样是不是就相当于终止循环了呢？ 1234567fun main(args: Array&lt;String&gt;) &#123; val list = listOf(1,3,4,5,6,7,9) list.forEach &#123; if(it &gt; 3) return println(it) &#125;&#125; 这时候我们毫不犹豫的写下了这样的代码，大于 3 的时候，直接 return，结果呢？运行到 4 的时候，forEach 就真的被终止了，后面也就没有了输出。 嗯，这样是不是就算把问题解决啦？想想也不可能呀，不然我这周的文章岂不是太坑人了？ 12345678fun main(args: Array&lt;String&gt;) &#123; val list = listOf(1,3,4,5,6,7,9) list.forEach &#123; if(it &gt; 3) return println(it) &#125; println(\"Hello\")&#125; 当我们把代码改成这样的时候，我们运行时发现只输出 1 3，后面的 Hello 则是无法打印的。原因呢，当然也很简单，在 return 眼里，Lambda 表达式都不算事儿，所以我们在大于 3 时的 return，实际上是返回了 main 函数，于是 list.forEach 这个结构之后的代码就不能被执行了。 好吧，那这里用 return 肯定是有问题的，我们不用它了行了吧。那不用 return 用什么呢？好在 Kotlin 为我们提供了标签式的返回方法，也就是说，如果你想从一个 Lambda 表达式当中显式地返回，那么你只需要写 return@xxx 即可，例如： 12345678fun main(args: Array&lt;String&gt;) &#123; val list = listOf(1,3,4,5,6,7,9) list.forEach &#123; if(it &gt; 3) return@forEach println(it) &#125; println(\"Hello\")&#125; 你也可以给这个 Lambda 表达式起个新标签名称，比如 block： 12345678fun main(args: Array&lt;String&gt;) &#123; val list = listOf(1,3,4,5,6,7,9) list.forEach block@&#123; if(it &gt; 3) return@block println(it) &#125; println(\"Hello\")&#125; 这样，我们的程序运行结果就是： 12313Hello 这一步大家都会想到的，不过这并不是最终的解。 调用还是循环？我来问大家一个问题，前面的 forEach 后面传入的 Lambda 表达式体是循环体吗？ 当然不是。那其实就是一个函数体，因此对这个函数体的退出只能退出当前的调用。为了说明这个问题，我们还是需要对原有的例子做下小修改： 123456789fun main(args: Array&lt;String&gt;) &#123; val list = listOf(1,3,4,5,6,7,9) list.forEach block@&#123; println(\"it=$it\") if(it &gt; 3) return@block println(it) &#125; println(\"Hello\")&#125; 结果呢？ 12345678910it=11it=33it=4it=5it=6it=7it=9Hello 好家伙，尽管我们在大于 3 的时候 return@block，但看上去仍然没有什么软用，显然，后面的循环仍然执行了。 简单总结一下，在 Lambda 表达式中，return 返回的是所在函数，return@xxx 返回的是 xxx 标签对应的代码块。由于 forEach 后面的这个 Lambda 实际上被调用了多次，因此我们没有办法像 for 循环那样直接 break 。 额。。这可如何是好？ 流式数据处理实际上我们在 Kotlin 当中用到的 forEach、map、flatMap 等等这样的高阶函数调用，都是流式数据处理的典型例子，我们也看到不甘落后却又跟不上节奏的 Java 在 8.0 推出了 stream Api，其实也无非就是为流式数据处理提供了方便。 采用流式 api 处理数据，我们就不能再像以前那样思考问题啦，以前的思维方式多单薄呀，只要是遍历，那就是 for 循环，只要是条件那就是 if…else，殊不知世界在变，api 也在变，你不跟着变，那你就请便啦。 那么，回到我们最开始的问题，需求其实很明确，遇到某一个大于 3 的数，我们就终止遍历，这样的代码用流式 api 写出来应该是这样的： 123val list = listOf(1,3,4,5,6,7,9)list.takeWhile &#123; it &lt;= 3 &#125;.forEach(::println)println(\"Hello\") 我们首先通过 takeWhile 来筛选出前面连续不大于 3 的元素，也就是说一旦遇到一个大于 3 的元素我们就丢弃从这个开始所有后面的元素；接着，我们把取到的这些不大于 3 的元素通过 forEach 打印出来，这样的话，程序的效果与文章最开头的 for 循环 break 的实现就完全一致了。 12345val list = listOf(1,3,4,5,6,7,9)for(e in list)&#123; if(e &gt; 3) break println(e)&#125; 当然，你可能会说如果我想要打印其中的偶数，那我该怎么写呢？这时候我告诉大家，如果你写出了下面这样的代码，那么我只能告诉你，。。额，我刚想说啥来着？？ 12345list.forEach &#123; if(it % 2 == 0)&#123; println(it) &#125;&#125; 上面这样写的代码呢，让我想起了辫帅张勋：张将军，你知不知道，咱大清已经亡了呢？ 1list.filter &#123; it % 2 == 0 &#125;.forEach(::println) 哈哈，如果真的希望使用流式 api，那么上面这样的写法才算是符合风格的写法。当然了，如果你愿意，你还可以定义一个 isEven 的方法，代码写出来就像下面这样： 123456fun Int.isEven() = this % 2 == 0fun main(args: Array&lt;String&gt;) &#123; val list = listOf(1,3,4,5,6,7,9) list.filter(Int::isEven).forEach(::println)&#125; 性能前不久看到有一篇文章对 Java 8 的流式 api 做了评测，说流式 api 的执行效率比传统的 for-loop 差出一倍甚至更多，所以建议大家慎重考虑选择。 其实对于这个东西我认为我们没必要把神经绷这么紧。原因也很简单呀，流式 api 的执行效率从实现上来讲，确实很难达到纯 for-loop 那样的高效，例如我们前面的： 1list.filter(Int::isEvent).forEach(::println) 在 filter 的时候就调用了一次完整的 for-loop，而后面的 forEach 同样再来一遍，也就是说我们用传统的 for-loop 一遍搞定的事儿，用流式 api 写了两遍，如果条件比较复杂，出现两遍三遍的情况也是比较正常的。 不过这并不能说明流式 api 就一定要慎重使用。流式 api 更适用于数据的流式处理，特别是涉及到较多 UI 交互的场景，这样的业务逻辑用流式 api 表达起来会非常的简洁直观，也易于维护，相应的，这样的场景对于性能的要求并没有到吹毛求疵的地步；而对于性能比较敏感的程序，通常来说也没有很复杂的业务逻辑，流式 api 在这里也难以发挥作用。 另外，仅仅多个几次循环也并不会改变算法本身的运算效率的数量级，所以对于适用于流式 api 的场景，大家还是可以放心去使用的。 – 如果你有兴趣加入我们，请直接关注公众号 Kotlin ，或者加 QQ 群：162452394 联系我们。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://www.Kotliner.cn/tags/Kotlin/"},{"name":"Lambda","slug":"Lambda","permalink":"http://www.Kotliner.cn/tags/Lambda/"},{"name":"Stream Api","slug":"Stream-Api","permalink":"http://www.Kotliner.cn/tags/Stream-Api/"}]},{"title":"[译]Use Kotlin with npm, webpack and react","slug":"Use Kotlin with npm, webpack and react","date":"2017-04-18T07:23:00.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/04/18/Use Kotlin with npm, webpack and react/","link":"","permalink":"http://www.Kotliner.cn/2017/04/18/Use Kotlin with npm, webpack and react/","excerpt":"","text":"在 Kotlin 1.1 中，编译器生成 JavaScript 功能已经达到生产可用状态。当然，编译器支持还不足以解决现实生活中的问题，所以我们继续将 Kotlin 整合到更大的 JavaScript 生态系统中。今天，我们要介绍两个新项目：一个将 Kotlin 与 npm，webpack 和 karma 集成在一起的 Gradle 插件，以及一个实现了 Kotlin/JVM 后端和基于 React 的 Kotlin/JS 前端的全栈应用程序示例。 Kotlin 前端插件Kotlin 前端插件 允许你使用 webpack 构建和部署 Kotlin 前端应用。你可以使用 npm 作为应用的包管理器，插件将负责将依赖的包下载并将其打包到生成的 JS 文件中。该插件还与 Karma 集成，允许你运行应用的测试用例。为了获得最佳的工作流程，该插件支持连续编译和实时预览，确保你的应用在浏览器中始终是最新的。README 文件给出使用插件的说明，示例目录包含一个 简单的例子 显示如何将其应用于真实的项目。 Kotlin React 例子 Thinkter 是使用 Kotlin 构建的现代全栈应用程序的一个例子。后端运行在 Jetty 并使用 Ktor （由 Kotlin 团队开发的 Kotlin Web 应用程序框架）。前端使用 React; Kotlin 的 React Wrappers 是 作为项目的一部分提供 。欢迎你在项目中使用我们的 React Wrappers，并根据自己的需要进行调整。请注意，我们正在努力在内部开发 React Wrappers，我们正在考虑将它们作为单独的开源库发布。想要了解 Kotlin React 的代码，可以直接阅读 应用组件 的源码。Kotlin 开发团队非常欢迎你们反馈意见！请在 GitHub 上提交问题，逛逛 论坛 ，或者加入Kotlin Slack 的 #javascript 频道。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"Kotlin Native 详细体验，你想要的都在这儿","slug":"Kotlin Native 详细体验，你想要的都在这儿","date":"2017-04-15T03:13:15.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/04/15/Kotlin Native 详细体验，你想要的都在这儿/","link":"","permalink":"http://www.Kotliner.cn/2017/04/15/Kotlin Native 详细体验，你想要的都在这儿/","excerpt":"","text":"本文来自：www.kotliner.cn， 源码地址：https://github.com/enbandari/Kotlin-Native-Demo 内容提要：本文通过 gradle 以及 makefile 两种方式对 Kotlin Native 项目进行构建，提供了详细的从 C 源码编译、到 Kotlin Native 项目的编译及运行的方法，以及该过程中遇到的问题和解决方案，涉及两处对编译器的修改也已经提交 pr。 最近因为 www.kotliner.cn上线的原因，一直没顾上对 Kotlin Native 进行体验，现在 Kotlin Native 预览版发布一周了，我来给大家较为详细地介绍一下它的一些相关内容。 1、Kotlin Native 是什么Kotlin Native 不是 Jni 的概念，它不仅仅是要与底层代码比如 C、C++ 交互，而且还要绕过 Jvm 直接编译成机器码供系统运行。也就是说，Kotlin 准备丢掉 Java 这根拐杖了！ 其实我第一次看到 Native 这个名字的时候很自然的想到了 Jni，Kotlin 跑在 Jvm 上面，使用 Jni 与底层代码交互是一件再正常不过的事情了，至于搞这么大动静么，不过等我进行了一番了解之后才发现，Kotlin 项目组的野心真是不小，Java 诞生这么多年了，也没有做过编译成除 Java 虚拟机字节码以外的字节码的事情，Kotlin 才出来多久啊，果然具有革命性。 所以以后有人再问你，什么是 Kotlin，你要回答，Kotlin 是一门很牛逼的静态语言（而不是之前经常说的 Kotlin 是一门运行在 Jvm、Android、FE 上的静态语言了），反正你能想到的，Kotlin 项目组都想干。。 2、如何编写 Kotlin Native 程序现在 Kotlin Native 刚刚处在技术预览阶段，离商用目测还需要至少一年的时间（小小地激动一下，2018年会不会发布正式版呢），性能优化、标准库、反射等等功能现在尚处于早期的状态，所以大家也没必要强求。下面我给大家介绍下怎么编译出一个 HelloWorld 工程。 2.1 准备编译器编译器目前有 Mac、Linux 两个版本，可以编出运行在 树莓派、iOS 以及 OS X 和 Linux 系统上的程序（Windows 真可怜。。），下面的演示运行在 Mac OS X 10.11.6 上，与 Linux 的小伙伴可能稍微一些差异。 编译器官方有现成可用的版本，下载地址如下： Mac / iOS Linux / 树莓派 不过呢，也建议小伙伴们直接 clone 编译器源码编译，没有复杂的编译步骤，两行命令即可搞定编译。 Github: Kotlin Native 代码拖下来之后，保证网络畅通，运行： 1$ ./gradlew dependencies:update 这一步是下载依赖，官方源码使用了 gradle-wrapper，所以如果你本地没有 gradle 3.1 的话也会自动去下载。这一步就是下载下载下载，所以一定要注意，出错的话基本上就是网络问题。运行完成之后，你就会在 dist/dependencies 目录下面看到下载的各种依赖了。 接着就可以编译了： 1./gradlew dist 编译时间不长，如果出现错误，可以 clean 多试几次。。编译完之后我们就可以得到编译器一份啦。 2.2 Gradle 版 HelloWorld下面我们先在 IntelliJ 中创建一个普通的 Gradle 工程，创建好之后，修改 build.gradle 文件，改成下面这样： 12345678910111213141516171819202122232425262728293031buildscript &#123; repositories &#123; mavenCentral() maven &#123; url \"https://dl.bintray.com/jetbrains/kotlin-native-dependencies\" &#125; &#125; dependencies &#123; classpath \"org.jetbrains.kotlin:kotlin-native-gradle-plugin:0.1\" &#125;&#125;apply plugin: 'konan'konanInterop &#123; kotliner &#123; defFile 'kotliner.def' // interop 的配置文件 includeDirs \"src/c\" // C 头文件目录，可以传入多个 //pkg \"cn.kotliner.native\" // C 头文件编译后映射为 Kotlin 的包名，这个有问题，后面我们再说 &#125;&#125;konanArtifacts &#123; Kotliner &#123; inputFiles fileTree(\"src/kotlin\") //kotlin 代码配置，项目入口 main 需要定义在这里 useInterop 'kotliner' //使用前面的 interop 配置 nativeLibrary file('src/c/cn_kotliner.bc') //自己编译的 llvm 字节格式的依赖 target 'macbook' // 编译的目标平台 &#125;&#125; 我们可以看到，konan 就是用来编译 Kotlin 为 native 代码的插件，konanArtifacts 配置我们的项目，konanInterop 主要用来配置 Kotlin 调用 C 的接口。有关插件的配置，可以参考官方文档：GRADLE_PLUGIN。 配置好之后，我们还要创建一个 gradle.properties 文件，加入下面的配置： 123# 配置编译器 home，要配置为 bin 目录的 parent# 例如：konan.home=&lt;你的 kotlin-native 源码路径&gt;/kotlin-native/distkonan.home=&lt;你的编译器路径&gt; 当然，这个配置可以不加，那样的话，你编译的时候会首先下载一个编译器放到你本地。 接着我们创建一个 kotliner.def 文件，用来配置 c 源码到 kotlin 的映射关系： kotliner.def 1headers=cn_kotliner.h 下面准备我们的源码，在工程目录下面创建 src 目录，在 src/c 目录下面创建下面的文件： src/c/cn_kotliner.h 12345678#ifndef CN_KOTLINER_H#define CN_KOTLINER_Hvoid printHello();int factorial(int n);#endif //CN_KOTLINER_H src/c/cn_kotliner.c 123456789101112#include \"cn_kotliner.h\"#include &lt;stdio.h&gt;void printHello()&#123; printf(\"[C]HelloWorld\\n\");&#125;int factorial(int n)&#123; printf(\"[C]calc factorial: %d\\n\", n); if(n == 0) return 1; return n * factorial(n - 1);&#125; 我们定义了两个函数，一个用来打印 “HelloWorld”，一个用来计算阶乘。 接着在 src/c 目录下面，用命令行编译： 1clang -std=c99 -c cn_kotliner.c -o cn_kotliner.bc -emit-llvm 如果提示找不到 clang 命令，可以去编译器的 dependencies 目录中找。 截止到现在，我们已经编译好 C 源码了。接着我们创建 kotlin 源码： src/kotlin/main.kt 123456import kotliner.*fun main(args: Array&lt;String&gt;) &#123; printHello() (1..5).map(::factorial).forEach(::println)&#125; 好了，这时候我们可以运行 gradle 的 build 任务了： 1234567891011121314151612:47:29: Executing external task &apos;build&apos;...:downloadKonanCompiler:genKotlinerInteropStubs UP-TO-DATE:compileKotlinerInteropStubsJetFile: kotliner.ktJetFile: kotliner.kt:compileKonanKotlinerJetFile: main.ktsrc/kotlin/main.kt:4:11: warning: inliner failed to obtain inline function declarationsrc/kotlin/main.kt:4:28: warning: inliner failed to obtain inline function declaration:buildBUILD SUCCESSFULTotal time: 34.743 secs12:48:04: External task execution finished &apos;build&apos;. 编译完成之后，在 build/konan/Kotliner/bin 目录中会生成一个 kexe 文件，命令行运行它： 123456789101112131415161718192021222324252627$ ./Kotliner.kexe[C]HelloWorld[C]calc factorial: 1[C]calc factorial: 0[C]calc factorial: 2[C]calc factorial: 1[C]calc factorial: 0[C]calc factorial: 3[C]calc factorial: 2[C]calc factorial: 1[C]calc factorial: 0[C]calc factorial: 4[C]calc factorial: 3[C]calc factorial: 2[C]calc factorial: 1[C]calc factorial: 0[C]calc factorial: 5[C]calc factorial: 4[C]calc factorial: 3[C]calc factorial: 2[C]calc factorial: 1[C]calc factorial: 012624120 好，我们的程序已经运行起来了，我们看到了 C 当中的 HelloWorld 输出以及阶乘求解的过程，大功告成。 当然，你还可以编写更多好玩的代码，编译的结果就是 Kotlin 再也不需要 Jvm 了，你说激动不激动？ 2.3 命令行版 HelloWorld除了 gradle 构建外，我们也可以直接使用命令行编译 Kotlin Native，具体步骤也比较类似，首先准备好源码，跟 2.2 中一致。 接着编写 Makefile 或者 build.sh，官方采用了 shell 脚本的方式来构建，那么我下面给出类似的 Makefile： 123456789101112build : src/kotlin/main.kt kotliner.kt.bc konanc src/kotlin/main.kt -library build/kotliner/kotliner.kt.bc -nativelibrary build/kotliner/cn_kotliner.bc -o build/kotliner/kotliner.kexekotliner.kt.bc : kotliner.bc kotliner.def cinterop -def ./kotliner.def -o build/kotliner/kotliner.kt.bckotliner.bc : src/c/cn_kotliner.c src/c/cn_kotliner.h mkdir -p build/kotliner clang -std=c99 -c src/c/cn_kotliner.c -o build/kotliner/cn_kotliner.bc -emit-llvmclean: rm -rf build/kotliner 这样只需要在命令行执行先把编译器 /bin 加入 path，之后执行 make，编译完成之后就可以在 build/kotliner/ 下面找到 kotliner.kexe 了。 3. 几个重要的坑3.1 Gradle 插件指定包名的问题gradle konan 插件配置中， 有一行可以配置 C 代码映射到 Kotlin 的包名： 123456konanInterop &#123; kotliner &#123; ... pkg \"cn.kotliner.native\" // 生成的 C 代码标识符中含有 “.” 倒是无法编译 &#125;&#125; 如果这样配置，那么生成的 cstubs.c 文件就会出现下面的情形： 123456#include &lt;stdint.h&gt;#include &lt;cn_kotliner.h&gt;int32_t kni_cn.kotliner.native_factorial (int32_t n) &#123; return (int32_t) (factorial((int)n));&#125; kni_cn.kotliner.native_factorial 显然这不是一个合法的 C 标识符。因此目前这个地方还是有问题的。 这个问题我已经提了 issue，参见：interop with package name failed 解决方案也比较简单，我发现这段儿 C 代码生成的时候，编译器企图对包名中的特殊字符进行替换，只不过替换的是 “/“ 而不是 “.”： org/jetbrains/kotlin/native/interop/gen/jvm/StubGenerator.kt 123456 private val FunctionDecl.cStubName: String get() &#123; require(platform == KotlinPlatform.NATIVE)- return \"kni_\" + pkgName.replace('/', '_') + '_' + this.name+ return \"kni_\" + pkgName.replace('.', '_') + '_' + this.name &#125; 3.2 Kotlin 的 main 函数不能有包名细心的读者应该会发现，我们前面写的 main 函数所在文件是没有 package 的，如果你给这个文件制定一个 package，那么编译器就无法找到入口函数，进而导致编译链接错误。 1234567Undefined symbols for architecture x86_64: &quot;_kfun:main(kotlin.Array&lt;kotlin.String&gt;)&quot;, referenced from: _Konan_start in combined8326574232997306104.old: symbol(s) not found for architecture x86_64exception: java.lang.IllegalStateException: The /Users/benny/Github/kotlin-native/dist/dependencies/target-sysroot-1-darwin-macos/usr/bin/ld command returned non-zero exit code: 1. at org.jetbrains.kotlin.backend.konan.LinkStage.runTool(LinkStage.kt:285) at org.jetbrains.kotlin.backend.konan.LinkStage.link(LinkStage.kt:261) 3.3 def 文件的路径如果你使用前面的 makefile 进行编译，cinterop 调用时传入的 def 文件的路径一定不能写成下面这样 1cinterop -def kotliner.def -o build/kotliner/kotliner.kt.bc kotliner.def 必须使用 ./kotliner.def 的形式，否则编译器在编译时出遇到类似下面的问题： 12345678&lt;konan.home&gt;/dependencies/clang-llvm-3.9.0-darwin-macos/bin/clang -Isrc/c -isystem &lt;konan.home&gt;/dependencies/clang-llvm-3.9.0-darwin-macos/lib/clang/3.9.0/include -B&lt;konan.home&gt;/dependencies/target-sysroot-1-darwin-macos/usr/bin --sysroot=&lt;konan.home&gt;/dependencies/target-sysroot-1-darwin-macos -mmacosx-version-min=10.11 -emit-llvm -c build/kotliner/kotliner.kt.bc-build/natives/cstubs.c -o build/kotliner/kotliner.kt.bc-build/natives/cstubs.bcclang-3.9: error: no such file or directory: &apos;build/kotliner/kotliner.kt.bc-build/natives/cstubs.c&apos;clang-3.9: error: no input filesException in thread &quot;main&quot; java.lang.Error: Process finished with non-zero exit code: 1 at org.jetbrains.kotlin.native.interop.gen.jvm.MainKt.runExpectingSuccess(main.kt:112) at org.jetbrains.kotlin.native.interop.gen.jvm.MainKt.runCmd(main.kt:158) at org.jetbrains.kotlin.native.interop.gen.jvm.MainKt.processLib(main.kt:396) at org.jetbrains.kotlin.native.interop.gen.jvm.MainKt.main(main.kt:43) 以上用 &lt; konan.home &gt; 替换了编译的路径。 这个问题是因为 cinterop 最终会调用 clang 去编译一个动态生成的 c 文件，而调用时传入的 workdir 是 def 文件的父目录，如果我们传入 def 文件时写了形如 “-def kotliner.def” 这样的参数，那么得到的父目录就是 null 了，于是就出现了各种找不到文件的情况。 当然我们可以对编译器源码稍作修改就可以解决这个问题： Interop/StubGenerator/src/main/kotlin/org/jetbrains/kotlin/native/interop/gen/jvm/main.kt 12357 - val workDir = defFile?.parentFile ?: File(System.getProperty(\"java.io.tmpdir\")) + val workDir = defFile?.absoluteFile?.parentFile ?: File(System.getProperty(\"java.io.tmpdir\")) 这个问题我也在 github 提了 pr，大家可以参考：Wrong workdir when use relative def file path like “-def interop.def”。 4、展望嗯，这题目看上去真有点儿让我想起毕业论文来呢。不过这个展望比起论文的展望要踏实得多。 4.1 IntelliJ 支持通过前面两节对 Kotlin Native 项目的构建和运行，我们发现 Kotlin 官方对于开发体验非常关注，尽管目前 IntelliJ 对此的支持还基本为零，不过 gradle 插件的支持已经非常令人满意了。相信随着 Kotlin Native 项目的迭代，IntelliJ 对其的支持也会趋于完善，彼时我们开发 Kotlin Native 的程序简直会 high 到飞起。 当然，我们也看到前面的构建过程中，对于 c 源码的构建支持几乎为零，我们仍然需要手动对 c 文件进行编译，不过这个并不复杂，所以极有可能出现的情形是 JetBrains 专门为 Kotlin 搞一个 IntelliJ 的版本（哇塞），整合 CLion 以及现有 Kotlin Native 的功能，一键编译 c 以及 Kotlin Native 源码也未可知呀。 4.2 支持更多平台Kotlin Native 技术预览版还不支持 windows，这可苦了没有 Unix-like 机器的小伙伴们（嗯，虚拟机可以拯救你们），不过这只是暂时的，前期也没必要在很多平台上投入精力，一旦 Kotlin Native 在 Unix-like 机器上火起来，届时 windows 版的动力岂不是更大么，哈哈。 比起对 windows 版的支持，我觉得对 Android 的支持才是杀手级的。毕竟现在写桌面程序的人要少一些了，而 windows 程序也大多用微软全家桶，所以赶紧支持 Android 吧，哈哈哈。 4.3 再见，Jni从学知道 Jni 的一开始，就尝试着写过几个小程序，结果毋庸置疑，除了蛋疼就是蛋疼，IDE 支持也困难得不要不要的。后来开始写 Android，也基本上对 Jni 是敬而远之。 说起来我们公司项目有大量的 openGL 代码用 C/C++ 编写，在 windows 和 Mac 上有相应的移植版本，开发完成后再打包移植到 Android 以及 iOS 上。当然，我并不在这些项目组，我只是觉得搞这些开发的同事特别是负责移植到 Android 的同事的实在太优秀了，像我这种 JB 脑残粉，离了 IDE 智能提示的话，一行代码都写不下去。。。 Kotlin 的出现很有希望终结 Jni 的痛苦现状，Kotlin Native 也将为我们这些 Jvmer 打开一扇窗户，让我们几乎零成本进入底层代码的编写。 那个什么，以后别说自己是 Jvmer 了，说自己是 Kotliner 吧，也欢迎大家经常光顾 www.kotliner.cn。 4.4 大一统如果我想写个牛逼一点儿的程序，我会选择 Java，原因是我对它最熟； 如果我想写一个工具脚本，我会选择 python，尽管 python 有时候还真是挺坑的，不过用着还算不错； 如果我想写个网站，我会选择 php，因为。。开发方便，资料也多。。。 嗯，自打一开始学编程，我就发现这坑可踩大发了。尽管用 C 可以写出 php 能写出的任何程序，Java 也一样，不过每一门语言终究因其自身的特点而擅长于不同的使用场景。 前不久跟一个资深开发聊天，他问我 Kotlin 能做什么，我说能做这个，能做那个，结果他听了之后来了一句：Kotlin 能写的 Java 都能写是呗？没错，他说得是对的，只是这能和能做好之间可就差了十万八千里了。 请问，如果你想要写一个小工具，你用 Java 写的话，是不是工程还没有配好，别人用 python 就已经调试完了？如果你用 C++ 写 web 应用，是不是工程还没配好，别人用 php 已经开始跟客户端联调了？这么说也许夸张了一些，但不得不承认的是，每一门语言都有其擅长的场景，“xxx能干的yyy也能干” 这样的句式简直让人有种 “你行你上啊” 来批驳的冲动。 那么 Kotlin 的出现究竟能给我们带来什么呢？试想一下，写小工具，我们可以用 kts（Kotlin Script）；所有 Java 擅长的 Kotlin 都擅长，而且写起来还比 Java 简洁不少；你甚至可以用 Kotlin 来开发前端程序来替代 JavaScript，尽管这个目前看来还没有很多人用到。而现在呢，我们还可以把 Kotlin 直接编译成 C 一样的机器码来运行，这样一来，Kotlin 将来还可以直接应用于嵌入式等对性能要求比较高的场景，这可真是上的了云端，下的了桌面，写的了网页，嵌的了冰箱啊。 一句话，Kotlin 从 Jvm 起家，现正在向着各种应用场景用功，各个场景的表现也不错，俨然成为一门擅长多个领域的语言了。 当然，程序员们也是萝卜青菜各有所爱，真正实现大一统显然也不太现实，但我们至少拥有了这样的途径和机会是不是？ 如果你有兴趣加入我们，请直接关注公众号 Kotlin ，并且加 QQ 群：162452394 联系我们。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://www.Kotliner.cn/tags/Kotlin/"},{"name":"Native","slug":"Native","permalink":"http://www.Kotliner.cn/tags/Native/"}]},{"title":"Kotliner.cn 上线啦","slug":"Kotliner.cn 上线啦","date":"2017-04-10T03:09:51.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/04/10/Kotliner.cn 上线啦/","link":"","permalink":"http://www.Kotliner.cn/2017/04/10/Kotliner.cn 上线啦/","excerpt":"","text":"Kotliner Kotlin 在国内目前引起了不少人的关注，不过整体上 Kotlin 的国内技术氛围还是要稍微差一些的。目前国内有一个 Kotlin 论坛，不过不太活跃，毕竟论坛的时代已经过去了，现在除了房地产水一下水木，找 IT 工作的水一下北邮人，技术论坛感觉已经过气了。我看到有些朋友在 Github 上面发起翻译 Kotlin 官网的项目，这个想法挺不错，不过应该知道的人不多，可能需要一些宣传；在总结了前人的经验之后，我觉得我们可以依托公众号和 QQ 群搭建一个博客，这个博客主要承担下面的功能： 同步更新官方博客中文版 同步更新 Kotlin 公众号 收录整理国内优秀的 Kotlin 资源 发现并宣传国内优秀的 Kotlin 开发者和分享者 总体上讲，做到 Kotlin 开发者的一本重要的参考手册，在目前国内资源匮乏的条件下满足 Kotlin 开发者的日常开发需求，同时也要为热衷于分享的 Kotlin 开发者提供一个展示自己的机会。 截止现在，Kotliner 已经同步完所有 Kotlin 公众号的文章，我们的下一步计划是同步 Kotlin 1.0 发布以来官方博客的部分有价值的文章，这些文章发布于正式版之后，基本上到现在还是比较有参考价值的。 如果你有兴趣加入我们，请直接回复公众号，或者加 QQ 群：162452394 联系我们。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[{"name":"kotlin.cn 中文博客","slug":"kotlin-cn-中文博客","permalink":"http://www.Kotliner.cn/tags/kotlin-cn-中文博客/"}]},{"title":"Kotlin Native：本周又搞了个大事情","slug":"Kotlin Native：本周又搞了个大事情","date":"2017-04-10T01:49:45.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/04/10/Kotlin Native：本周又搞了个大事情/","link":"","permalink":"http://www.Kotliner.cn/2017/04/10/Kotlin Native：本周又搞了个大事情/","excerpt":"","text":"话说。。有一天在地铁上正站得我风生水起（这玩意儿也能风生水起？）的时候，小伙伴突然往群里面丢了一个链接，然后群里就炸了：Kotlin/Native Tech Preview: Kotlin without a VM，Kotlin Native 在年初的时候就逐渐引起大家的注意，Kotlin 的扛把子 Andrey 哥也一再表示“用不了多久咱们就能过上好日子啦”，当然我估摸着 2017 年的大事情会不少，这不来得还挺快。 话说这 Kotlin Native 呢，还处于预览阶段，官方一再强调“我还是个宝宝，你们可不要乱来哦”： No performance optimization has been done yet, so benchmarking Kotlin/Native makes no sense at this point. 这个嘛，请官方放心，我们不会轻易放过你的！ 于是群里小伙伴们开始下载 Native 的源码 Github: Kotlin-native 开始编译，并运行其中的 sample，整个过程其乐融融，有 Mac 和 Linux 的小伙伴表示毫无压力，而只有 windows 的哥们表示“我的树莓派不在家里啊”。额，看到没，用 windows 做开发是没有钱途滴！这事儿突然让我想起来前几天编译 Android Sdk 源码，编译 mac 版在 Mac 上面编即可，而想编译 windows 的 sdk，你就得在 Linux 上面先编译完 Linux 版 sdk，然后再用 Linux 版来个移魂大法换成 windows 版，额，我就改了几句 aapt 的代码，mac 版立等可取，windows 版编了好几天啊哭。。 接着说 Kotlin Native，当小伙伴们看到 Kn 编译之后生成了这样的 stubs，瞬间表示 Jni 有救啦！ 一个注解就能连接上 C 代码，是不是很让人期待！ 想来也真是给力，上周刚刚推送的文章对 Kotlin Native 做了狠狠的期待，这周就出这样的大新闻，不得不说，2017 年 Kotlin 很让人期待呀，如果你还在犹豫到底要不要学，啥也别说了先加 QQ 群吧：","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[{"name":"Native","slug":"Native","permalink":"http://www.Kotliner.cn/tags/Native/"}]},{"title":"Kotlin Primer草稿 函数","slug":"KotlinPrimerFunction","date":"2017-04-07T01:10:11.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/04/07/KotlinPrimerFunction/","link":"","permalink":"http://www.Kotliner.cn/2017/04/07/KotlinPrimerFunction/","excerpt":"","text":"函数本章节主要介绍Kotlin中的函数相关的概念。 普通函数声明即使Kotlin是一门面向对象的编程语言，它也是有函数的概念的——而不像Java那样，仅仅有“方法”。 Java中有静态方法来代替函数的作用，但是Kotlin的函数比Java的静态方法自由度大很多。我们先来看几个例子。 函数声明使用fun保留字，语法比较类似Scala： 123fun function() &#123; println(\"This is a function\")&#125; 如果你需要一个有参数的函数： 123fun functionWithParams(obj: Any?) &#123; println(\"You have passed an object to this function: $obj\")&#125; 上面的函数有一个Any?类型的参数。类似的例子还有程序的入口main函数： 12fun main(args: Array&lt;String&gt;) &#123;&#125; 如果你需要一个返回值的话： 123fun functionWithReturnValue(): Int &#123; return Random().nextInt()&#125; 如果一个函数不返回东西，你可以不写返回值。也可以让它显示返回Unit： 12fun functionReturnsUnit(): Unit &#123;&#125; 如果一个函数不会返回（也就是说只要调用这个函数，那么在它返回之前程序肯定GG了（比如一定会抛出异常的函数）），因此你也不知道返回值该写啥，那么你可以让它返回Nothing： 123fun functionReturnsNothing(): Nothing &#123; throw RuntimeException(\"\")&#125; 一个函数也可以拥有Java风格的泛型参数： 123fun &lt;T&gt; functionWithGenericsParam(t: T): T &#123; return t&#125; Kotlin中的泛型概念和Java基本相同，这里不再展开讨论。关于型变、协变等Java中没有的复杂泛型概念将在下文讨论。 函数参数可以有默认值（关于这个函数中for循环的中缀语法下文会提到，这里可以先忽略）： 1234fun functionWithDefaultParams(limit: Int = 10): Int &#123; for (i in 0..limit step 2) println(i) return limit&#125; 于是你不再需要像Java那样为了默认参数而写一大长串重载函数了。当然，Kotlin也支持重载。 如果一个函数的函数体只需要一个表达式就可以计算出来，比如考虑如下函数： 123fun functionReturningIncreasedInteger(num: Int): Int &#123; return num + 1&#125; 你可以直接使用这种语法（expression function body）： 1fun functionReturningIncreasedInteger(num: Int) = num + 1 第二种语法省略了返回值类型（编译器可以根据后面的表达式推导出返回类型），以及大括号。 同理，比如说我们有一个求平方的函数： 1fun square(int: Int) = int * int 如果一个函数是空函数，比如Swing的ActionListener强制要求重载但是又不需要使用的函数，可以通过这种方式来表达： 1234567891011121314fun main(args: Array&lt;String&gt;) &#123; val input = JTextField() input.addKeyListener(object : KeyListener &#123; override fun keyTyped(e: KeyEvent?) = Unit override fun keyReleased(e: KeyEvent?) = Unit override fun keyPressed(e: KeyEvent?) &#123; if (e != null &amp;&amp; e.keyCode == KeyEvent.VK_ENTER) &#123; output.append(\"$&#123;input.text&#125;\\n\", Color(0x467CDA)) repl.handle(input.text, sl) input.text = \"\" &#125; &#125; &#125;)&#125; 其中， fun xxx() = Unit 表示这是一个空函数。 如果一个函数不返回Unit或者Nothing，那么尽可能让它成为一个纯函数（即没有副作用)的函数）。这是函数式编程的约定。 关于函数式编程：函数式编程是一种学院派的编程范式，与之对应的是“命令式编程”。它常常与数学中的范畴论（category theory）结合，追求编写更易维护、并发性更好的程序。业界对它褒贬不一，笔者倾向于将它与面向对象编程结合。 虽然Hadi Hariri曾经在JetBrains中国开发者日上说过Kotlin不是函数式编程语言，但是Kotlin有大量的（看起来非常）函数式的特性、约定、标准库函数。因此我们可以默认它是追求函数式编程的，那么就应该尽可能遵循函数式法则。 为什么返回Unit或者Nothing就不需要纯了呢？ 既然一个函数没有返回值，那么对它讨论引用透明也就没有意义了。如果一个返回Unit或者Nothing的函数没有副作用，那么它的存在也将没有意义。 更多关于函数式编程的知识不在本书讨论范围内，读者可以自行查询相关资料。 内部函数函数里面也可以定义函数： 12345678fun functionWithAnotherFunctionInside() &#123; val valuesInTheOuterScope = \"Kotlin is awesome!\" fun theFunctionInside(int: Int = 10) &#123; println(valuesInTheOuterScope) if (int &gt;= 5) theFunctionInside(int - 1) &#125; theFunctionInside()&#125; 内部函数可以直接访问外部函数的局部变量、常量，Java是做不到这点的哦。 递归也没有任何问题。如上面的代码所示。 方法方法是一种特殊的函数，它必须通过类的实例调用，也就是说每个方法可以在方法内部拿到这个方法的实例。这是方法和函数的不同之处。 方法和函数几乎一模一样，唯一的区别就是方法必须声明在类里面。下面是一个方法和一个函数： 12345fun thisIsAFunction() = Unitclass ThisIsAClass &#123; fun thisIsAMethod() = Unit&#125; 中缀表达式可能你会好奇上面给出的一个例子中有一个for循环使用的诡异语法，即中缀表达式： 12345fun main(args: Array&lt;String&gt;) &#123; for (i in 1..100 step 20) &#123; println(i) &#125;&#125; 这个step是什么意思呢？ 其实是Kotlin方法的一种语法糖，一个方法如果在声明时有一个infix修饰符，那么它可以使用中缀语法调用。 所谓中缀语法就是不需要点和括号的方法调用： 123456789101112class Bclass A &#123; infix fun infixFunction(b: B) &#123; // codes &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val a = A() a infixFunction b&#125; 同理，我们只需要给一个类增加一个中缀的step方法就可以实现上面的语法： 12345678class A &#123; infix fun step(step: Int) = Unit&#125;fun main(args: Array&lt;String&gt;) &#123; val a = A() a step 2&#125; 这个功能基本就是用于将代码变得“更易阅读”。Scala所有函数缺省支持中缀表达式，Kotlin需要单独声明。 操作符重载中缀表达式可以在一定程度上简化函数调用的代码。如果说中缀表达式还不够简洁，那么你一定需要操作符重载了。 Kotlin的操作符重载的规则是： 该方法使用operator修饰符 该方法的方法名必须被声明为特定的名称，以将对应的操作符映射为这个函数的调用 参数必须符合该操作符的规定，比如+的重载就不能有多于一个（不含）的参数，也不能为空参数。 举个例子，我们要重载A类的+运算符。注意三个规定（函数名、参数得符合规矩，加operator修饰）： 12345class A &#123; operator fun plus(a: A) &#123; println(\"invoking plus\") &#125;&#125; 这就是对+的重载了。我们可以这样调用这个函数： 1val a = A() + A() 此处的+就是对plus方法的调用了。我们可以运行上面的代码，看到输出：”invoking plus”。 当然，操作符重载也可以被替换为函数调用： 1val a = A().plus(A()) 这段代码和上面那段完全相同。 还有不少操作符的重载，下面给出一系列例子（仅作为函数名的实例，实现全部为空/false/0（因为部分操作符重载要求返回Int/Boolean））： 123456789101112131415161718192021222324252627282930313233class A &#123; operator fun plus(a: A) = Unit operator fun minus(a: A) = Unit operator fun times(a: A) = Unit operator fun div(a: A) = Unit operator fun rem(a: A) = Unit @Suppress(\"DEPRECATED_BINARY_MOD\") @Deprecated(\"mod should be replaced with rem\", ReplaceWith(\"rem\")) operator fun mod(a: A) = Unit operator fun rangeTo(a: A) = Unit operator fun get(index: Int) = Unit operator fun get(index1: Int, index2: Int) = Unit operator fun set(index: Int, value: Any?) = Unit operator fun set(index1: Int, index2: Int, value: Any?) = Unit operator fun invoke(obj: Any?) operator fun inc() = A() operator fun dec() = A() operator fun unaryPlus() = A() operator fun unaryMinus() = A() operator fun compareTo(other: Any?) = 0 override operator fun equals(other: Any?) = false operator fun contains(element: Any?) = false operator fun iterator() = object : Iterator&lt;Any&gt; &#123; override operator fun hasNext() = false override operator fun next() = Unit &#125;&#125; 首先是最基本的操作符，它们对应的操作符和注释中的一一对应： 12345678910111213class A &#123; operator fun plus(a: A) = Unit // + operator fun minus(a: A) = Unit // - operator fun times(a: A) = Unit // * operator fun div(a: A) = Unit // / operator fun rem(a: A) = Unit // % @Suppress(\"DEPRECATED_BINARY_MOD\") @Deprecated(\"mod should be replaced with rem\", ReplaceWith(\"rem\")) operator fun mod(a: A) = Unit // %，和rem一样 operator fun rangeTo(a: A) = Unit // ..&#125; 倒数第二个mod是特殊的操作符重载——它在Kotlin1.1中被标记为过时（Deprecated）的。在1.1中，使用了rem（remainder）来代替mod，符合java.math.BigInteger的命名。 关于最后那个rangeTo有些不符合人的直觉，下面讲到contains的时候会一起提到，读者可以暂时放下这个问题。 然后是下标访问操作符： 123456class A &#123; operator fun get(index: Int) = Unit operator fun get(index1: Int, index2: Int) = Unit operator fun set(index: Int, value: Any?) = Unit operator fun set(index1: Int, index2: Int, value: Any?) = Unit&#125; get接收任意数量的int参数，假设它们是index1, index2, index3（以此类推），那么对应的操作符就是对应维数个下标的访问。比如以下例子，操作符对应的方法调用写在行尾注释里了： 12345fun main(args: Array&lt;String&gt;) &#123; val a = A() a[1] // a.get(1) a[1][2] // a.get(1, 2)&#125; 对应的set接收任意数量个int，以及一个任意类型的对象，表示将下标访问作为左值并赋值： 12345fun main(args: Array&lt;String&gt;) &#123; val a = A() a[1] = 233 // a.set(1, 233) a[1][2] = \"666\" // a.set(1, 2, \"666\")&#125; invoke方法允许你把一个Kotlin对象当作Lambda表达式来使用。关于什么是Lambda表达式下文会专门介绍。 12345678910class A &#123; operator fun invoke(obj: Any?)&#125;fun main(args: Array&lt;String&gt;) &#123; val a = A() a(obj) // 实际上调用了 a.invoke(obj) // 还可以 A()(obj)&#125; 自增自减运算符就更简单了，它们必须返回自己所在类的子类型。这里直接在注释里面写出对应的操作符表达： 1234567// 假设a是A的一个实例class A &#123; operator fun inc() = A() // a++ operator fun dec() = A() // a-- operator fun unaryPlus() = A() // ++a operator fun unaryMinus() = A() // --a&#125; 还有比较运算符，这是一个特殊的操作符重载，一个函数将会生成一组操作符。有一个特殊情况，就是相等的判断。 考虑以下代码： 1234class A &#123; operator fun compareTo(other: Any?) = 0 override operator fun equals(other: Any?) = false&#125; 当一个类只有compareTo没有equals的时候，所有的六个比较运算符（\\&lt;, >, \\&lt;=, >=, ==, !=）会被全部代理给compareTo函数的返回值和0的大小比较： 12345678fun main(args: Array&lt;String&gt;) &#123; A() &gt; A() // A().compareTo(A()) &gt; 0 A() &lt; A() // A().compareTo(A()) &gt; 0 A() &gt;= A() // A().compareTo(A()) &gt;= 0 A() &lt;= A() // A().compareTo(A()) &lt;= 0 A() == A() // A().compareTo(A()) == 0 A() != A() // A().compareTo(A()) != 0&#125; 如果有equals，==和!=两个操作符会被代理给equals方法，其余不变。 1234fun main(args: Array&lt;String&gt;) &#123; A() == A() // A().equals(A()) A() != A() // !A().equals(A())&#125; 有一个操作符，这个操作符不是严格意义上的“操作符”，但它比起其它的操作符重载，它还多了一个特权。它就是in操作符。 123class A &#123; operator fun contains(element: Any?) = false&#125; 它要求返回Boolean，传入一个参数。调用的话使用in： 1234fun main(args: Array&lt;String&gt;) &#123; val ls = listOf(12, 233, 43) println(233 in ls)&#125; 这里的in就是调用了ls的contains方法。这里你可能要问了：既然是使用in这个符合Kotlin函数命名规范的表达，为什么不使用中缀表达式呢？ 想清楚了，我们暂且不说in其实是Kotlin保留字这个问题，中缀表达式的语法是： 12345678fun main(args: Array&lt;String&gt;) &#123; a.func(b) // 变成 a func b // 它不能变成 // b func a // 上面那个是错的，会变成b.func(a)&#125; 但是a in b其实是调用了b的一个方法，因此中缀表达式无法实现这个in。 前面说到contains操作符有一个特权，我们来看看这个特权。还记得when语句吗？它非常灵活，比Java风格的switch不知道高到哪里去了。这里先看一个基本用法： 12345678fun main(args: Array&lt;String&gt;) &#123; val a = Random(System.currentTimeMillis()).nextInt() when (a) &#123; 1 -&gt; &#123; /* codes */ 233 &#125; 2 -&gt; 233 else -&gt; 666 &#125;&#125; 它可以配合contains方法： 12345678fun main(args: Array&lt;String&gt;) &#123; val a = Random(System.currentTimeMillis()).nextInt() when (a) &#123; in 1..100 -&gt; 233 is Int -&gt; 2333 else -&gt; 666 &#125;&#125; 看到了吗？in还可以这样写哦。 还有一组运算符，它们将被编译为相同的一个操作符，也是in，只不过场合不同。 12345class A &#123; operator fun iterator() = Unit operator fun hasNext() = false operator fun next() = Unit&#125; 这个in是用于for-in循环的。上面例子中的for循环使用的是这个in操作符。 一个标准的Kotlin风格的for循环应该是下面这样的：123fun main(args: Array&lt;String&gt;) &#123; for (i in 1..10) println(i)&#125; 它和下面的代码完全等价： 1234567fun main(args: Array&lt;String&gt;) &#123; val range = 1..10 val item = range.iterator() while (item.hasNext()) &#123; println(item.next()) &#125;&#125; 还记得那个step吗？它其实是对1..100调用了一个中缀的方法step。这下读者对于前面遗留的疑问就全部解决了。 Kotlin关于操作符重载的内容确实比较繁杂，但是比起C++的操作符重载还是要强大那么一点点的（C++没有in这种操作符）。 Lambda表达式好了这是函数式编程的重头戏——Lambda表达式。 Lambda表达式俗称匿名函数，熟悉Java的大家应该也明白这是个什么概念。Kotlin的Lambda表达式更“纯粹”一点，因为它是真正把Lambda抽象为了一种类型，而Java只是单方法匿名接口实现的语法糖罢了。 Lambda在Java中非常常用，这里不再单独介绍它。 Lambda表达式最常用的地方之一是为GUI控件设置监听器： 1234567fun main(args: Array&lt;String&gt;) &#123; val button = JButton(\"Clear screen\") button.addActionListener &#123; output.text = \"\" output.append(\"Repl.HINT\") &#125;&#125; 还有调用集合框架抽象出来的高阶函数（Higher Order Function）： 12345fun main(args: Array&lt;String&gt;) &#123; (1..10).forEach &#123; println(it) &#125;&#125; 上面的代码可能会令读者产生疑惑，那个it是什么鬼？ it是Kotlin为单参数的Lambda钦定的默认参数名。单参数的Lambda可以省去参数的声明，转而使用it这个名字。 首先，我们有无参数的Lambda表达式： 123fun main(args: Array&lt;String&gt;) &#123; &#123; &#125;&#125; 你可以直接把它写在外面，并且把它当成对象使用。Lambda对象有缺省的invoke函数的实现，也就是调用这个Lambda： 123fun main(args: Array&lt;String&gt;) &#123; &#123; println(\"invoking lambda\") &#125;.invoke()&#125; 你也可以使用操作符重载的方式调用invoke函数： 123fun main(args: Array&lt;String&gt;) &#123; &#123; println(\"invoking lambda\") &#125;()&#125; 如果一个Lambda有参数，那么需要使用这样的语法声明： 1234fun main(args: Array&lt;String&gt;) &#123; // &#123;参数名:参数类型 -&gt; Lambda体&#125;() &#123; str: String -&gt; println(str) &#125;(\"the deep dark fantasy\")&#125; 如果有多个参数： 123456fun main(args: Array&lt;String&gt;) &#123; // &#123;参数名:参数类型, 参数名:参数类型 -&gt; Lambda体&#125;() &#123; str: String, num: Int -&gt; println(\"num = $num, str = $str\") &#125;(\"the deep dark fantasy\", 233)&#125; Lambda变量的签名不需要写参数名，只需要写类型。Lambda的返回值就是最后一个表达式的返回值。就像这样： 123456789fun main(args: Array&lt;String&gt;) &#123; // 只需要写类型，我没骗你吧 val value: (String, Int) -&gt; Int value = &#123; str: String, num: Int -&gt; println(\"num = $num, str = $str\") num &#125; value(\"the deep dark fantasy\", 233) + 1&#125; 如果Lambda的参数、返回值类型不匹配，互相赋值是会报错的哦。 当然，Lambda经常作为函数参数使用。 如果一个Lambda是一个函数的最后一个参数，Kotlin为这种情况专门提供了一个语法糖。 Lambda在作为匿名变量传递给函数时，不需要显式声明参数类型（因为可以根据函数参数那里的类型签名推导）。 上面两句话如何理解呢？比如你有一个自定义UI控件： 12345class KotlinButton : View() &#123; fun setOnClickListener(block: (View) -&gt; Unit) &#123; // set &#125;&#125; 然后调用的时候就可以使用这个语法糖了： 123456789101112131415class MainActivity : AppCompatActivity() &#123; override fun onCreate(save: Bundle?) &#123; val a = KotlinButton() // 原本是： // a.setOnClickListener(&#123; view -&gt; // toast(\"Clicked\") // &#125;) // 语法糖省去了表示参数的括号，直接写Lambda a.setOnClickListener &#123; view -&gt; // 编译器的类型推导省去了 view: View 的类型声明 toast(\"Clicked\") view.text = \"Oh my god\" &#125; &#125;&#125; 上面那段代码是Android的，熟悉的API看出来了吗？ 你甚至还可以把那个view参数的声明给省了，因为只有一个参数，可以使用it代替： 123456fun main(args: Array&lt;String&gt;) &#123; a.setOnClickListener &#123; toast(\"Hia hia\") it.text = \"clicked\" &#125;&#125; 如果一个函数不只是有一个参数，但是最后一个参数（依然符合条件），那么可以这样写： 12345fun main(args: Array&lt;String&gt;) &#123; a.callSomeMethods(1, 2, 3) &#123; // do something &#125;&#125; 它完全等价于： 12345fun main(args: Array&lt;String&gt;) &#123; a.callSomeMethods(1, 2, 3, &#123; // do something else &#125;)&#125; 如果你不需要用到那个参数，又不想为它命名，那么使用下划线代替它吧。 12345fun main(args: Array&lt;String&gt;) &#123; a.setOnClickListener &#123; _ -&gt; toast(\"LOL LOL LOL\") &#125;&#125; 此时你可能会问：上面那个代码完全可以把整个_ -&gt;给省掉啊？不是说单参数可以省吗？ 因为多参数是不能省的（多参数Lambda不写参数会报错），所以它还是很有用的： 12345fun main(args: Array&lt;String&gt;) &#123; listOf(1, 2, 3).forEachIndexed &#123; _, _ -&gt; println(\"Looping!\") &#125;&#125; 最后说的这个下划线的特性是Kotlin1.1才引入的。 请读者注意不要混淆上面的两个“多参数”，第一处说的是函数多参数，第二处说的是Lambda多参数。 我们可以通过Lambda表达式来勉强地实现函数的柯里化： 1fun plus(a: Int) = &#123; b: Int -&gt; a + b &#125; 调用就可以这样： 123fun main(args: Array&lt;String&gt;) &#123; println(plus(233)(666))&#125; 这有什么用呢？可以实现一个函数的部分应用。 123456fun main(args: Array&lt;String&gt;) &#123; val a = plus(233) // 然后呱啦呱啦呱啦一堆东西 val pluser2 = getIntFromSomewhere() println(a(pluser2))&#125; 和泛型结合之后可以泛化出上面那个函数的抽象： 12fun &lt;A, B, C&gt; ((a: A, b: B) -&gt; C).curry() = &#123; a: A -&gt; &#123; b: B -&gt; invoke(a, b) &#125; &#125; plus就可以这样被抽象出来： 1234567fun main(args: Array&lt;String&gt;) &#123; val plusOrigin = &#123; a: Int, b: Int -&gt; a + b &#125; val a = plusOrigin.curry() a(233)(666) // 和上面那个就是一样的了&#125; 我们还可以做出多参数的柯里化的抽象： 1234fun &lt;A, B, C, D, E, F, G&gt; ((a: A, b: B, c: C, d: D, e: E, f: F) -&gt; G).curry() = &#123; a: A -&gt; &#123; b: B -&gt; &#123; c: C -&gt; &#123; d: D -&gt; &#123; e: E -&gt; &#123; f: F -&gt; invoke(a, b, c, d, e, f) &#125; &#125; &#125; &#125; &#125; &#125; 这样的抽象可以用于更多参数的函数的柯里化： 123456789101112131415161718192021fun main(args: Array&lt;String&gt;) &#123; val makeString = &#123; a: Int, b: Short, c: String, d: File, e: URL, f: Double -&gt; \"$a $b $c $d $e $f\" &#125; val a = makeString.curry() // 调用方法一 a(233)(666)(\"Gensokyo\")(File(\"./README.md\"))(URL( \"https://github.com/ice1000\"))(1.0) // 调用方法二 a(233) .invoke(666) .invoke(\"Gensokyo\") .invoke(File(\"./README.md\")) .invoke(URL(\"https://github.com/ice1000\")) .invoke(1.0)&#125; 就是这样。 调用函数调用写法和Java几乎完全一样，比如调用上面声明的几个函数： 1234fun main(args: Array&lt;String&gt;) &#123; functionWithGenericsParam(233) functionReturnsNothing()&#125; 已经说过了Lambda的invoke写法所以这里不再提及。 当你需要调用一个接收了“有返回值的Lambda”的函数时，这样的写法是会报错的： 1234567fun main(args: Array&lt;String&gt;) &#123; function &#123; println(\"Hi there!\") // 下面这句会报错！ // return 233 &#125;&#125; 因为这样的return语句在被inline之后，编译器不知道你是要return掉main函数还是这个Lambda。 因此你需要显式声明return的作用域： 123456fun main(args: Array&lt;String&gt;) &#123; function &#123; println(\"Hi there!\") return@function 233 &#125;&#125; 这叫做“Label return”，其中return@后面的标签（Label）是你要return的Lambda所传递给的函数名（比如上面就是function）。 如果你的函数名是kotlinIsAwesome，那么你就需要这样写： 12345fun main(args: Array&lt;String&gt;) &#123; kotlinIsAwesome &#123; return@kotlinIsAwesome 233 &#125;&#125; 如果你使用IntelliJ IDEA，它会告诉你你需要写什么标签。 内联函数顾名思义，就是把函数体给内联到调用处。这对程序的逻辑是没有影响的，只是对一些无关逻辑的因素有影响，比如： 运行效率 目标文件体积 重构上的优越性 等等。 比如标准库的一堆函数： 12345/** Prints the given message to the standard output stream. */@kotlin.internal.InlineOnlypublic inline fun print(message: Any?) &#123; System.out.print(message)&#125; 内联函数最好的好处就是直接内联Lambda，不产生匿名内部类对象。这是一个非常黑的黑科技，减少Lambda对象的数量可以既保证函数式的优美代码，又不必为Lambda对象的开销买单。 如果一个内联函数没有内联到Lambda表达式，那么Kotlin编译器会给出一个警告——因为inline本身就只是为了inline掉Lambda而准备的特性，标准库会有一些专门用于内联的函数（后面会讲到）。inline一些无关紧要的函数反而会导致无谓的体积增加（JVM本身就会在运行时内联不少函数）。 Kotlin-discussion曾经出现过一个帖子，楼主说他太喜欢inline这个功能了，以至于把大量的大型函数inline的到处都是，最后导致了jar体积的肥大。 crossinline与noinlinecrossinline是一种比普通inline更高级的inline方法，它只能修饰Lambda参数，用于处理一些奇怪的Lambda的内部return（有时你只是想return掉Lambda，但是内联后会导致return掉外部context）。 Kotlin编译器使用了一些奇怪的方法来复用内联Lambda产生的参数。 123fun crossInlineFunction(crossinline f: () -&gt; Unit) &#123; f.invoke()&#125; noinline也只能用于修饰Lambda参数，表示在内联这个函数的情况下，不对这个Lambda进行内联优化（即：依然针对Lambda产生一个匿名内部类对象，开销和Java的就一样了。有些情况编译器无法内联这个Lambda，只能提示你加上noinline。这里不再展开讲解）。 123fun noInlineFunction(noinline f: () -&gt; Unit) &#123; f.invoke()&#125; 因此，请读者尽可能遵循标准规定：仅对接收Lambda的函数使用内联。 扩展函数扩展可谓是Kotlin的“killer feature”，它只是一个语法糖，却是一个（有时）难以理解的语法糖，一般黑带Kotlin程序员会谨慎并大量地使用它。 在IDE的帮助下，扩展对原库的污染已经不再是污染，因为扩展和原方法会被高亮给清晰地区分开。 下文中，有时会把扩展函数称为扩展方法，指的实际上是同一个概念。 普通的扩展函数说了这么多，扩展到底是什么呢？ 就是使用一些语法糖来假装给一些类添加方法，并像真正的方法一样调用它。 为什么要“假装给类添加方法”呢？ 你有种给java.io.File类添加一个openOrCreate方法啊？ （以上调侃并不适用于rt.jar开发人员） 你可能还是不能理解这是什么，那么看看下面的例子吧： 1234567891011fun main(args: Array&lt;String&gt;) &#123; val ls = java.util.ArrayList&lt;Int&gt;() ls.add(233) ls.add(666) ls.add(555) ls.add(1024) val sum = ls.fold(0) &#123; sum, value -&gt; sum + value &#125; println(sum)&#125; 以上代码使用Kotlin1.1第一个正式版编译器编译通过。在JRE1.8_101上完美运行。 你肯定知道，java.util.ArrayList是没有fold这个方法的。 那上面的代码是怎么回事？为什么我可以在ls对象上调用一个它本来没有的方法呢？ 这完全符合刚才的定义： 像真正的方法一样调用它。 那么我们来看看这个方法怎么实现吧。这里不使用集合框架，而是使用另一个例子：给File类增加一个openOrCreate方法。 首先，我们可以这样： 123fun openOrCreate(file: java.io.File) &#123; if (!file.exists()) file.createNewFile()&#125; 然后这样调用它： 123fun main(args: Array&lt;String&gt;) &#123; openOrCreate(File(\"./save.txt\"))&#125; 但是如果我们希望一种更优美的方式，我们可以使用这个语法： 123fun File.openOrCreate() &#123; if (!exists()) createNewFile()&#125; 卧槽！那个if (!exists())看起来就像是直接写在File类内部的方法一样啊！ 其实这里是个小小的trick，编译器会这样处理它： 123fun openOrCreate(receiver: File) &#123; if (!receiver.exists()) receiver.createNewFile()&#125; 也就是说，如果将fun openOrCreate(receiver: File)写成fun File.openOrCreate()，那么这个函数可以直接调用File类的方法，就像它自己也是一个File类的方法一样。编译过后它会被处理为对receiver的方法调用。 也就是说，这种扩展方法是不能调用private、protected以及internal的属性/方法的（因为它事实上就是一个普普通通的函数罢了）。 我们来看看它的调用吧： 1234fun main(args: Array&lt;String&gt;) &#123; val file = File(\"./save.png\") file.openOrCreate()&#125; 是不是很有趣啊？ 而且，在意识到了这只是一个普通方法后，你可能会问：能不能将它当成普通函数而不是方法运行呢？ 当然。。。。。不可以： 1234fun main(args: Array&lt;String&gt;) &#123; val file = File(\"./save.png\") openOrCreate(file) // error&#125; 当然，你也可以在一个类里面对另一个类进行扩展： 1234567891011class A(val int: Int)class B &#123; fun A.someFunction() &#123; println(int) &#125; fun anotherFunction() &#123; val a = A() a.someFunction() &#125;&#125; 这也是合法的。 在一个扩展函数内部，this所指向的就是receiver。 123fun File.openOrCreate() &#123; if (!this.exists()) this.createNewFile()&#125; 读者可以通过在扩展函数内部调用println(this)来验证。 扩展Lambda其实扩展还有一种用途，就是使一个Lambda成为“扩展Lambda”： 12345fun main(args: Array&lt;String&gt;) &#123; val extensionLambda = Int.&#123; println(this) &#125; 233.extensionLambda() // OK extensionLambda(233) // OK&#125; 看到了吗？Lambda表达式也可以被理解为是“对一个类进行扩展的Lambda”表达式。也就是说，它也可以像扩展方法一样，从内部拿到一个特定的this，然后将它作为一个扩展使用。 扩展Lambda也可以作为一个函数的参数。 不同于扩展函数，扩展Lambda可以被当作一个非扩展Lambda。 12345fun applyToFile(block: File.() -&gt; Unit) &#123; val file = File() file.block() // OK block(file) // OK&#125; 这么写，没人拦着你，我不会拦着你，编译器也不会拦着你。这个代码和上面的代码都是合法的Kotlin代码。 注意，以上代码仅为演示语法，是没有实际意义的。 我们还可以结合扩展函数和扩展Lambda：将一个扩展Lambda作为一个扩展函数的参数。 1234fun File.run(block: File.() -&gt; Unit) &#123; this.block() // OK block(this) // OK&#125; this一般可以省略，所以有： 123fun File.run(block: File.() -&gt; Unit) &#123; block()&#125; 还可以结合Kotlin的“expression body”： 1fun File.run(block: File.() -&gt; Unit) = block() 在调用的时候，可以再结合一下Kotlin的Lambda参数语法糖： 123456fun main(args: Array&lt;String&gt;) &#123; val file = File(\"./save.log\") file.run &#123; if (!exists()) createNewFile() &#125;&#125; 这相当于是给File类提供了一个run的工具函数，它可以把一个Lambda应用到file对象。 请读者确保自己能读懂以上代码，它用到了很多Kotlin的（比较）高级的特性： 扩展函数 扩展Lambda Lambda作为最后一个参数的简化写法 到这里就结束了吗？ 不，你可能已经相到了另一个JVM支持的特性，它和扩展结合起来能做到更优美。 还记得吗？这是JVM很早就引入的一个特性。 泛型。 泛型扩展首先考虑如下代码： 123fun &lt;T&gt; runWith(receiver: T, block: T.() -&gt; Unit) &#123; receiver.block()&#125; 这个函数用泛型抽象了一个“runWith”的概念，也就是说传入一个对象和一个扩展给该对象的类型的Lambda，然后在这个对象上调用这个Lambda： 123456789101112fun main(args: Array&lt;String&gt;) &#123; val file = File(\"./save.svg\") runWith(file) &#123; if (!exists()) createNewFile() &#125; val int = 233 runWith(int) &#123; if (this &lt;= 100) println(\"smaller than 100, or equaled.\") else println(\"bigger than 100.\") &#125;&#125; 我们再结合扩展： 123456fun &lt;T&gt; T.run(block: T.() -&gt; Unit) &#123; block() // OK this.block() // OK block(this) // OK block.invoke(this) // OK&#125; 上面展示了四种截然不同但是完全等价的调用block的方法，读者在抄代码的时候请只保留一个。 这个run变得更玄学了，可以直接在任意类型的任意对象上调用run方法了： 123456fun main(args: Array&lt;String&gt;) &#123; Random().nextInt(200).run &#123; if (this &lt;= 100) println(\"smaller than 100, or equaled.\") else println(\"bigger than 100.\") &#125;&#125; 还记得吗？接收Lambda对象的函数是被建议写为inline的： 123inline fun &lt;T&gt; T.run(block: T.() -&gt; Unit) &#123; block()&#125; 这样省去了Lambda传递的开销，和朴素写法就完全等价了。 所以亲爱的读者，还记得之前提到的集合框架多出来的fold方法吗？这是内置在Kotlin标准库的扩展函数。 Kotlin的标准库，基本由扩展函数组成。它通过扩展，结合Java标准库本身已经有的一个非常强大的集合框架，通过打包后仅仅700kb的jar作为标准库，却非比寻常的强大。 我们来看看其它JVM语言的做法： 语言 做法 Java 做的再烂也是所有JVM语言的爸爸，想打我的人多了去了你算老几 Scala 自己从头造了一个集合框架，通过隐式转换实现和Java标准库的集合框架的无缝衔接，但是开销比较大，不仅仅是运行开销，还有debug开销 Clojure 自己造了一个Lisp风格的集合框架（序列框架），Lisp的语法自带扩展效果 Groovy 相当于是从rt.jar里面抄了一些代码改成Groovy风格的形式，和Java没有互操作 JRuby/Mirah 不存在交互问题，因为这两门语言本身就不适合用于上面几门语言的领域（其实也没有交互） 相比之下，Kotlin这种做法是非常友善的（inline零开销，完美利用rt.jar，而且可以随心所欲地扩展）。 关于扩展是否会污染原库的讨论曾经Kotlin社区有人询问过关于扩展函数是否会污染原库的问题。 JetBrains显然考虑到了这点，他们通过IDE插件将两种方法高亮成了不同颜色，完美区分了普通方法和扩展方法： ide 如果你是IntelliJ IDEA用户，那么应该早就注意到这一点了。 缺省设置是黄色，可以在这里调整： settings","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"http://www.Kotliner.cn/tags/函数式编程/"}]},{"title":"[译]Kotlin 1.1 Event Report","slug":"Kotlin 1.1 Event Report","date":"2017-04-06T15:21:00.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/04/06/Kotlin 1.1 Event Report/","link":"","permalink":"http://www.Kotliner.cn/2017/04/06/Kotlin 1.1 Event Report/","excerpt":"","text":"Kotlin 1.1 版本发布在社区反响很好。为了演示 Kotlin 1.1 的新功能，JetBrains 提供了一个在线活动。所有感兴趣的人都可以观看 Andrey Breslav 的在线直播演示，并在 Q&amp;A 环节获得他们关心的问题的答案。这激发了许多当地社区组织见面会：超过 30 个用户组在 21 个国家举办了线下活动。你可以在这里找到完整的活动列表 Kotlin社区网页 。活动当天有 3000 多人参加了线上直播。演示和 Q&amp;A 视频可以在 YouTube 上查看： Kotlin 1.1 活动反馈如果你看了直播，我们想知道你的想法！请 填写此表格 分享您的反馈。它只需要大约7-10分钟。您的投入对于帮助我们改进未来的 Kotlin 活动非常重要。 Kotlin 未来特性调查 我们还向所有社区提供了对 Kotlin 未来的影响。活动组织者收到了调查表，活动参与者可以在线下对最期望的功能发表看法。调查得到很多关注，我们现在已经把它放在网上，以听取更广泛的社区建议。现在你可以在线给 Kotlin 的未来提供你的建议 ！请注意，你在 v1.2 中有很大可能看不到这些功能，但我们会在确定工作优先级时考虑您的意见。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"[译]Kotlin 1.1 也适用于 Android 开发者","slug":"Kotlin 1.1 is also for Android Developers","date":"2017-04-05T08:13:00.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/04/05/Kotlin 1.1 is also for Android Developers/","link":"","permalink":"http://www.Kotliner.cn/2017/04/05/Kotlin 1.1 is also for Android Developers/","excerpt":"Kotlin 1.1的发布令人们感到非常兴奋。此版本包含的新功能对 Java 开发者非常有用，并将 引领 JVM 走向一个充满发展潜力的新世界。\n但有些新功能，如 coroutine 和 type alias（下文有几个例子）对于 Android 开发者来说就像科幻小说。\n我们仍然停留在几乎没有什么改进的古老 Java 6 中，迫使我们以其他平台已经被被遗忘的方式进行开发。\n所以一个理所当然的问题是：Kotlin 团队能够保持与 Java 6 的兼容性，同时保留所有这些新功能吗？答案是：当然！\n所有新特性仍然兼容 Java 6 为 Android 开发者所用。 今天我想向您展示其中的一部分，看看它们是如何使你更容易的开发 Android 应用程式。","text":"Kotlin 1.1的发布令人们感到非常兴奋。此版本包含的新功能对 Java 开发者非常有用，并将 引领 JVM 走向一个充满发展潜力的新世界。 但有些新功能，如 coroutine 和 type alias（下文有几个例子）对于 Android 开发者来说就像科幻小说。 我们仍然停留在几乎没有什么改进的古老 Java 6 中，迫使我们以其他平台已经被被遗忘的方式进行开发。 所以一个理所当然的问题是：Kotlin 团队能够保持与 Java 6 的兼容性，同时保留所有这些新功能吗？答案是：当然！ 所有新特性仍然兼容 Java 6 为 Android 开发者所用。 今天我想向您展示其中的一部分，看看它们是如何使你更容易的开发 Android 应用程式。 type alias 使你的 listener 更易读当然 type alias 有很多不同的应用场景，不过我首先想到的是使用 lambda 作为 listener 的类型时会使代码更易读。 如果没接触过 type alias 的话，可以简单的理解为给复杂的类型名起个别名，使其更为可读。 例如你有个接收 listener 的 RecyclerViewAdapter。RecyclerView 没有 ListView 那样 标准的方式来处理条目点击事件，必须由开发者自己实现。 假如我们希望有一个可以访问 view 的 listener，那 adapter 可能如下所示： 123class MyAdapter(val items: List&lt;Item&gt;, val listener: (View) -&gt; Unit) : RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;() &#123; ...&#125; 而你的 ViewHolder 可能需要接收该 listener，才能将其分配给 view： 12345class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; fun bind(item: Item, listener: (View) -&gt; Unit) &#123; itemView.setOnClickListener(listener) &#125;&#125; 这不是一个复杂的例子，但是正如你所看到的我们需要重复定义这个 lambda ，会导致这段代码不太好阅读。 但是现在我们可以创建一个代表点击 listener 的 type alias：typealias ClickListener = (View) -&gt; Unit然后在需要的每一个地方使用它：class MyAdapter(val items: List&lt;Item&gt;, val listener: ClickListener)或者fun bind(item: Item, listener: ClickListener) { ... } data class 更强大了data class 可以为我们避免大量的样板代码，但是它不能继承其它类所以某些情况下不可用。 Kotlin 1.1 取消了这个限制，例如 data class 可以定义为 sealed class 的子类了： 12345sealed class UiOp &#123; object Show : UiOp() object Hide : UiOp() data class Translate(val axis: Axis, val amount: Int): UiOp()&#125; 同时 sealed class 可以在父类之外定义，就像这样的： 1234sealed class UiOpobject Show : UiOp()object Hide : UiOp()data class Translate(val axis: Axis, val amount: Int) : UiOp() 在 lambda 中使用 destructuring从 Kotlin 最早的版本开始 data class 就能够使用 destructuring declarations 了，因为它会自动生成 componentX() 方法，借助这些方法可以将 data class 对象拆分成若干变量，如下所示： 123data class Item(val text: String, val url: String) val (text, url) = item 可是在 Kotlin 1.1 之前你并不能在 lambda 上这么做。不过等待结束了！现在可以这么写： 1234fun bind(item: Item) = item.let &#123; (text, url) -&gt; textView.text = text imageView.loadUrl(url)&#125; 这个改进十分适用于操作 Pair 和 Map 等类型的对象 适用与局部变量的 delegated propertydelegated property 已被证明是非常有用的，可以为类中的 property 提供附加的能力。 例如最有用的一个是 lazy property，它会推迟赋值操作，直到变量第一次使用。 但其实 lazy 对于局部变量来说也是十分有用的，而之前 Kotlin 缺乏这个功能。 现在通过 delegated property，我们可以做到： 12345678910fun testLocalDelegation() &#123; val database by lazy &#123; createDatabase() &#125; val cache by lazy &#123; createMemoryCache() &#125; if (mustUseDatabase()) &#123; database.use &#123; ... &#125; &#125; else &#123; cache.use &#123; ... &#125; &#125;&#125; 虽然这个例子可以在没有使用 lazy 的情况下解决，但它有助于理解这个概念。 有一些占用比较多的对象不一定会被使用，可以通过使用 lazy 延迟实例化，直到我们初次使用它。 这时大括号内的代码会被执行，并且将结果缓存下来以备稍后再次使用。 再也不用在 lambda 中定义未使用的变量了在 lambda 中定义了变量但最终没使用情况很常见。 这是因为在 Kotlin 1.0 中没有办法丢弃 lambda 中未使用的参数。 例如使用 delegated property 更新 RecyclerView adapter，我使用了以下代码： 1234var items: List&lt;Content&gt; by Delegates.observable(emptyList()) &#123; prop, old, new -&gt; autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;&#125; prop 变量从未被使用过，这时我们就可以使用下划线来替换它： 1234var items: List&lt;Content&gt; by Delegates.observable(emptyList()) &#123; _, old, new -&gt; autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;&#125; 还有种更糟的情况，如果 lambda 有多个参数，即使你一个也不用还是需要写上所有参数。现在我们可以忽略它们了： 1234var items: List&lt;Item&gt; by Delegates.observable(emptyList()) &#123; _, _, _ -&gt; notifyDataSetChanged()&#125; 不仅可以定义较少的变量，而且代码还变得更易读了，那些有用的变量一眼就能看到。 Coroutinecoroutine 是 Kotlin 1.1 中最令人兴奋的特性。尽管在此版本中带着“实验性”的标签，但 coroutine 功能齐全，你完全可以开始在项目中使用它们。 coroutine 能让你以同步的方式编写异步代码，允许你在某些时候暂停执行并等待结果，同时写下顺序相连代码。 您可能已经知道在 Kotlin 中 coroutine 并不是指一个库或者具体的实现，而是一种能力，通过它能够创建具有 coroutine 特性的库。 因此尽管某些代码看起来可能相似，但重要的是要知道创建这些辅助线程并返回主线程的“齿轮”是什么，这在 Android 中非常重要。 幸运的是 Kotlin 社区的动作很快，已经有几个库引入了 coroutine 方便我们在 Android 上使用。 首先来看看 Jetbrains 官方提供的： kotlinx-coroutines-android 提供了在 Android 上使用 coroutine 的实现。 Anko 在其最新的 beta 版中改写了部分框架引入 coroutine。 还有许多其他第三方库实现了自己的 coroutine 版本： AsyncAwait-Android by Niek Haarman Async / Await by Metalab 如果你在寻找 Retrofit 的 coroutine 版本，那么可以试试 kotlin-coroutines-retrofit by Andrey Mischenko 建议你们使用的时候看看它们是如何实现的，这就是开源的好处。 其它对 Android 开发者有用的东西这个版本还有更多的改进，但是我更想强调一些侧重于 Android 开发的内容。 首先，现在可以通过使用以下配置来启用 Jack 编译器的支持了：jackOptions {true}。虽然 Google 已经宣布放弃 Jack 工具链了，但是如果你对 Java 8 有需求那么会有一点用处，然后等到 Android Studio 2.4 的正式版发布就可以彻底弃用 Jack 了。（从 Android Studio 2.4 Preview 4 版本开始支持所有 Java 7 语言特性，部分 Java 8 语言特性） 另外介绍一个小技巧，就是用 @JvmOverloads 来实现自定义 View 的构造函数，在 Kotlin 中借助参数默认值一个构造函数就能满足自定义 View 的多种构造需求（嗯，很长的一个构造函数） 12345class CustomView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) &#123; ...&#125; 结论Kotlin 1.1 带来了大量的新功能，不禁让人产生为什么还要使用 Java 的想法。 Kotlin 为 Android 开发者带来的好处是毋庸置疑的，从现在开始使用 Kotlin 编写你的 Android 应用吧。 如果你想从头开始学习使用 Kotlin 开发 Android 应用，那么你应该会对 Kotlin for Android Developers 这本书感兴趣。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://www.Kotliner.cn/tags/Coroutine/"},{"name":"Android","slug":"Android","permalink":"http://www.Kotliner.cn/tags/Android/"},{"name":"typealias","slug":"typealias","permalink":"http://www.Kotliner.cn/tags/typealias/"}]},{"title":"Kotlin视频教程","slug":"Kotlin视频教程","date":"2017-04-05T03:40:48.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/04/05/Kotlin视频教程/","link":"","permalink":"http://www.Kotliner.cn/2017/04/05/Kotlin视频教程/","excerpt":"","text":"Kotlin从入门到『放弃』系列 视频教程随着Kotlin越来越成熟稳定，我已经开始在生产环境中使用它。考虑到目前国内资料较少，我录制了一套视频教程，希望以此抛砖引玉，让 Kotlin 在国内火起来。 个人水平有限，不足之处欢迎大家发邮件到 bennyhuo@println.net，谢谢大家！ 介绍视频从2016年10月初开始发布，更新至12月中旬完结。精力有限，后续暂时每周一通过公众号推送 Kotlin 及 Java 生态的一些文章，大家有选题也可以直接联系我，目前已经有两篇是基于大家的反馈撰写的，反馈也比较不错，谢谢大家的关注与支持。 在线收看全部视频（腾讯视频） 下载全部视频（百度云） 关注微信公众号：Kotlin， 获取最新视频更新动态 加入 QQ 群 Kotlin ，162452394： 目录01 Kotlin 简介 简要介绍下什么是 Kotlin，新语言太多了，大家为什么要接触 Kotlin 呢？因为它除了长得与 Java 不太像以外，其他的都差不多~ 02 Hello World 千里之行，始于Hello World！ 03 使用Gradle编写程序简介（可选） 这年头，写 Java 系的代码，不知道 Gradle 怎么行呢？ 04 集合遍历 map 放下 i++，你不知道 map 已经占领世界了么？以前我以为 map-reduce 很牛逼，后来才知道就是数据迭代处理嘛。 05 集合扁平化 flatMap 这个可以说是 map 的一个加强版，返回的仍然是开一个可迭代的集合，用哪个您自己看需求~ 06 枚举类型与When表达式 Kotlin 丢掉了 switch，却引进了 when，这二者看上去极其相似，不过后者却要强大得多。至于枚举嘛，还是 Java 枚举的老样子。 07 在 RxJava 中使用 Lambda 这一期通过一个统计文章中字符数的小程序进一步给大家呈现 Lambda 的威力，也向大家展示一下如何在 Kotlin 当中优雅地使用 RxJava。我不做教科书，所以如果大家对概念感兴趣，可以直接阅读官方 API RxJava 是一个非常流行的 Java Reactive 框架，函数式的数据操作使得 Lambda 表达式可以充分体现自己的优势，比起 Java 的冗长，你会看到一段非常漂亮简洁的代码。建议大家先阅读 RxJava 的官方文章以对其有一些基本的认识。 08 使用 Retrofit 发送 GET 请求 Retrofit 是 Square 的 Jake 大神开源的RESTful 网络请求框架，用它发送请求的感觉会让你感觉爽爆的。我这里还有几篇文章，以及一个我 hack 过的分支 HackRetrofit，有兴趣的童鞋可以一起探讨下~ Android 下午茶：Hack Retrofit 之 增强参数. Android 下午茶：Hack Retrofit (2) 之 Mock Server 深入浅出 Retrofit，这么牛逼的框架你们还不来看看？ 09 尾递归优化 尾递归，顾名思义，就是递归中调用自身的部分在函数体的最后一句。我们知道，递归调用对于栈大小的考验是非常大的，也经常会因为这个导致 StackOverflow，所以尾递归优化也是大家比较关注的一个话题。Kotlin 支持语法层面的尾递归优化，这在其他语言里面是不多见的。 10 单例 单例大家一定都不陌生，只要你动手写一个程序，就免不了要设计出一些全局存在且唯一的对象，他们就适合采用单例模式编写。在 Java 里面，单例模式的写法常见的有好几种，虽然简单却也是涉及了一些有意思的话题，那么在 Kotlin 当中我们要怎么设计单例程序呢？ 11 Sealed Class 枚举类型可以很好的限制一个类型的实例个数，比如 State 枚举有两种类型 IDLE 和 BUSY 两种状态，用枚举来描述再合适不过。不过，如果你想要设计子类个数有限的数据结构，比如指令，指令的类型通常是确定的，不过对于某些有参数的指令每一次都使用同一个实例反而不合适，这时候就需要 Sealed Class。 12 Json数据引发的血案 Json 数据可真是大红大紫一番，它实在是太容易理解了，随着 Js 的火爆它就更加『肆无忌惮』起来。我们在 Java/Kotlin 当中解析它的时候经常会用到 Gson 这个库，用它来解析数据究竟会遇到哪些问题？本期主要围绕 Json 解析的几个小例子，给大家展示一下 Java/Kotlin 的伪泛型设计的问题，以及不完整的数据的解析对语言本身特性的冲击。 13 kapt 以及它的小伙伴们 首先感谢 @CodingPapi，这一期的内容主要来自于他的建议。 Kotiln 对于注解的支持情况在今年（2016）取得了较大的成果，现在除了对 @Inherited 这个注解的支持还不够之外，试用了一下没有发现太大的问题。关于 kapt，官方的文章罗列下来，其中 kapt: Annotation Processing for Kotlin 已经过时了，大家可以阅读下了解其中提到的三个方案 Better Annotation Processing: Supporting Stubs in kapt 提到的实现其实基本上就是现在的正式版 Kotlin 1.0.4 is here 提到了 kapt 的正式发布，需要注意的是，kapt 的使用方法有些变化，需要 apply plugin: &#39;kotlin-kapt&#39; 本期主要通过一个简单的 Dagger2 实例给大家展示了注解在 Kotlin 当中的使用，看上去其实与在 Java 中使用区别不大，生成的源码也暂时是 Java 代码，不过这都不重要了，反正是要编译成 class 文件的。 后面我们又简单分析了一下 Dagger2 以及 ButterKnife 的源码（有兴趣的话也可以看下我直接对后者进行分析和 Hack 的一篇文章：深入浅出 ButterKnife，听说你还在 findViewById？），其实自己实现一个注解处理器是非常容易的，类似的框架还有androidannotations，它的源码大家可以自行阅读。 通过这个例子，我们其实发现 kapt 还是有一些不完善的地方，主要是： 不支持 @Inherited 生成的源码需要手动添加到 SourceSets 中 编译时有时候需要手动操作一下 gradle 的 build 才能生成源码（这一点大家注意下就行了，我在视频中并没有提到） 不过总体来讲，kapt 的现状还是不错的，相信不久的将来这些问题都将不是问题。 14 Kotlin 与 Java 共存 (1) 你想要追求代码简洁、美观、精致，你应该倾向于使用 Kotlin，而如果你想要追求代码的功能强大，甚至有些黑科技的感觉，那 Java 还是当仁不让的。 说了这么多，还是那句话，让他们共存，各取所长。 那么问题来了，怎么共存呢？虽然一说理论我们都知道，跑在 Jvm 上面的语言最终都是要编成 class 文件的，在这个层面大家都是 Java 虚拟机的字节码，可他们在编译之前毕竟还是有不少差异的，这可如何是好？ 正所谓兵来将挡水来土掩，有多少差异，就要有多少对策，这一期我们先讲在 Java 中调用 Kotlin。 15 Kotlin 与 Java 共存 (2) 上一期我们简单讨论了几个 Java 调用 Kotlin 的场景，这一期我们主要讨论相反的情况：如何在 Kotlin 当中调用 Java 代码。 除了视频中提到的点之外还有一些细节，比如异常的捕获，集合类型的映射等等，大家自行参考官方文档即可。在了解了这些之后，你就可以放心大胆的在你的项目中慢慢渗透 Kotlin，让你的代码逐渐走向简洁与精致了。 打赏录制这样一套视频确实是需要花费时间和心血的，如果您觉得它对您有帮助，可以通过微信和支付宝打赏，我将努力将视频做到最好！谢谢！","raw":null,"content":null,"categories":[{"name":"视频教程","slug":"视频教程","permalink":"http://www.Kotliner.cn/categories/视频教程/"}],"tags":[{"name":"视频教程","slug":"视频教程","permalink":"http://www.Kotliner.cn/tags/视频教程/"}]},{"title":"Kotlin 兼容 Java 遇到的最大的坑","slug":"Kotlin 兼容 Java 遇到的最大的坑 ","date":"2017-04-03T07:05:15.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/04/03/Kotlin 兼容 Java 遇到的最大的坑 /","link":"","permalink":"http://www.Kotliner.cn/2017/04/03/Kotlin 兼容 Java 遇到的最大的坑 /","excerpt":"","text":"前言：上周我发了一篇文章Kotlin 遇到 MyBatis：到底是 Int 的错，还是 data class 的错？讲如何解决群里面一兄弟遇到的 data class 与 MyBatis 相克的问题，其中提到了几种外门邪道的方法，也提到了官方的解决思路，有些朋友看了之后还是不太明白，甚至紧接着就有小伙伴在使用 Realm 的时候遇到了类似的问题，看来，我还是得再写一篇来进一步告诉大家，这究竟是个什么问题，以及该如何面对它。 本文源码在 Github：Kotlin-Tutorials 这个项目当中，微信公众号无法添加外链，请大家点击“阅读原文”获取。 一个 Realm 的小例子Realm 在 2016 年与 RxJava、Retrofit 这样的框架一起，在 Android 开发领域内着实小小的火了一把，如果大家对它不了解，没关系，传送门 biu ~ Realm 我们先按照官网的说明配置好 gradle 依赖，话说呀，这互联网发展这么快，新时代的框架一出来，逼格果断就体现在完善的构建和开发生态，你发布的东西还只是一个 jar 包，人家呢，早上了 maven 不说，还要搞几个 gradle 任务来方便你开发： 123456789101112buildscript &#123; ext.kotlin_version = '1.1.1' repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.0' //这里将 realm 的 gradle 插件加入 gradle 构建的运行时 classpath \"io.realm:realm-gradle-plugin:3.0.0\" &#125; &#125; ... 123apply plugin: 'com.android.application' apply plugin: 'realm-android' //应用插件，Realm 会在这里添加自己的一些构建任务 ... 其实 gradle 插件开发也是一个很有意思的话题，如果大家有需要，我后面也可以写几篇文章介绍下（悄悄告诉你们，其实我早就想写了，这不是 kotlin 版的 gradle 还没有正式发布么！）。 有了这个我们就可以开始写个 Realm 的 demo 了。 小明：等等！我还有一事不明，你怎么不添加 realm 的依赖就要开始写 demo 了啊！ 艾玛，要么说小明人家就是明白人呢，我前面写了一大堆，只不过是添加了 gradle 构建的依赖而已，而我们的程序想要使用 realm，必须依赖 realm 的运行时库才行。那这么说我是不是漏掉了什么？当然没有，怎么会呢，我这么聪（dou）明（bi）的人，我可是一步一步照着官网的步骤抄的！ 其实呀，realm 的运行时依赖早在我们 apply plugin 的时候就已经添加进来的， realm-android 这个插件除了添加了一些它需要的 gradle 任务之外，也顺手帮我们把依赖添加了。嗯，就是酱紫，如果有那个同学学（xian）有（de）余（dan）力（teng），可以翻一翻 realm 插件的源码。 来来来，赶紧看 demo，不然有些人该内急了~ 首先在 Application 当中初始化它： 1234567891011class App : Application() &#123; override fun onCreate() &#123; super.onCreate() Realm.init(this) Realm.setDefaultConfiguration( RealmConfiguration.Builder() .deleteRealmIfMigrationNeeded() .schemaVersion(1) .build()) &#125; &#125; 定义一个 User 类： 1data class User(@PrimaryKey var id: Int, val name: String) : RealmObject() 接着我们开始存数据和查数据啦： 1234567891011121314151617add.setOnClickListener &#123; Realm.getDefaultInstance().use &#123; it.beginTransaction() val d = it.createObject(User::class.java, it.where(User::class.java).count()) d.name = \"User $&#123;d.id&#125;\" it.commitTransaction() &#125; &#125; query.setOnClickListener &#123; Realm.getDefaultInstance().use &#123; it.where(User::class.java).findAll().map &#123; Log.d(TAG, it.toString()) &#125; &#125; &#125; 想得挺美，结果呢？编译不通过。 1Error:A default public constructor with no argument must be declared in User if a custom constructor is declared. 无参构造方法这就让我想到上周的文章，那篇文章里面我们其实就发现症结根本不是什么 Int 和 Integer，而是无参构造方法。JavaBean 是 Java 的一个概念，我其实甚至有些觉得 Java 的设计者们通过 JavaBean 这样的概念来弥补语言本身的缺陷——不管怎样，JavaBean 是不能没有无参构造的，。 Kotlin 呢，语言层面就有类似于 JavaBean 的东西，那就是 data class，这俩孩子实在太像了，以至于大家经常把 data class 当做 JavaBean 来使。嗯，你信不信 Kotlin 的设计者也是这么想的呢？当然，用 data class 这样一个名正言顺的“亲儿子”数据类来替代 JavaBean 这么个语言层面没有任何支持和认可的“野孩子”，应该算是 JavaBean 莫大的荣幸了，可问题又出在 Java 语言本身构造方法滥用的潜在问题上了。在 Java 中，构造方法真心是一个很没有存在感的东西，大家总是根据自己的喜好来随意的定义很多个构造方法的版本，而最终忽视掉它们的内在联系，导致没有正常走完初始化逻辑的实例满天飞，这家伙如果是导弹，我估计也不需要解放军就可以直接把台湾给统一了。 说了这么多，我主要是想吐槽两个点：第一个就是 Java 本身语言设计层面几乎没有任何照顾到数据类的体现（可千万别说 clone 和 Serialize），第二个就是 Java 对其对象的实例化过程的把控太过于儿戏。 这两点呢，Kotlin 都做的很好，我现在写 Kotlin 经常被迫认真思考一个类该如何正确初始化，这显然对于我们的程序结构和逻辑梳理有莫大的好处。可是结果呢？Java 时代的那些框架们受不了了。Kotlin 背靠着 Java 这座大山，Java 就像它的父母一样，父母的观念再老再陈旧，Kotlin 也得做好自己该做的，一方面是向现在看来陈旧但在过去已经非常革命的观念致敬，另一方面嘛，如果 Java 不支持个几十万首付，Kotlin 能买得起房吗？ 哇塞，我好能扯啊。 其实想要解决 default public constructor 这样的问题，Kotlin 官方已经想到了，那就是 noarg。嗯，我原以为我提一句 noarg 大家就会知道是什么了，看来是我想的简单了，毕竟这个东西在 1.0.6 才出来，当时我还在介绍这个版本的时候提到了它的使用方法，朋友们可能还没有接触过，没关系，下面我再贴一些写法，大家一看就明白： 首先你要做的就是定义一个注解： 1annotation class PoKo 接着 gradle 配置一下脚本的依赖： 12345678buildscript &#123; ... dependencies &#123; ... classpath \"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version\" ... &#125; &#125; 加了运行时环境，那么我们就可以使用 noarg 插件了： 12345apply plugin: \"kotlin-noarg\" noArg &#123; annotation(\"net.println.kotlin.realm.PoKo\") &#125; 配置完之后，PoKo 这个注解就有了超能力，所有被它标注的类在编译时都会生成一个无参的构造方法，于是我们给 User 加一个 PoKo 的注解： 1@PoKo data class User(...) : RealmObject() 搞定，果断去编译一下！！ final 还是不 final，这是个问题本来兴高采烈的以为不就是个无参构造的问题嘛，结果编译的时候又爆出了新的问题： 1Error:(31, 61) error: cannot inherit from final User 好家伙，这究竟发生了什么。。原来 Realm 在编译的时候生成了一个类： 12public class UserRealmProxy extends net.println.kotlin.realm.User implements RealmObjectProxy, UserRealmProxyInterface 这个类要继承我这个 User 类，结果就报错了。 下面是理（che）论（dan）时间。我们说在 C++ 当中给合适的变量、函数参数、函数返回值甚至函数加上 const 是个好习惯，大家没有意见吧？同样的，Java 当中给那些不变的量、不能被继承的类、不能被覆写的方法加上 final 也是个好习惯，大家也没有意见吧？那么问题来了，大家有几个人这么干了？是不是不到万不得已，才懒得写那个 final 呢，五个字母呢，你是想累死宝宝啊？我就知道 Effective Java 这本书看了也白看，因为大家经常明知道什么是好习惯却还是要对着干，这个不是因为大家不喜欢好习惯，而是因为坚持好习惯需要成本！不瞒各位说，我中午为了坚持午休的好习惯，牺牲了跟组里面的小伙伴一起开黑上分的机会，还得装着拥护“人民ri报”关于“小学生打排位太坑”的评论，我容易么我。。 嗯，扯远了。还是说 final 的事儿，Kotlin 就做的很好，它默认所有的类、变量、方法都是 final 的，想要继承？来，过来申请我给你审批。。。你看，这样从根儿解决问题，我们再也不用为了坚持好习惯而发愁了，因为我们根本不需要坚持，难道你想要坚持坏习惯嘛？ 可是 Java 及其框架们呢？原来到北京买房有钱就行，现在呢，商住都不让买了啊（什么？你说广州都不让卖了？）。那叫一个不适应，这可不是得闹事儿么。 Kotlin 官方考虑到 Java 帮它出首付买房的事儿，想了想算了，还是出个什么插件，解决下这个问题吧，于是 allopen 闪亮登场！allopen 的原理跟 noarg 极其类似，它是在编译器对指定的类进行去“final”化，你别看你写代码的时候 User 还是个 final 的类，不过编译成字节码之后这天呀可就变了。 关于 allopen 的使用，跟 noarg 简直不要太像，先定义一个注解： 1annotation class PoKo // How old r U! 可以跟 noarg 公用同一个注解，也可以自己另外单独定义一个，这个不要紧。 接着 gradle 配置搞起： 12345678buildscript &#123; ... dependencies &#123; ... classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\" ... &#125; &#125; 接着就是应用插件，配置注解一气呵成： 12345apply plugin: \"kotlin-allopen\" allOpen &#123; annotation(\"net.println.kotlin.realm.PoKo\") &#125; 编译运行~ ps：如果加了 allopen 和 noarg 之后编译仍然提示原来的错误，记得狠狠地 clean 一下才行哈。 ## 认真脸：究竟什么是 “坑”前面说了 Kotlin 的两个 “坑”，都是关于 data class 的。有人认为这么说 Kotlin 不公平，毕竟人家 Kotlin 也是可以写出下面的代码的： 1234class User&#123; var id: String? = null var name: String? = null &#125; 尽管你在为 Kotlin 打抱不平，不过如果你真要写这样的代码，我建议你还是用 Java 吧。你不属于 Kotlin。。。 Kotlin 这么美的语言，怎么能写这么丑陋的东西呢？这就好比有人说为什么空类型强转为非空类型一定要两个感叹号呢，用一个不就够了么，两个看起来好丑呀！ 12var user: User? = getUser() user!!.name = \"小明\" //小明，他们说你丑！ 有人回答说：明明这就是丑陋的东西，为什么要美化？掩盖事物的本质只能让事情变得更糟糕！ 我们用 Kotlin 企图兼容 Java 的做法，本来就是权宜之计，兼容必然带来新旧两种观念的冲突以及丑陋的发生，这么说来，我倒是更愿意期待 Kotlin Native 的出现了。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"AllOpen","slug":"AllOpen","permalink":"http://www.Kotliner.cn/tags/AllOpen/"},{"name":"NoArg","slug":"NoArg","permalink":"http://www.Kotliner.cn/tags/NoArg/"},{"name":"Java","slug":"Java","permalink":"http://www.Kotliner.cn/tags/Java/"},{"name":"JavaBean","slug":"JavaBean","permalink":"http://www.Kotliner.cn/tags/JavaBean/"}]},{"title":"Kotlin 遇到 MyBatis：到底是 Int 的错，还是 data class 的错？","slug":"Kotlin 遇到 MyBatis：到底是 Int 的错，还是 data class 的错","date":"2017-03-27T01:26:47.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/03/27/Kotlin 遇到 MyBatis：到底是 Int 的错，还是 data class 的错/","link":"","permalink":"http://www.Kotliner.cn/2017/03/27/Kotlin 遇到 MyBatis：到底是 Int 的错，还是 data class 的错/","excerpt":"","text":"问题出现前不久刚刚应小伙伴的要求拉了个 QQ 群：162452394 (微信群可以加我微信 enbandari，邀大家进群)，上周一的时候在公众号推送了之后一下子就热闹起来了。 话说有个哥们在群里面问了这么一个问题，他用 MyBatis 来接入数据库，有个实体类用 Kotlin 大概是这么写的： 1data class User (var id: Int, var username: String, var age: Int, var passwd: String) 它对应的数据库表是这样的： 1234567CREATE TABLE userinfo( id INT(11) PRIMARY KEY NOT NULL AUTO_INCREMENT, username VARCHAR(45), age INT(11), passwd VARCHAR(45)); 字段顺序也都能对得上。 然后呢，他就配置了这么一条查询语句： 12345&lt;mapper namespace=\"net.println.kotlin.mybatis.UserMapper\"&gt; &lt;select id=\"selectUser\" resultType=\"net.println.kotlin.mybatis.User\"&gt; select * from userinfo where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 对应的 UserMapper 代码如下： 123public interface UserMapper &#123; User selectUser(int id);&#125; 这一切看上去似乎一点儿毛病都没有哇，可一旦他调用 selectUser 方法之后，程序开始抱怨了： 1No constructor found in net.println.kotlin.mybatis.User matching [java.lang.Integer, java.lang.String, java.lang.Integer, java.lang.String] 啥问题呢？找不到构造方法。当时看到这个问题的时候正好手里有活，没有仔细看，周末特意照着写了个 demo，果然。。嗯。。居然找不到构造方法，这就有意思了。 问题探究 ① —— Kotlin 的类型映射按理说，我们的 data class 是有构造方法的，说找不到构造方法倒也有些不公平，应该确切的说是找不到合适的构造方法。前面那句错误信息告诉我们 MyBatis 想要找的构造方法是下面的签名： 1init(java.lang.Integer, java.lang.String, java.lang.Integer, java.lang.String) 我们的 data class 的构造方法呢？ 1init(kotlin.Int, kotlin.String, kotlin.Int, kotlin.String) 嗯，乍一看确实不一样哈，难怪找不到合适的构造方法。这样说对吗？我在之前有篇文章为什么不直接使用 Array 而是 IntArray ？提到 过 Kotlin 的类型映射的问题，kotlin.String 编译之后毫无疑问的要映射成 java.lang.String，而 kotlin.Int 则有可能映射成 int 或是 java.lang.Integer，这么说来我们的 User 的构造方法签名可能是下面这样： 1init(int, java.lang.String, int, java.lang.String) 也可能是这样： 1init(java.lang.Integer, java.lang.String, java.lang.Integer, java.lang.String) 现在通过刚才报的错误来看，映射后的签名毫无疑问的应该是前面那种了，毕竟这里 Int 并没有装箱的需求，为了追求效率，映射成 int 是再合适不过的了。也正是这个原因，MyBatis 才无法找到它想要的构造方法，无法构造出 User 对象，最终导致程序运行失败。 问题探究 ② —— JavaBean 的无参构造JavaBean 是一个很有意思的概念，刚刚接触这个概念的时候都有点儿不敢相信自己的耳朵，一个在 JavaEE 当中举足轻重的概念居然就只是一个有无参构造方法、属性通过 Getter 和 Setter 访问、可序列化和反序列化的 POJO，就这么简单？说实在的，当时真觉得 JavaBean 也没什么了不起的，就像最开始学牛二定律的时候一样，一个只有 4 个字符的定律，料它也不能把洒家怎样——可是实际上呢，它确实把我给怎样了。。 刚刚我们分析错误的时候，很直接的分析了构造方法为什么不匹配的原因，却没有想想为什么要找这个构造方法，试想，如果你用 Java 写这段代码，你肯定会写出类似下面的代码： 12345678public class User&#123; private int id; private String username; private int age; private String passwd; ... 省略 getter 和 setter &#125; 如果不纠结序列化的事儿，这个 User 就是个 JavaBean 是吧，你交给 MyBatis 使用的话也不会出现任何问题—— MyBatis 压根儿不需要找什么构造方法，因为人家根本不需要费那劲，有无参的默认构造方法的话，构造对象实例岂不是轻而易举？ 对咯，MyBatis 其实想要的是一个 JavaBean，一个有默认无参构造方法的类，结果呢，你给人家塞了一个 data class 过去。。 解决方案 ① —— 我就用 Integer 了怎么着吧这个问题有一个最为直接的解决办法，那就是直接使用 Integer 而不是 kotlin.Int。 1data class User (var id: Integer, var username: String, var age: Integer, var passwd: String) 不过，你一旦这么写了，你就没办法在 Kotlin 当中正常实例化这个类了（在 Java 中可以实例化），所以这种方案堪比七伤拳啊： 1val user = User(1,\"root\", 30,\"\") //error : The integer literal does not conform to the expected type Integer 解决方案 ② —— kotlin.Int 什么时候映射为 Integer如果 kotlin.Int 能够映射成 java.lang.Integer，那么这问题就彻底解了。试想一下，什么情况下 int 不好使，非得用 Integer？ 整型作为泛型参数的时候 可以为 null 这两种情况显而易见的需要 Integer 出马了，比如你想将一堆整数放入 ArrayList 当中，你只能这么搞： 12ArrayList&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;();... 还有一种就是整型值可能为 null 的时候，毕竟作为基本类型的 int 连默认值都是 0，怎么会为 null 呢？ 回到我们的问题，如果能让 data class 的 Int 映射为 Integer，那么构造方法应该是妥妥的了： 1data class User (var id: Int?, var username: String, var age: Int?, var passwd: String) 我们把构造方法当中的 id 和 age 的类型做了修改，从不可为空的 Int 改为可为空的 Int？，这样编译之后就只好映射为 Integer了。 问题解决~ 这个方案的优点就是几乎没有额外的依赖或者其他什么开销，只是后续编码时，你会总是被迫对 id、age 这几个属性进行是否为空的判断，这样看起来一点儿都不美。 解决方案 ③ —— 默认参数其实就像我们前面提到的，如果 User 这个类有个无参构造的话，后面查找其他构造方法的事儿就压根儿不会有。也就是说如果我们给 User 类加一个无参构造，这个问题也是可以解决的： 123456class User &#123; var id: Int = 0 lateinit var username: String var age: Int = 0 lateinit var passwd: String&#125; 如果这样写的话，我们就无法享受 data class 带来的书写便利了。。不过如果我们能够骗过 MyBatis 说我们这个类有无参构造，那么问题不就解决了？ 1data class User (var id: Int = 0, var username: String = \"\", var age: Int = 0, var passwd: String = \"\") 我们为每一个参数加了默认值， 这样编译出来之后，字节码当中就真的会看到有无参构造方法了： 1234567891011121314public &lt;init&gt;()V L0 ALOAD 0 ICONST_0 ACONST_NULL ICONST_0 ACONST_NULL BIPUSH 15 ACONST_NULL INVOKESPECIAL net/println/kotlin/mybatis/User.&lt;init&gt; (ILjava/lang/String;ILjava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V RETURN L1 MAXSTACK = 7 MAXLOCALS = 1 实际上我们也可以通过反射来获得到这个无参的构造方法，也正是因为如此，我们也可以直接用 newInstance 方法来构造 User 实例： 1User::class.java.newInstance() 既然有了无参构造方法，MyBatis 就不需要绞尽脑汁还要找其他的构造方法，于是问题解决~ 这个方案的优点是，比较简单，也没有上一个方案那样的副作用；缺点就是，万一某一个属性没有默认值，你该给它设置什么呢？ 解决方案 ④ —— 官方也认为有时候我们需要一个无参构造早在 1.0.6 发版的时候，官方就增加了对无参构造的一种另类支持，即 noarg 插件。Kotlin 原本不需要这么做，但考虑到它与 Java 解不开理还乱的关系，Java 支持的一切代码的写法 Kotlin 也似乎有责任和义务来完全支持了。 这个方法其实是 Kotlin 编译插件在编译器通过字节码织入的方式向 class 文件中写入了一个无参构造方法，这个构造方法由于出现的时间比较晚，我们无法在代码中引用到它，不过却可以通过反射访问到它，这样就即保证了 Kotlin 的初心不变，如果你愿意用 data class 或者类似的实体类，那么你就要按照 Kotlin 的要求妥善处理好它的成员的初始化，也方便了一些框架的“出格”行为，显然一个聪明的框架需要对代码本身有足够的理解，对编码人员的限制对于框架本身来说就显得没有那么的重要了。 如果你遇到了这样的问题，我当然建议你采用官方的这个解决方案，原因很简单，除了要写一个注解之外，几乎没有任何副作用，另外，官方支持的方案自然也比较有保障啦。 拓展延伸 —— 不择手段创建实例说起来我就要批评一下 MyBatis 了，一点儿都不如 Gson 流氓。我们前面虽然没有细说，不过大家基本上可以知道 MyBatis 是如何创建返回结果的实例的： 123456789101112 private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix) throws SQLException &#123;... &#125; else if (resultType.isInterface() || metaType.hasDefaultConstructor()) &#123; //有无参构造方法的话走的是这个分支 return objectFactory.create(resultType); &#125; else if (shouldApplyAutomaticMappings(resultMap, false)) &#123; //在这里查找与表结构匹配的构造方法，我们之前遇到的错误就在这个方法当中抛出 return createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs, columnPrefix); &#125; ... &#125; 我们看到如果没有找到匹配的构造方法，也没有无参的构造方法，MyBatis 就叹了一口气，放弃了。这样的事情如果交给 Gson，你就会发现完全不一样。我曾在12 Json数据引发的血案这一期当中介绍过 Gson 如何创建实例，它甚至可以让 Kotlin 的不可空类型“赋值”为 null，原因很简单，它在实例化对象的时候也跟 MyBatis 一样，先去找无参构造，找不到就用 Unsafe.allocateInstance 来创建对象，主要这个创建方法非常的底层，你可以简单的理解为只为实例化出来的 Java 对象开辟了对象存续需要的空间，而对应地它的成员没有一个会正常初始化。 1234567891011class Test&#123; init &#123; println(\"init\") &#125; companion object&#123; init &#123; println(\"cinit\") &#125; &#125;&#125; 注意到这段代码，cinit 将在 Test 类加载时打印，init 将在 Test 实例化时打印。 1234val field = Unsafe::class.java.getDeclaredField(\"theUnsafe\")field.isAccessible = trueval unsafe = field.get(null) as Unsafeunsafe.allocateInstance(Test::class.java) 我们运行这样的程序，结果只有 cinit，难怪人家叫 Unsafe，都告诉你 Unsafe 了你还想要什么。。 不过这在 C++ 当中，简直不叫事儿，不信给你看一段代码： 123456789101112131415161718class Hello &#123;public: int getNum(); int checkNum(int a, int b = 0);&#125;;...int Hello::getNum() &#123; return 12310;&#125;...using namespace std;int main() &#123; cout &lt;&lt; ((Hello*)0)-&gt;getNum() &lt;&lt; endl; return 0;&#125; 我们把一个 0 强转为 Hello 类型的指针，接着还调用人家的函数 getNum，结果你猜怎么着？运行结果还是对的！ 如果你经常接触 Jni，你也经常会把 native 的指针传给 Java，Java 拿到的其实就是一个 long 类型的数，等 Java 需要调用 native 代码的时候，你就会发现这个整数传给 native 层会首先被 reinterpret_cast。 这有什么稀罕的，反正你创建的类也好，对象也好，最终都是数，严格的语法限制也不过是编译器给我们盖起的围墙，你通过围墙来保护你自己，同时也让围墙遮挡了你的眼睛。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"NoArg","slug":"NoArg","permalink":"http://www.Kotliner.cn/tags/NoArg/"},{"name":"JavaBean","slug":"JavaBean","permalink":"http://www.Kotliner.cn/tags/JavaBean/"}]},{"title":"[译]Kotlin 1.1 Event in Your City","slug":"Kotlin 1.1 Event in Your City","date":"2017-03-21T13:51:00.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/03/21/Kotlin 1.1 Event in Your City/","link":"","permalink":"http://www.Kotliner.cn/2017/03/21/Kotlin 1.1 Event in Your City/","excerpt":"","text":"我们将于2017年3月23日进行Kotlin 1.1活动 线上直播。您可以通过JetBrains TV观看Andrey Breslav的演讲，了解Kotlin 1.1的关键特性，包括协程(coroutines)，JavaScript后端等。您也可以使用#kotlinqa在twitter上提出问题，我们将在3月23日直播中的Q&amp;A环节进行解答。为适应不同的时区我们共准备了2个直播流，详情可在博客日志中参阅详细计划与指导 。从下图中了解您所在的城市是否有Kotlin 1.1活动，如果您所在的城市尚未出现在下图中，请单独加入直播。 请注意，美国的直播时间已经更改为PDT(太平洋夏季时间)时间。第一个直播流将于上午9点开始，第二个上午11点开始。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"[译]Kotlin 1.0.7 is out","slug":"Kotlin 1.0.7 is out","date":"2017-03-15T14:21:00.000Z","updated":"2017-05-22T01:47:46.329Z","comments":true,"path":"2017/03/15/Kotlin 1.0.7 is out/","link":"","permalink":"http://www.Kotliner.cn/2017/03/15/Kotlin 1.0.7 is out/","excerpt":"","text":"我们很高兴地宣布Kotlin 1.0.x系列的最后一个更新，Kotlin 1.0.7已经发布了。需要重点关注的是该补丁针对Gradle和annotation processing进行修复，此前无法升级到1.1版本的用户现在可以正常使用了。完整的修复列表可以在更新日志查看。要在Maven或Gradle版本中更新版本，只需在构建脚本中更改Kotlin版本号。命令行编译器会在Github发行页面中下载。在IntelliJ IDEA和Android Studio中，如果您使用Kotlin 1.0.7构建项目，我们建议使用1.1版本的插件，并将语言版本切换为1.0。如果您确实想要安装1.0.7版本的插件，可以在Kotlin插件页面下载相应版本，并通过IDE的“从磁盘安装插件…”按钮进行安装。一如既往，如果您在新版本中遇到任何问题，欢迎您在讨论组或者Slack（在这里获得邀请）里寻求帮助，或在这里提交issue。让我们来享受Kotlin吧！","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"[译]Kotlin 1.1.1 is out","slug":"Kotlin 1.1.1 is out","date":"2017-03-14T12:29:00.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/03/14/Kotlin 1.1.1 is out/","link":"","permalink":"http://www.Kotliner.cn/2017/03/14/Kotlin 1.1.1 is out/","excerpt":"","text":"今天我们发布了针对 Kotlin 1.1 的第一个bug修复更新。此更新的重点是解决导致错误代码生成的回归；我们希望尽可能快地修复此问题。详细内容请查看更新日志 。重点更新如下： 默认情况下，已启用Gradle增量编译。如果需要，您仍然可以按照文档描述禁用此功能。 Kotlin插件现已可以通过Gradle插件依赖添加使用。详情可参阅相关文档。 禁用使用带有接收器的函数类型作为JavaScript外部声明的参数类型。在此之前，传递给这些参数的lambdas没有被正确的参数调用，并且在这个问题上没有简单的解决方法，所以现在我们决定禁用这个功能。 更新后的Kotlin Eclipse 和 NetBeans 插件将支持Kotlin 1.1.1，所以您可以尽情享受Kotlin新版本的优点而无需关注IDE。 如何更新要更新IDEA插件，在菜单栏中依次选择 Tools | Kotlin | Configure Kotlin Plugin Update，然后点击“Check for updates now”按钮。另外，不要忘记在Maven和Gradle构建脚本中更新编译器和标准库版本 命令行编译器可以从 Github发布页面 页面下载。像往常一样，如果您在新版本中遇到任何问题，您可以在 论坛 中寻求帮助，在Slack(获取邀请)、或者在问题追踪器提出问题 。让我们开始吧！","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"Kotlin Script 介绍","slug":"Kotlin Script 介绍","date":"2017-03-13T04:43:19.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/03/13/Kotlin Script 介绍/","link":"","permalink":"http://www.Kotliner.cn/2017/03/13/Kotlin Script 介绍/","excerpt":"","text":"1. 认识 kts打开你的 IntelliJ，随便找个位置，注意我说的，随便找个位置，创建一个文件，命名为 Hello.kts，然后你就会发现 IntelliJ 能够识别这种类型，文件的 icon 与 kt 后缀的 kotlin 文件没啥区别。 那你知道你创建了一个什么东西吗？它究竟与平时我们写的 Kotlin 代码有啥区别呢？其实，从名字我们就可以了解到，这是一个 Kotlin 的脚本文件，我们可以在其中直接写函数调用，逻辑判断，数值计算，干什么都行。 Hello.kts 12345678import java.io.Fileprintln(\"Hello from kts\")val file = File(\".\")file.listFiles().forEach(::println)println(\"The End.\") 这段代码能输出什么呢？ 123456789101112Hello from kts./.gradle./.idea./build./build.gradle./gradle./gradlew./gradlew.bat./Hello.kts./settings.gradle./srcThe End. 我恰好把这个脚本文件放到了一个工程的目录下面，于是它输出了这个工程根目录的所有文件。 2. 命令行调用 kts如果只是在 IntelliJ 当中能够运行脚本，那多没意思。脚本就是要放到命令行跑的，就跟 python 一样，当成 shell 的神助攻来帮我们处理一下任务才好。 IntelliJ 的运行方法当然也是可以的，我们不妨把它的命令复制过来给大家看一下： 1$JAVA_HOME/java -Dfile.encoding=UTF-8 -classpath \"$INTELLIJ_HOME/Kotlin/kotlinc/lib/kotlin-compiler.jar:$INTELLIJ_HOME/Kotlin/kotlinc/lib/kotlin-reflect.jar:$INTELLIJ_HOME/Kotlin/kotlinc/lib/kotlin-runtime.jar:$INTELLIJ_HOME/Kotlin/kotlinc/lib/kotlin-script-runtime.jar\" org.jetbrains.kotlin.cli.jvm.K2JVMCompiler -script /Users/benny/workspace/temp/Forty/Hello.kts 不知道大家看明白没，Kotlin 的编译器或者说脚本运行时环境都是 jar 包，用 Java 直接调用就 OK 了。不过这么复杂的命令我可不想每次都写。 嗨，这你还犹豫什么，赶紧安装 kotlin 的安装包，里面有 kotlinc 和 kotlin 这样的命令，用法几乎与 javac 和 java 一模一样。安装方法点这里。 啊，你说安装好了？那么这时候你运行 kotlinc，是不是会出现一个响应式终端呢？ 跟 Python Scala 之类的一样呢？ 1234$ kotlincWelcome to Kotlin version 1.0.6-release-127 (JRE 1.8.0_60-b27)Type :help for help, :quit for quit&gt;&gt;&gt; 你可以在里面随便敲个运算式啥的，从今天开始，kotlin 也可以成为你的御用“计算器”啦！ 额，扯远了，现在我们该说说怎么运行刚才那个脚本了： 1234567891011121314$ kotlinc -script Hello.ktsHello from kts./.gradle./.idea./build./build.gradle./gradle./gradlew./gradlew.bat./Hello.class./Hello.kts./settings.gradle./srcThe End. 我最初觉得应该是类似 python 那样直接运行，可结果却有点儿让人尴尬。。好吧，随便啦。 12$ kotlin Hello.ktserror: running Kotlin scripts is not yet supported 3. 我的 main 函数去哪儿啦？我们都知道，Java 虚拟机上面的程序入口是 main 函数，嗯，就连 Android dalvik 那个算不上真正意义上的 Java 虚拟机的虚拟机，入口函数也是 main 呢！可是前面的脚本分明就没有 main 函数，还跑得挺欢啊，这简直不能让人相信爱情了（什么？跟爱情有毛关系？！）。。 好吧，这个事儿我们还是要仔细探查一下，不然毁了三观可不好。Java 系的孩子，还是要有点儿信仰的，嗯，信仰 main 的存在~ 且说，我们运行 kotlinc 这个程序，你知道它是什么吗？不知道？没关系，找着它，结果发现丫其实就一 shell 脚本。。我去，搞得这么恐怖，原来就一 shell。。 Mac 版 kotlinc 部分 12345678910...if [ -n \"$KOTLIN_RUNNER\" ];then java_args=(\"$&#123;java_args[@]&#125;\" \"-Dkotlin.home=$&#123;KOTLIN_HOME&#125;\") kotlin_app=(\"$&#123;KOTLIN_HOME&#125;/lib/kotlin-runner.jar\" \"org.jetbrains.kotlin.runner.Main\")else [ -n \"$KOTLIN_COMPILER\" ] || KOTLIN_COMPILER=org.jetbrains.kotlin.cli.jvm.K2JVMCompiler java_args=(\"$&#123;java_args[@]&#125;\" \"-noverify\") kotlin_app=(\"$&#123;KOTLIN_HOME&#125;/lib/kotlin-preloader.jar\" \"org.jetbrains.kotlin.preloading.Preloader\" \"-cp\" \"$&#123;KOTLIN_HOME&#125;/lib/kotlin-compiler.jar\" $KOTLIN_COMPILER)fi 我们看到了什么？org.jetbrains.kotlin.cli.jvm.K2JVMCompiler ？小哥，你看起来好生面熟啊，哪儿见过呢？ 1$JAVA_HOME/java -Dfile.encoding=UTF-8 -classpath \"$INTELLIJ_HOME/Kotlin/kotlinc/lib/kotlin-compiler.jar:$INTELLIJ_HOME/Kotlin/kotlinc/lib/kotlin-reflect.jar:$INTELLIJ_HOME/Kotlin/kotlinc/lib/kotlin-runtime.jar:$INTELLIJ_HOME/Kotlin/kotlinc/lib/kotlin-script-runtime.jar\" org.jetbrains.kotlin.cli.jvm.K2JVMCompiler -script /Users/benny/workspace/temp/Forty/Hello.kts 原来，IntelliJ 运行 kts 用到的命令，在 kotlinc 当中也是一样一样的，嗯哈，这就有意思了，我们运行一段脚本的程序入口原来在 K2JVMCompiler 当中，那我们不妨找着它的源码一看究竟~ K2JVMCompiler 在 Kotlin 源码的 compiler/cli 模块下。 它的入口方法倒也直接了当， 123@JvmStatic fun main(args: Array&lt;String&gt;) &#123; CLICompiler.doMain(K2JVMCompiler(), args)&#125; 原来这只是一个壳而已，我们还是一步步往下追查吧。在追查之前呢，我们需要一点儿想象力，猜测一下 kts 是如何运行的。 首先可以确定的是 kts 并没有 main 函数，所以一种可能是 kotlin 编译器在运行时给它生成一个 main 函数，然后调用它。这里有个问题，如果这个调用时普通 Java 虚拟机程序的那样调用的话，这就意味着 kts 执行的过程会有两个进程存在，一个是我们刚才执行的命令，另一个是以动态生成 main 为入口函数的 kts 文件。 还有一种可能，kts 文件直接编译成一个普通的类，直接在 kotlinc 的运行时中类加载并且运行。 另种方式比较下来，显然第二种最为简单，不过我们在 kts 当中写的代码究竟是作为哪部分代码运行的呢？ “元芳，你怎么看？” “大人所言极是呀！只是小可有一事不明。。。” “你哪儿来那么多事儿。。” 好，猜测完毕，开始查案~ 刚一开始看了两行就给我逗乐了，这个代码跳来跳去的，最后竟然又回到了 K2JVMCompiler.doExecute 方法，接着又到了 KotlinToJVMBytecodeCompiler.compileAndExecuteScript，这里基本上告诉我们 Kotlinc 会直接编译 kts 并且加载运行它。 12345678910fun compileAndExecuteScript( environment: KotlinCoreEnvironment, paths: KotlinPaths, scriptArgs: List&lt;String&gt;): ExitCode&#123; ... val scriptClass = compileScript(environment, paths) tryConstructClassFromStringArgs(scriptClass, scriptArgs) ...&#125; 我们看下这个方法的内容，省略掉异常处理的代码之后，第一句是编译这个 kts ，得到 scrpitClass，这实际上就是一个 Java Class，后面的 tryConstructClassFromStringArgs 则是要实例化这个类，scriptArgs 则是我们在运行这个脚本时传入的其他参数，这里作为脚本生成的类 scriptClass 的构造方法的参数传入。 1234567891011121314fun tryConstructClassFromStringArgs(clazz: Class&lt;*&gt;, args: List&lt;String&gt;): Any? &#123; try &#123; return clazz.getConstructor(Array&lt;String&gt;::class.java).newInstance(args.toTypedArray()) &#125; catch (e: NoSuchMethodException) &#123; for (ctor in clazz.kotlin.constructors) &#123; val mapping = tryCreateCallableMappingFromStringArgs(ctor, args) if (mapping != null) &#123; return ctor.callBy(mapping) &#125; &#125; &#125; return null&#125; 哦，这样我们就明白了，原来 kts 当中的代码其实是被编译成类的构造方法来运行的。这么说来我们还可以给脚本传入参数，在脚本当中引用命令行传入的参数也不难： 12345println(\"Hello from kts, args below: \")args.forEach(::println)println(\"The End.\") 运行输出： 12345$ kotlinc -script Hello.kts X-Man WolfrineHello from kts, args below: X-ManWolfrineThe End. 注意，如果你需要单步调试上面的过程，可以直接在 IntelliJ 当中右键运行 org.jetbrains.kotlin.cli.jvm.K2JVMCompiler，参数填入 -script [kts文件的路径]即可。如果遇到下面的错误： 1Class 'xxx' is compiled by a pre-release version of Kotlin and cannot be loaded by this version of the compiler 确保你的编译环境和 IntelliJ 插件一致的前提下，加入 -Xskip-metadata-version-check 参数来忽略错误即可。 4. 小结通过这篇文章我们不仅知道了 Kotlin 可以支持脚本方式运行，还知道了其运行的原理：编译成一个类，脚本代码作为其构造方法运行，命令行参数作为构造方法的参数传入。 其实前面这段分析本身没有什么难度，它最有价值的地方在于它为我们提供了一个方便快捷了解 Kotlin 内部运行机制的入口，哪里不会断哪里，妈妈再也不用担心我的 Kotlin~","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"KotlinScript","slug":"KotlinScript","permalink":"http://www.Kotliner.cn/tags/KotlinScript/"},{"name":"脚本运行","slug":"脚本运行","permalink":"http://www.Kotliner.cn/tags/脚本运行/"}]},{"title":"快速上手 Kotlin 11招","slug":"快速上手 Kotlin 11招","date":"2017-03-13T04:43:19.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/03/13/快速上手 Kotlin 11招/","link":"","permalink":"http://www.Kotliner.cn/2017/03/13/快速上手 Kotlin 11招/","excerpt":"","text":"最近经常会收到一些 “用 Kotlin 怎么写” 的问题，作为有经验的程序员，我们已经掌握了一门或者多门语言，那么学 Kotlin 的时候就经常会有类似 “ ‘再见’用日语怎么说？”、“ ‘你好’ 用西班牙语怎么说？” 的问题，所以我决定把一些常用的语法对照列举出来，如果大家熟悉 Java，那么快速上手 Kotlin 会变得非常地容易。 这篇文章主要是写给需要快速上手 Kotlin 的 Java 程序员看的，这时候他们关注的是如何 Kotlin 写出类似某些 Java 的写法，所以本文基本不涉及 Kotlin 的高级特性。 1. 如何定义变量Java 定义变量的写法： 1String string = \"Hello\"; 基本等价的 Kotlin 定义变量的写法： 1var string: String = \"Hello\" Java 定义 final 变量的写法： 1final String string = \"Hello\"; 注意到前面的是一个编译期常量，Kotlin 当中应该这么写： 1const val string: String = \"Hello\" 同样是 final 变量，Java 这么写： 1final String string = getString(); 注意到，这个不是编译期常量，Kotlin 这么写： 1val string: String = getString() 另外， Kotlin 有类型推导的特性，因此上述变量定义基本上都可以省略掉类型 String。 2. 如何定义函数Java 当中如何定义函数，也就是方法，需要定义到一个类当中： 123public boolean testString(String name)&#123; ...&#125; 等价的 Kotlin 写法： 123fun testString(name: String): Boolean &#123; ...&#125; 注意到返回值的位置放到了参数之后。 3. 如何定义静态变量、方法Java 的静态方法或者变量只需要加一个 static 即可： 12345678public class Singleton&#123; private static Singleton instance = ...; public static Singleton getInstance()&#123; ... return instance; &#125;&#125; 用 Kotlin 直译过来就是： 123456789class KotlinSingleton&#123; companion object&#123; private val kotlinSingleton = KotlinSingleton() @JvmStatic fun getInstance() = kotlinSingleton &#125;&#125; 注意 getInstance 的写法。 JvmStatic 这个注解会将 getInstance 这个方法编译成与 Java 的静态方法一样的签名，如果不加这个注解，Java 当中无法像调用 Java 静态方法那样调用这个方法。 另外，对于静态方法、变量的场景，在 Kotlin 当中建议使用包级函数。 4. 如何定义数组Java 的数组非常简单，当然也有些抽象，毕竟是编译期生成的类： 12String[] names = new String[]&#123;\"Kyo\", \"Ryu\", \"Iory\"&#125;;String[] emptyStrings = new String[10]; Kotlin 的数组其实更真实一些，看上去更让人容易理解： 12val names: Array&lt;String&gt; = arrayOf(\"Kyo\", \"Ryu\", \"Iory\")val emptyStrings: Array&lt;String?&gt; = arrayOfNulls(10) 注意到，Array T 即数组元素的类型。另外，String? 表示可以为 null 的 String 类型。 数组的使用基本一致。需要注意的是，为了避免装箱和拆箱的开销，Kotlin 对基本类型包括 Int、Short、Byte、Long、Float、Double、Char 等基本类型提供了定制版数组类型，写法为 XArray，例如 Int 的定制版数组为 IntArray，如果我们要定义一个整型数组，写法如下： 1val ints = intArrayOf(1, 3, 5) 5. 如何写变长参数Java 的变长参数写法如下： 123void hello(String... names)&#123; ...&#125; Kotlin 的变长参数写法如下： 123fun hello(vararg names: String)&#123; &#125; 6. 如何写三元运算符Java 可以写三元运算符： 1int code = isSuccessfully? 200: 400; 很多人抱怨 Kotlin 为什么没有这个运算符。。。据说是因为 Kotlin 当中 : 使用的场景比 Java 复杂得多，因此如果加上这个三元运算符的话，会给语法解析器带来较多的麻烦，Scala 也是类似的情况。那么这中情况下，我们用 Kotlin 该怎么写呢？ 1int code = if(isSuccessfully) 200 else 400 注意到，if else 这样的语句也是表达式，这一点与 Java 不同。 7. 如何写 main 函数Java 的写法只有一种： 12345class Main&#123; public static void main(String... args)&#123; ... &#125;&#125; 注意到参数可以是变长参数或者数组，这二者都可。 对应 Kotlin，main 函数的写法如下： 12345678class KotlinMain&#123; companion object&#123; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; &#125; &#125;&#125; Kotlin 可以有包级函数，因此我们并不需要声明一个类来包装 main 函数： 123fun main(args: Array&lt;String&gt;)&#123; ...&#125; 8. 如何实例化类Java 和 C++ 这样的语言，在构造对象的时候经常需要用到 new 这个关键字，比如： 1Date date = new Date(); Kotlin 构造对象时，不需要 new 这个关键字，所以上述写法等价于： 1val date = Date() 9. 如何写 Getter 和 Setter 方法Java 的 Getter 和 Setter 是一种约定俗称，而不是语法特性，所以定义起来相对自由： 1234567891011public class GetterAndSetter&#123; private int x = 0; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125;&#125; Kotlin 是有属性的： 12345class KotlinGetterAndSetter&#123; var x: Int = 0 set(value) &#123; field = value &#125; get() = field&#125; 注意看到，我们为 x 显式定义了 getter 和 setter，field 是 x 背后真正的变量，所以 setter 当中其实就是为 field 赋值，而 getter 则是返回 field。如果你想要对 x 的访问做控制，那么你就可以通过自定义 getter 和 setter 来实现了： 1234567891011121314151617class KotlinGetterAndSetter&#123; var x: Int = 0 set(value) &#123; val date = Calendar.getInstance().apply &#123; set(2017, 2, 18) &#125; if(System.currentTimeMillis() &lt; date.timeInMillis)&#123; println(\"Cannot be set before 2017.3.18\") &#125;else&#123; field = value &#125; &#125; get()&#123; println(\"Get field x: $field\") return field &#125; &#125; 10. 如何延迟初始化成员变量Java 定义的类成员变量如果不初始化，那么基本类型被初始化为其默认值，比如 int 初始化为 0，boolean 初始化为 false，非基本类型的成员则会被初始化为 null。 123public class Hello&#123; private String name;&#125; 类似的代码在 Kotlin 当中直译为： 123class Hello&#123; private var name: String? = null&#125; 使用了可空类型，副作用就是后面每次你想要用 name 的时候，都需要判断其是否为 null。如果不使用可控类型，需要加 lateinit 关键字： 123class Hello&#123; private lateinit var name: String&#125; lateinit 是用来告诉编译器，name 这个变量后续会妥善处置的。 对于 final 的成员变量，Java 要求它们必须在构造方法或者构造块当中对他们进行初始化： 123public class Hello&#123; private final String name = \"Peter\";&#125; 也就是说，如果我要想定义一个可以延迟到一定实际再使用并初始化的 final 变量，这在 Java 中是做不到的。 Kotlin 有办法，使用 lazy 这个 delegate 即可： 12345class Hello&#123; private val name by lazy&#123; NameProvider.getName() &#125;&#125; 只有使用到 name 这个属性的时候，lazy 后面的 Lambda 才会执行，name 的值才会真正计算出来。 11. 如何获得 class 的实例Java 当中： 12345678910public class Hello&#123; ...&#125;...Class&lt;?&gt; clazz = Hello.class;Hello hello = new Hello();Class&lt;?&gt; clazz2 = hello.getClass(); 前面我们展示了两种获得 class 的途径，一种直接用类名，一种通过类实例。刚刚接触 Kotlin 的时候，获取 Java Class 的方法却是容易让人困惑。 123456class Helloval clazz = Hello::class.javaval hello = Hello()val clazz2 = hello.javaClass 同样效果的 Kotlin 代码看上去确实很奇怪，实际上 Hello::class 拿到的是 Kotlin 的 KClass，这个是 Kotlin 的类型，如果想要拿到 Java 的 Class 实例，那么就需要前面的办法了。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"快速上手","slug":"快速上手","permalink":"http://www.Kotliner.cn/tags/快速上手/"}]},{"title":"[译]Kotlin 1.1 Event","slug":"Kotlin 1.1 Event","date":"2017-03-06T09:43:00.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/03/06/Kotlin 1.1 Event/","link":"","permalink":"http://www.Kotliner.cn/2017/03/06/Kotlin 1.1 Event/","excerpt":"","text":"Kotlin 1.1除了为您的项目带来新特性之外，还是您与当地社区进行线下交流学习、了解Kotlin的未来与发展的绝好机会。您可以组织社区的小伙伴们，一起参与Jetbrains团队在3月23日举办的Kotlin直播活动。为了适应不同时区，我们准备了两个直播流，分别是欧洲中部时间[CET]下午5点/7点(太平洋夏季时间[PDT]上午9点/11点)。 告诉我们，我们将在博客上公布。 Kotlin 1.1活动时间： CET时间下午5点/7点(PDT时间上午9点/11点) - Andrey Breslav演讲(Youtube上直播30分钟)，链接将稍候放出。 CET时间下午5点30分/7点30分(PDT时间上午9点30分/11点30分) - 休息30分钟，期间可以自由讨论关于在Kotlin未来版本中您最希望加入的功能或特性，并在Twitter上分享和评论。 CET时间下午6点/8点(PDT时间上午10点/12点) - 与Kotlin团队的互动问答环节(45分钟，直播); 欢迎各位参与讨论与发言。 互动问答环节 从3月21日开始，至3月23日互动环节结束期间，您可以在Twitter上使用#kotlinQA标签向我们提出任何您想要问的问题； Kotlin团队将对问题进行分类; 团队将在Q＆A环节现场回答问题; 如果在会议期间有问题没有答复，我们仍将通过Twitter进行回复 优先回答提问频率最高的问题 Future Features kit本次调查的目的是收集社区用户对语言特征的偏好和需求。您可以提出在Kotlin后续版本中最希望看到的特征或功能；不过这些内容并不保证能在1.2版本中发布，但我们会在确定工作优先级时考虑您的意见。 Kotlin Future Feature Kit包含20张写有功能名称和描述的卡片以及用于投票的贴纸; 将功能卡片粘贴到白板（或墙壁）上; 每位参加者可获得3张（3张）贴纸，可以在功能中自由分配：最多为三种不同的功能进行投票，或者对某一功能投出两票甚至三票; 参加者可以通过阅读卡片的说明了解功能，然后按上所述规则进行投票; 将结果进行拍照; 使用#kotlinevent标签在Twitter上发布 在这里提交你的答案吧","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"Kotlin 1.1","slug":"Kotlin 1.1","date":"2017-03-04T00:46:34.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/03/04/Kotlin 1.1/","link":"","permalink":"http://www.Kotliner.cn/2017/03/04/Kotlin 1.1/","excerpt":"","text":"上周一的文章里面提到 Kotlin 1.1 rc了，还没正式发布，我在周三的时候把文章转到掘金以后，好多小伙伴告诉我，1.1 已经发布了~ tips: 本文有较多外链，公众号阅读时无法跳转，如有需要，请大家点击”阅读原文”。 1、更新要点1.1 Coroutine1.1 最大的更新一定必须毫无疑问的要数 Coroutine 了，尽管在正式发版之前，Kotlin Team 突然虚了，决定把这个特性定为 Experimental，不过这似乎并没有改变什么。不就是改个包名么！！ 早在春节放假那几天，我就在公众号连续两周发文介绍 Coroutine，本来还计划有第三篇的，不过开工以后个项目有点儿累，每天翻 Android 系统 C++ 层的代码翻到吐，也没精力去写第三篇文章，真是抱歉，如果大家有兴趣，可以参考前两篇： 深入理解 Kotlin Coroutine (一) 深入理解 Kotlin Coroutine (二） 其中，第一篇文章写于 experimental 之前，不过大家只要在包名当中加上 experimental 就没问题了。 Kotlin 的 Coroutine 实现主要分为两个层面，第一个层面就是标准库以及语言特性的支持，这里面主要包括最基本的 suspend 关键字以及诸如 startCoroutine 这样的方法扩展，上述第一篇文章对此做了详细的介绍。第二层面则主要是基于前面的基础封装的库，目前主要是 kotlinx.coroutine ，其中封装了 runBlock、launch 这样方便的操作 Coroutine 的 api，这在第二篇文章做了详细地介绍。所以大家在了解 Coroutine 的时候，可以从这两个角度来入手，以免没有头绪。 我们再来简单说说 Coroutine 的运行机制。Coroutine 是用来解决并发问题的，它甚至有个中文名叫“协程”，它看上去跟线程似乎是并发问题的两种独立的解决方案，其实不然。要并发的执行任务，从根本上说，就是要解决 Cpu 的调度问题，Cpu 究竟是如何调度，取决于操作系统，我们在应用程序编写的过程中用到的 Thread 也好，Coroutine 也好，本质上也是对操作系统并发 api 的封装。知道了这一点，我们再来想想 Thread 是如何做到两个线程并发执行的呢？Java 虚拟机的实现主要采用了对内核线程映射的方式，换句话说，我们通常用到的 Thread 的真正直接调度者可以理解为是操作系统本身。那我们在 Kotlin 当中支持 Coroutine 是不是也要把每一个 Coroutine 映射到内核呢？显然不能，不然那跟 Thread 还有啥区别呢？再者，Coroutine 的核心在 Co 上，即各个 Coroutine 是协作运行的，有一种“你唱罢来我登场”的感觉，就是说，Coroutine 的调度权是要掌握在程序自己手中的。于是，如果你去了解 kotlinx.coroutine 的实现，你就会发现 CommonPool 这么个东西，它不是别的，它的背后正是线程池。 线程是轻量级进程，而协程则是轻量级线程。 Coroutine 的出现让 Kotlin 如虎添翼，如果你之前在写 Go，Lua，python，或者 C#，这回 Java 虚拟机家族可不会让你失望了。自从有了协程，你也可以写出这样的代码： 12345678910111213141516val fibonacci = buildSequence &#123; yield(1) // first Fibonacci number var cur = 1 var next = 1 while (true) &#123; yield(next) // next Fibonacci number val tmp = cur + next cur = next next = tmp &#125; &#125; ... for (i in fibonacci)&#123; println(i) if(i &gt; 100) break //大于100就停止循环 &#125; 序列生成器，记得我刚学 python 那会儿看到这样的语法，简直惊呆了。 123val imageA = loadImage(urlA) val imageB = loadImage(urlB) onImageGet(imageA, imageB) 这样的代码也是没有压力的，看上去就如同步代码一般，殊不知人家做的可是异步的事情呐。 协程的出现，让我们可以用看似同步的代码做着异步的事情。 这篇文章我们主要说说 1.1 的发版，Coroutine 的更多内容，建议大家直接点击前面的链接去读我的另外两篇文章~ 1.2 JavaScript 支持真是媳妇儿终于熬成婆，Js 终于被正式支持了。看官方的意思，他们已经用这一特性做了不少尝试，从 Kotlin 从头到尾写一个站点，似乎毫无压力，尽管类似反射这一的特性还没有支持，不过面包会有的嘛。 从我个人的角度来说，也可能我对前端了解太少吧，我觉得应用在前端比起移动端、服务端来说，Kotlin 的前景相对不明朗。我用 JavaScript 用得好好的，为啥要切换 Kotlin 呢？动态特性玩起来挺爽的，虽然回调写多了容易蛋疼，但这也不是不可以规避的。关于 Kotlin 开发前端这个问题，我需要多了解一下前端开发者的看法，相比他们是否愿意接触 Kotlin，我更关心有几个做前端的人知道这门语言。不瞒各位说，前几天跟一个支付宝客户端的大哥聊了一会儿，他问我这个 k o t 什么的，是干啥的。。。我当时在想，看来阿里人对 Kotlin 还不是很熟悉啊。 Whatever，Kotlin 现在都可以支持 node.js 了，还有什么不可能的呢？作为吃瓜群众，且让我观望一阵子。 1.3 中文支持你放心，这一段内容你绝对在其他人那里看不到，因为没人会这么蛋疼。我前几天为了做一个案例用中文写了段代码，想着 Java 支持中文标识符，Kotlin 应该也问题不大。没曾想，写的时候一点儿问题的没，可编译的时候却直接狗带了。 123456789101112package 中国.北京.回龙观 class G6出口&#123; fun 下高速()&#123; println(\"前方堵死, 请开启飞行模式 :)\") &#125; &#125; fun main(args: Array&lt;String&gt;) &#123; val 回龙观出口 = G6出口() 回龙观出口.下高速() &#125; 注意，包名、代码文件名都是中文的，如果用 1.0.6 版编译，结果就是万里江山一片红哇。 1234567Error:Kotlin: [Internal Error] java.io.FileNotFoundException: /Users/benny/temp/testKotlin/out/production/testKotlin/??/??/???/G6??.class (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138) at kotlin.io.FilesKt__FileReadWriteKt.readBytes(FileReadWrite.kt:52) at org.jetbrains.kotlin.incremental.LocalFileKotlinClass ... 注意到，汉字都变成了 ??，瞧瞧编译器那小眼神，真是看得我都醉了。 如果我们用 1.1 的编译器来编译这段代码，结果就可以正常输出： 1前方堵死, 请开启飞行模式。 1.4 其他特性1.1 还新增了不少特性，我在之前的一篇文章就做过介绍：喜大普奔！Kotlin 1.1 Beta 降临~ tpyealias 绑定调用者的函数引用 data class 可以继承其他类 sealed class 子类定义的位置放宽 _ 作为占位，替代不需要的变量 provideDelegate 2、Kotlin 元年2016 年是 Kotlin “元年（First year of Kotlin）”，官网给出了这样一幅图来展示它一年来的成绩： Github 上面的代码量都破千万了，使用 Kotlin 的公司也逐渐增多，除了 JetBrains 自己以外，我觉得在 Java 界比较有分量的就是 Square 了，如果 Google 能够稍微提一句 Kotlin ，显然这个故事就会有另外一个令人兴奋的版本——好啦，不要 yy 啦。 据说，比较著名的主要有Amazon Web Services, Pinterest, Coursera, Netflix, Uber, Square, Trello, Basecamp 这些公司将 Kotlin 投入了生产实践当中。国内资料较少，估计接触的人也不是很多，像百度、腾讯、阿里巴巴、滴滴、新美大、小米、京东这样的公司可能还没有太多的动力去将 Kotlin 应用到开发中，就算开始尝试，也多是在 Android 开发上面试水；而敢于尝试 Kotlin 的，更多是没有什么历史包袱且富于创新和挑战精神的创业团队，对于他们而言 Kotlin 为开发带来的效率是非常诱人的。 说到这里，有两个令人兴奋的消息需要同步给大家： Gradle 开始尝试用 Kotlin 作为其脚本语言，目前已经发到了 0.4.0。这个真的可以有，groovy 虽然是一门很灵活的语言，不过写配置的时候如果没有 IDE 的提示，实在是太痛苦了。大家有兴趣也可以关注一下这个项目：gradle-script-kotlin Spring 5.0 加入 Kotlin 支持，Spring 的地位可想而知，Spring 为 Kotlin 站台，这分量还是很重的。 不知道 2017 年会发生什么，且让我们准备好爆米花饮料，拭目以待吧。 关于 Kotlin 的资料，英文版的图书已经出版了几本，主要有： Kotlin in Action：这部书已经有了纸质版，是官方自己人写的，算是一本比较权威的参考书了。 Kotlin for Android Developers：这本书也算是老资历了，稍微看几眼你就会为 Kotlin 有趣的特性所吸引。另外，它还有一个中文的翻译版本 Modern Web Development with Kotlin：这本书我没有读过，如果你需要用 Kotlin 开发 web 应用，它应该会给予你一些帮助。 Programming Kotlin：这本书涉及内容非常全面，内容也算是言简意赅，快速入门 Kotlin 可以选择它。 除了图书以外， Kotlin 的首席布道师 Hadi Hariri 已经在 O’Reilly 上面发布了两套视频教程： Introduction to Kotlin Programming Advanced Kotlin Programming 里面有免费的几段，且不说内容怎么样，反正考验大家英语听力的时候到了，嗯，老爷子讲得还是很清楚的。 国内的资料，很少。除了有个别小伙伴写的一些博客之外，较为系统的学习资料几乎没有。也难怪大家都不知道它呢。也正是为了弥补这一空白，我在 16 年 10 月的时候开始每周 10 分钟的节奏连续录了 15 期视频，如果你有 Java 基础，那么看这些视频基本上可以让你知道 Kotlin 是怎么一回事了。 Kotlin 中文视频教程 另外，如果你想要对 Kotlin 持续了解，建议你关注微信公众号 Kotlin，每周一推送的 Kotlin 的相关文章，基本上会覆盖了 Kotlin 的各种最新动态。也欢迎大家跟我交流开发中遇到的问题~ 3、Kotlin 时代1.1 的重要的更新其实就 Coroutine 以及 JavaScript 支持，毕竟 Kotlin 对 Java 的兼容支持已经做得非常不错了（别老提 apt 的事儿，1.0.4 之后的 kapt 不就基本上很好用了么）。别人问我，Kotlin 到底是写啥的，这个问题我通常说很官方的说，Kotlin 是一门运行在 Java虚拟机、Android、浏览器上的静态语言，可是，Kotlin Team 的节奏已经让这句话显得要过时了。他们用短短几年时间搞出这么个全栈的语言，各方面特性都还很棒，然而他们并不能感到满足，他们已经开始走 C++ 的路线，也许 Kotlin Native 要不了多久就会出现了。 第一次听到这消息的时候，我瞬间就凌乱了，那感觉就好像王者荣耀里面队友选了大乔一样，秒回泉水加满血，秒回战场收人头啊。 前不久，我很荣幸地跟一位创业公司 CEO 坐下来聊理想，他问我的第一句话就是：你觉得 Kotlin 是未来么？我当时就蒙了，不得不说，他对 Kotlin 的期待跟 Kotlin Team 如出一辙呀。我当时实在不知道该怎么回答他，回来仔细想了想，答案其实也是有的。 十几年前，东家缺钱，急需投资，投资人坐下来“拷问”小马哥：“这个东西（指当时的 OICQ）怎么赚钱？” 小马哥说自己只知道这个东西大家喜欢，但不知道向谁收钱。对于 Kotlin 来说，我只知道它好用，尽管大家都还看不太懂，不过它的时代正在悄悄的到来。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://www.Kotliner.cn/tags/Coroutine/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.Kotliner.cn/tags/JavaScript/"},{"name":"中文支持","slug":"中文支持","permalink":"http://www.Kotliner.cn/tags/中文支持/"},{"name":"Kotlin元年","slug":"Kotlin元年","permalink":"http://www.Kotliner.cn/tags/Kotlin元年/"}]},{"title":"[译]Kotlin 1.1 发布啦！JavaScript，Coroutine 还有更多你想要的","slug":"Kotlin 1.1 Released with JavaScript Support, Coroutines and more","date":"2017-03-01T09:12:00.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/03/01/Kotlin 1.1 Released with JavaScript Support, Coroutines and more/","link":"","permalink":"http://www.Kotliner.cn/2017/03/01/Kotlin 1.1 Released with JavaScript Support, Coroutines and more/","excerpt":"","text":"Kotlin 1.1 今天正式发布了，这让 Kotlin 有能力适用于更多的应用场景，希望大家能够喜欢。 我们希望 Kotlin 能够在应用的任何组件中成为独立的、富有表现力且性能强大的强类型语言，Kotlin1.1 为了实现这一目标迈出了巨大的两步。 首先，JavaScript 支持的“试验性”标签已被移除，并且支持所有 Kotlin 语言特性、标准库的大部分内容以及 JavaScript 互操作性。这意味着开发者可以完全使用 Kotlin 来编写整个 WEB 应用，同时继续使用 JavaScript 的开发框架（比如 React）。 其次，我们引入了协程(coroutines)的概念。作为线程的轻量级替代方案，协程在应用程序后端可以具有更大可扩展性，从而支持单个 JVM 实例上的大量工作负载。除此之外，协程对于实现异步行为具有强大的表现力，这对于在任何平台上构建响应式用户交互界面而言极其重要。 下面我们将进一步介绍这两大功能。其他部分如type aliases，callable references，destructuring in lambdas等详情可在最新消息查看，试试完整的可运行示例代码！ 协程(Coroutines)在 Kotlin 中协程使非阻塞式异步代码与同步代码一样易于理解。 异步编程正当风靡，唯一让我们思虑的是，非阻塞式代码大量增加了系统的复杂性。 而 Kotlin 现在提供了简化这种复杂性的方法，通过单原子让协程在语言中成为一等公民：挂起函数。这种类型的函数（或 lambda）表示在计算运行中可以被挂起（不阻塞任何线程），而后也能继续恢复运行。 从技术上说，协程是多任务协作的轻量级解决方案（类似于fibers)）。换言之，他们只是更好的线程：可以任意的启动和保留，且挂起的消耗极其之低（挂起之于协程，如阻塞之于线程），非常易于组合与订制。 我们对于协程的设计以实现最大的灵活性为目标：在语言中固化的部分少，而且可以作为库来实现很多功能。kotlinx.coroutines项目在 Rx，CompletableFuture，NIO，JavaFx 和 Swing 上均有设计功能库，甚至可以为 Android 和 JavaScript 编写类似的库。即使在其​​他语言中许多内置构建现在也可以用 Kotlin 库来编写。包括 Python 的 generators/yield，来自 Go 的 channels/select 以及 C＃的 async/await: 12345678910111213141516// runs the code in the background thread poolfun asyncOverlay() = async(CommonPool) &#123; // start two async operations val original = asyncLoadImage(\"original\") val overlay = asyncLoadImage(\"overlay\") // and then apply overlay to both results applyOverlay(original.await(), overlay.await())&#125; // launches new coroutine in UI contextlaunch(UI) &#123; // wait for async overlay to complete val image = asyncOverlay().await() // and then show it in UI showImage(image)&#125; 查看完整内容。 重要提示：凭借上述的这些优势，Kotlin 协程近乎全新的设计，在我们能确定这是 100％正确和完整之前，仍然需要大量的实践和测试。因此我们才选择在“实验性”标志下发布。我们不希望语言规则发生变化，但 API 可能需要在 Kotlin 1.2 中进行调整。 JavaScript 支持如上所述，Kotlin 1.1 中的所有语言特性（包括协程）都适用于 JVM / Android 和 JavaScript（JavaScript 的反射目前不可用，但我们正在这方面努力）。这意味着 Web 应用程序可以完全使用 Kotlin 编写，而且我们已经在 JetBrains 内部有一些尝试，相信很快就会发布教程和其他资料。 Kotlin for JavaScript 具有与“源生”JavaScript 代码进行互相操作的动态类型，通过类型 API 可以使用ts2kt converter以及DefinitelyTyped等知名库。 我们支持 Node.js 和浏览器。 Kotlin 标准库可通过npm使用。文档链接 。 工具Kotlin 1.1 并不是 Kotlin 工具发布的主版本：我们更喜欢具有这些功能的工具就绪后，不会对语言本身产生影响，所以我们在 Kotlin 1.0.x 版本中的有许多这样的改进： 主流 IDE 的 Kotlin 插件：IntelliJ IDEA，Android Studio，Eclipse 和 NetBeans IntelliJ IDEA 和 Gradle 中的增量编译 Spring，JPA 和 Mockito 的编译器插件（all-open 与 no-arg） 注解处理器 kapt 对 Android 项目的支持 Lint 检查 大量的 IDE 代码预测，检查，快速修复，重构和自动完成提升 我们将继续在 1.1.x 版本中进行更新，努力为开发者们提供更好的工具。 Kotlin 元年：迁移与社区总而言之，Kotlin 正在逐渐壮大。去年，我们看到有超过 160,000 人使用，Github 上的 Kotlin 开源项目从 2.4M 增加到 10M（约 4 倍）。我们的 Slack 社区已经从 1,400 人增长到超过 5,700 人（超过 4 倍）。世界各地均有社区组织了众多的线下交流以及用户群组，我们也看到越来越多的 Kotlin 书籍和在线课程发布。 Kotlin 在服务器端和 Android 端（开发人员数量均等）表现异常强大。 Spring 框架 5.0和vert.x 3.4均引入了对 Kotlin 的支持。 Gradle和TeamCity正在使用 Kotlin 构建脚本。更多使用 Kotlin 的项目可以在kotlin.link查看。 许多知名公司也正在使用 Kotlin：Pinterest，Coursera，Netflix，Uber，Square，Trello，Basecamp；除此之外， 由知名银行（如高盛，富国银行，摩根大通，德意志银行，瑞银，汇丰银行，法国巴黎银行，SociétéGénérale）联盟开发的分销账户分类账户Corda，其代码库中有超过 90％的部分使用 Kotlin。我们感谢世界各地的所有用户，贡献者和倡导者。您的支持对我们非常重要！ 组织您自己的 Kotlin 1.1 活动Kotlin 1.1 的发布是与当地社区好友线下聚会的好话题。我们已经准备了一些资料来帮助开发者们举办此类活动。3 月 23 日，我们将以 Kotlin 团队成员的形式进行现场直播，发起人均可获得一个背包，里面有一份关于未来特性的调查问卷和一些小礼物，点击注册即可参与。 后续为了使 Kotlin 成为真正的全栈语言，我们将为多个平台编译相同的代码提供工具和语言支持。这将有助于在客户端和服务器之间进行模块共享。我们将继续致力于改进 JavaScript 工具和库的支持。除此之外，JavaScript 平台的增量编译正在进行中。请继续关注 1.1.x 更新。 Java 9 即将推出，我们将在发布之前为其新功能提供支持。 我们期望在未来几个月内能够收到许多关于协程反馈意见，改进这一领域（在性能和功能方面）对于我们优先级最高。除此之外，下一版本的主要工作将集中在维护，性能改进，基础架构和错误修复方面。P.S 跨平台运行是 Kotlin 的战略方向，伴随着 1.1 的发布，我们可以在服务器，台式机，Android 设备和浏览器上运行，但是未来我们将把 Kotlin 编译为本地代码，并使之能够在更多平台（例如 iOS 和嵌入式设备等）上运行。 目前在 JetBrains 内部，有一个非常棒的团队正在开展这个项目，我们期待很快就会出现有趣的东西，不过尚未计划为此专门发布任何版本。 安装说明与以往一样，开发者可以使用Kotlin 线上编辑器 try.kotlinlang.org。 Maven/Gradle：使用1.1.0作为编译器和标准库的版本号(查看文档)。 IntelliJ IDEA：2017.1 已包含 Kotlin 1.1；旧版本则需要安装 Kotlin 插件或更新到 1.1 版本。 Android Studio：通过Plugin Manager安装或更新插件。 Eclipse：使用Marketplace 安装插件。 命令行编译器可以从Github 发布页面下载。 兼容性：Kotlin 1.1 语言和标准库向后兼容(modulo bugs) ：如果使用 1.0 版本编译运行，1.1 版本仍然可以运行。为了帮助大型团队有规律的更新，我们在编译器中新增禁用新功能的开关。查看踩坑文档。 请尽情享受 Kotlin！ P.S: 在Reddit和Hacker News上加入讨论吧！","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"高阶函数（二）","slug":"高阶函数（二）","date":"2017-02-27T06:41:00.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/02/27/高阶函数（二）/","link":"","permalink":"http://www.Kotliner.cn/2017/02/27/高阶函数（二）/","excerpt":"","text":"上周我已经给大家推送了一篇关于高阶函数的文章，这一期，我们继续探讨一些相关的有意思的话题。 1 复合函数大家一定见过下面的数学题吧： \\[求 f(g(x)) 的值。解： 设 m(x) = f(g(x)) …\\]m 就是 f 和 g 的复合。 我们在 Kotlin 当中要如何对函数进行复合呢？ 12val add5 = &#123; i: Int -&gt; i + 5 &#125;val multiplyBy2 = &#123; i: Int -&gt; i * 2 &#125; 我们定义了这么两个函数，接着这么调用它： 1println(multiplyBy2(add5(2))) // (2 + 5) * 2 add5 相当于我们的 g(x)，multiplyBy2 相当于 f(x)，那么上面的式子就相当于 f(g(x))。下面我们提供一个简单的方式来复合这两个函数，得到 m(x) = f(g(x))： 123456// f andThen g -&gt; g(f(x))infix fun &lt;P1, P2, R&gt; Function1&lt;P1, P2&gt;.andThen(function: Function1&lt;P2, R&gt;): Function1&lt;P1, R&gt; &#123; return fun(p1: P1): R&#123; return function.invoke(this.invoke(p1)) &#125;&#125; 这里面有几个知识点，我请大家一起复习一下。 第一个就是 infix，中缀表达式，有了这个关键字，我们的 add5 在调用 andThen 方法时，就不需要用 .andThen() 的形式了，而是像使用操作符一样。 第二个是扩展方法，andThen 其实就是 Function1 的扩展方法。 第三个则是 Lambda 表达式的类型了，我们在前面提到过，Lambda 表达式有 N （N &lt;= 22）个参数，那么它的类型就是 FunctionN，这里的 add5 只有一个参数，所以对应于 Function1 类型。 第四个是匿名函数，这个我们前面其实已经见到不少了。 我们看一个例子： 12val add5AndMultiplyBy2 = add5 andThen multiplyBy2println(add5AndMultiplyBy2(2)) 这个例子的输出结果其实与前面的相同， ( 2 + 5 ) * 2 = 14 通过 andThen，我们看到一个全新的函数 add5AndMultiplyBy2 被创造出来，它其实就是 add5 和 multiplyBy2 的复合。 当然，有时候我们其实还需要这样的结果： 12val multiplyBy2AndAdd5 = add5 compose multiplyBy2println(multiplyBy2AndAdd5(2)) 这个相当于 2 * 2 + 5 = 9。 我们简单看下 compose 的实现： 123456// f compose g -&gt; f(g(x))infix fun &lt;P1, P2, R&gt; Function1&lt;P2, R&gt;.compose(function: Function1&lt;P1, P2&gt;): Function1&lt;P1, R&gt; &#123; return fun(p1: P1): R&#123; return this.invoke(function.invoke(p1)) &#125;&#125; compose 与 andThen 的结果是完全相反的， 1f andThen g -&gt; g(f(x)) 而 1f compose g -&gt; f(g(x)) 这就是函数复合，其实你在初中数学就学过这些东西了。 2 CurryingCurry 也有咖喱的意思，不过这一节可并不是充满咖喱味的。在函数式编程当中，Currying 也经常被翻译成“科里化”，我们从这个名字完全读不出它究竟是要干啥。为什么？因为，Curry 是个人名——Haskell Curry。 回到我们的程序当中，我们首先必须要搞清楚什么是 Currying？Currying 其实就是由一个多参数的函数构造出一系列只有一个参数的函数的方法。这么说可能还是有些抽象，我们直接上例子： \\[ f(x,y,z) = x * y - z\\] 我们有一个三元函数，这个没什么复杂的，你在高中数学当中见到过比这个恐怖的多的式子。接着我们给它做个变式： \\[f(x,y,z) = k_{yz}(x)\\] 其中，\\(k_{yz}(x)\\) 是关于 \\(x\\) 的一个函数，\\(yz\\) 可当做常量看待。而一旦传入 \\(x\\) 的值以后，例如 \\(k_{yz}(x_0)\\) ，那么此时又有变换： \\[f(x_0,y,z) = k_{yz}(x_0) = m_{z,x=x_0}(y)\\] 类似的，我们还能最终变换成：\\[f(x_0,y_0,z) = m_{z,x=x_0}(y_0) = n_{x=x_0, y=y_0}(z)\\] 这么一个数学概念，其实就是 Currying。那么它到底想说明怎样一件事情呢？大家看，参数是一个一个传进来的，这就好比我们完成一件事情，也是对其进行肢解，然后一步一步完成的，通过 Currying，我们可以对一个函数的调用细节进行仔细的考量，甚至像流水线一样处理，以实现我们的目标。 用程序的语言描述，假设我们有一个函数： 123fun hello(x: String, y: Int, z: Double): Boolean&#123; ...&#125; 它 Currying 的结果便是： 123fun curriedHello(x: String): (y: Int) -&gt;(z: Double)-&gt; Boolean&#123; ...&#125; 下面我们给出一个 Kotlin 的例子： 123fun log(tag: String, target: OutputStream, message: Any?)&#123; ...&#125; 这是一个日志打印的函数，第一个参数 tag 是一个日志的标识，第二个参数是日志的内容，第三个参数是日志打印的目标，这个可以是控制台，也可以是文件，由调用者指定。 显然，我们通常调试时，输出日志都是直接到控制台的，于是我们定义一个新函数： 1fun consoleLog(tag: String, message: Any?) = log(tag, System.out, message) 由于我们可能针对某一个问题不断地调试，这些日志的 tag 也是相同的，那么我们又会定义一个新函数： 123val TAG = ......fun consoleLogWithTag(message: Any?) = log(TAG, System.out, message) 这样看上去似乎没什么问题，不过你有可能会想，我不过是临时打几行日志，真的有必要定义这么多函数？调试一段代码还好，调试的内容多了呢，而且他们的 tag 都还不一样，难道我要定义 consoleLogWithTag2 、consoleLogWithTag3 … 么？ 显然，如果你运用 Currying，问题就简单的多了，只不过是定义一个局部变量嘛： 12345val consoleLogWithTag = (::log.curried())(TAG)(System.out)...//打印日志consoleLogWithTag(\"This may be an error to call here.\") 其中 log.curried() 这个方法的签名如下： 123fun &lt;P1, P2, P3, R&gt; Function3&lt;P1, P2, P3, R&gt;.curried(): (p1: P1)-&gt;(p2: P2)-&gt;(p3: P3)-&gt; R&#123; ...&#125; 注意，由于 log 是函数名，因此我们在获取其对应的函数引用时需要加 ::。 好，说到这里，你可能直接去试前面的代码，然后垂头丧气的告诉我，说我这代码是骗人的，根本不能跑。为啥呢？因为根本没有 curried() 这个方法啊。 对啊，非常遗憾，截止到 1.1RC 版，我们也没有看到这样的 API 出现在标准库当中，所以我们只好自己搞咯： 12fun &lt;P1, P2, P3, R&gt; Function3&lt;P1, P2, P3, R&gt;.curried() = fun(p1: P1) = fun(p2: P2) = fun(p3: P3) = this(p1, p2, p3) 当然，这只是 Function3 的 curried() 实现版本，Kotlin 有 0-22 个 Function 版本，因此我们如果需要使用 Currying 这一特性的话，针对每一个版本都实现一个 curried 方法即可。 当然有 curried，就会有 uncurried，二者是完全相反的过程，我就不多讲了，大家可以自己尝试着实现一下。 3 偏函数我们再来看一下上一节这个打日志的例子，对于有三个参数的 log 函数，我们在极大多数的使用场景下都对前两个参数传入了相同的值： 1234567fun log(tag: String, target: OutputStream, message: Any?)&#123; ...&#125;...val consoleLogWithTag = (::log.curried())(TAG)(System.out) 其实，对一个多参数的函数，通过指定其中的一部分参数后得到的仍然是一个函数，那么这个函数就是原函数的一个偏函数了。从这个意义上来讲，consoleLogWithTag 也可以认为是 log 的一个偏函数。 显然，偏函数与 Currying 有一些内在的联系，如果我们需要构造的偏函数的参数恰好处于原函数参数的最前面，那么我们是可以使用 Currying 的方法获得这一偏函数的；当然，如果我们希望得到任意位置的参数被指定后的偏函数，那么我们就有足够的理由使用一些更好的方法。 例如： 12345678910val makeString = fun(byteArray: ByteArray, charset: Charset): String&#123; return String(byteArray, charset)&#125;...val makeStringFromGbkBytes = makeString.partial2(charset(\"GBK\"))//实际当中这个字节流可以是文件流，也可以是网络数据等等val gbkByteArray = ...println(makeStringFromGbkBytes(gbkByteArray)) 对于第二个参数 Charset，我们在国内有不少公司仍在用 GBK 编码，那么在开发的过程中，我们就没有必要每次都指定 GBK 这个编码选项了，下面这一句代码返回了一个 makeString 的偏函数，这个函数第二个参数确定为 charset(“GBK”)。 1val makeStringFromGbkBytes = makeString.partial2(charset(\"GBK\")) 接下来，同样我们需要给出 partial2 的实现： 12fun &lt;P1, P2, R&gt; Function2&lt;P1, P2, R&gt;.partial1(p1: P1) = fun(p2: P2) = this(p1, p2)fun &lt;P1, P2, R&gt; Function2&lt;P1, P2, R&gt;.partial2(p2: P2) = fun(p1: P1) = this(p1, p2) 我们看到，我们为 Function2 实现了两个扩展方法 partial1 和 partial2，这两个方法分别用来生成两个参数分别被指定后的偏函数。 目前 Kotlin 标准库尚且没有对此提供支持，如果需要得到 FunctionN (N &gt; 1) 的偏函数，那么我们需要把他们对应的 partialN 依次实现。 需要注意的是，makeString 是一个函数引用，可以直接用于调用函数的方法，这与上一节当中的 ::log 本质上是一样的，只是二者的定义方式不同，希望大家不要感到困惑。 123456// log 是函数名fun log(tag: String, target: OutputStream, message: Any?)&#123; ...&#125;...val consoleLogWithTag = (::log.curried())(TAG)(System.out) 本文主要给大家介绍了如何基于 Kotlin 的现有标准库来实现一些函数式编程的特性，其实这些特性已经在 Github 的 funKTionale 当中给出，本文的内容也更多的是在向它致敬。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"复合函数","slug":"复合函数","permalink":"http://www.Kotliner.cn/tags/复合函数/"},{"name":"Currying","slug":"Currying","permalink":"http://www.Kotliner.cn/tags/Currying/"},{"name":"偏函数","slug":"偏函数","permalink":"http://www.Kotliner.cn/tags/偏函数/"}]},{"title":"Kotlin 1.1：我们在路上","slug":"Kotlin 1.1：我们在路上","date":"2017-02-20T02:32:32.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/02/20/Kotlin 1.1：我们在路上/","link":"","permalink":"http://www.Kotliner.cn/2017/02/20/Kotlin 1.1：我们在路上/","excerpt":"","text":"►1.1 RC 来了，Release 还会远吗？ 去年 2 月 19 日 1.0 发版，我记得此前看到论坛上面开始讨论 1.0 API 趋于稳定的话题，想想都还挺兴奋呢，一不留神，Kotlin 1.0 在稳定奔跑一年之后，也终于迎来下一个版本：就在前天（17日），我留意到 Kotlin 官博发出了 1.1 RC(Release Candidate) 的消息，截止到目前，1.1 的所有开发工作都已经进入尾声，剩下的就只有我们期待的眼神了。 ►成长，一路有你 2016 这一年发生了挺多的事情，最重要的就是 Kotlin 终于有一个正式的版本，开始了按部就班的日子：每两个月一个正式版本以及一个 1.1 的里程碑版本。接着，我们也很快的发现我们期待的功能都悄悄的走进了 Kotlin 的更新日志，Kotlin 正一天一天的成长起来。 不知道各位看官年龄几何，对我来说，C 和 C++ 太老，Java 虽然小了一些，可它诞生的时候我还在小学里面玩 Dos；而当我真正开始认识它们的时候却发现它们实在是太庞大了，有时候甚至觉得可怕，有时候更是没办法理解它们。它们是编程语言的长者，而我，只是一个年轻的程序员。 Kotlin 则不一样了。它出现的不算早，大概 2010 年的样子吧，那个时候我刚刚闲来无事考了个软考中级的 “软件设计师”，一个在学校里面随处可见的“小黄书”背后的没有多大用处的考试，那个时候大概是我基础最好的时候吧。后来 Kotlin 逐渐成长起来，而我也逐渐脱离了象牙塔里的天真，冲向了努力干活历练自己的道路中间。 ►还记得，你与 Kotiln 的第一次相遇吗？ 最早认识 Kotlin 还是在 15 年初，那时候我正热衷于编写 IntelliJ 的插件，尽管后面成果空空，不过一些个莫名其妙的后缀为 kt 的文件却着实让我头疼不已。尽管照着说明安装好 Kotlin 的插件，可因为版本不一致，始终无法编译过去，真是无可奈何啊。当时我还想，又有新语言啊，这可当真是学海无涯咯。 不过，随着接触的机会逐渐增多，我发现 Kotlin 解决了很多我对 Java 不满的问题，而它呢，却又全力支持着 Java 中的一切，始终让我们感觉不到我用了另外一种语言，语法的那点儿差异说真的比起不同语言背后的编程思维的差异来说，简直不值得一提。我在同时尝试了 groovy 和 scala 之后，觉得 Kotlin 才是我想要的，于是在 Kotlin 1.0 发布之际，我向 Bugly 公众号投稿文章：Android 必备技能：最有可能接替Java的语言——Kotlin ，把我眼中的 Kotlin 向大家展现了出来。 ​►Kotlin 给你带来了什么？去年上半年有段时间经常奔波在北京和深圳之间，工作节奏“日新月异”，项目似乎进入了一种莫名其妙的状态，而我自己则犹如置身死水，所幸我也是上过王者的人了，也不枉费我那一段时间在上面投入的一个个不眠之夜吧。 那段时间，我对项目的代码有我“自以为是的足够”的祸害的自由，于是我开始肆无忌惮的用 Kotlin 写一些模块，完全没有顾及合作开发的我们组唯一的妹子的感受。以及，这代码后来落入导师手中，我也算是坑他们不浅呐。不过，如果没有这段经历，或许我后来也不会有那么大的底气去在 10 月份斗胆录制视频，也自然不会去开公众号每周发几篇水文了。说来，得好好谢谢他们。 话说，自从摊上这么个事儿，我只好每天早晨 6 点起来或写写东西，或看看书，学点儿东西，每天节奏也极其规律，中午再也没没有精力跟小伙伴们组团王者了，因为我得睡一个小时。 年前我又在 Bugly 公众号发了一篇文章：你为什么需要 Kotlin，结果大家都说我是被代码耽误了的段子手，呃。。我想说你们说的很对！ 承蒙各位朋友厚爱，经常提及后续视频录制的问题，我正在尝试重新录制一套较为细致和基础的视频，目前讲义已经编写完毕，至于发布时间，那得看我啥时候录得完啦。 末了，建议大家有事儿没事儿也都写写，我最开始在公司内部写文章刷积分玩，后来发现自己写的东西经常需要复习；不仅如此，很多时候遇到一个问题，可能最终用某种方式解决了，你以为这个问题你是搞清楚了的，不过，一旦你企图将其形成文字，你就会发现问题的背后将会是更多的细枝末节。俗话说得好，好记性不如啪啪啪的机械键盘啊！","raw":null,"content":null,"categories":[{"name":"心路历程","slug":"心路历程","permalink":"http://www.Kotliner.cn/categories/心路历程/"}],"tags":[{"name":"成长","slug":"成长","permalink":"http://www.Kotliner.cn/tags/成长/"}]},{"title":"高阶函数（一）","slug":"高阶函数（一）","date":"2017-02-20T02:32:32.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/02/20/高阶函数（一）/","link":"","permalink":"http://www.Kotliner.cn/2017/02/20/高阶函数（一）/","excerpt":"","text":"1 什么是高阶函数1.1 高阶函数的基本概念高阶函数其实看着挺吓人，不过就是把函数作为参数或者返回值的一类函数而已。其实这样的函数我们都见过很多了，来看个例子： 123public inline fun &lt;T&gt; Array&lt;out T&gt;.forEach(action: (T) -&gt; Unit): Unit &#123; for (element in this) action(element) &#125; 这是我们的老朋友了，forEach，传入了一个 Lambda 表达式，之后在迭代数组的时候调用这个 Lambda。你可千万别把 Lambda 不当函数，人家可是正儿八经的 FunctionN 的实例，这个我们在前面一篇文章细说 Lambda 表达式已经介绍过了~ 如果使用 forEach，我们就这么写： 123array.forEach&#123; print(\"$it, \") &#125; 输出结果就类似： 11, 2, 3, 4, forEach 其实就是一个把函数当参数传入的高阶函数了。 1.2 函数引用下面我们要来思考一个问题。为什么 Kotlin 可以有高阶函数？ 其实这个问题，我们早就有答案了，因为在 Kotlin 当中，函数是“一等公民”，函数的引用可以自由传递，赋值，并在合适的时候调用。为什么这么说呢？难道仅仅是因为我们可以任性的定义 Lambda 表达式这种匿名函数，并把它赋值为一个变量，然后可以随便传递和调用吗？ 当然不能完全是这样了。其实 Kotlin 当中的任何方法、函数都是有其名字和引用的，我们前面其实看到过一个 forEach 的例子，我再给大家拿出来： 1array.forEach(::println) 这个例子当中，我们其实是想要把元素挨个打印一遍，forEach 传入的是一个 (T) -&gt; Unit，这并不是说它只能传入一个符合参数和返回值的 Lambda，而是说符合参数和返回值定义的任意函数。println 有很多版本，其中有一个符合上面的条件： 123public inline fun println(message: Any?) &#123; System.out.println(message) &#125; 所以我们可以把它当参数传入。这个意义上讲，::println 跟 Function1 是什么关系呢？很明显接口实现的关系了，同时 ::println 因为可以具名引用到一个函数，所以我们也把类似的写法叫做函数引用。 我们再来看一个类成员的例子： 1234567class Hello&#123; fun world()&#123; println(\"Hello world.\") &#125; &#125; val helloWorld: (Hello)-&gt; Unit = Hello::world 我们同样可以用 :: 的方式来引用类成员方法，当然扩展方法也是可以的。这个要怎么用呢？ 12345fun Int.isOdd(): Boolean = this % 1 == 0 ... val ints = intArrayOf(1,3,4,5,8) ints.filter(Int::isOdd) 注意到 filter 的参数类型： 123public inline fun IntArray.filter(predicate: (Int) -&gt; Boolean): List&lt;Int&gt; &#123; return filterTo(ArrayList&lt;Int&gt;(), predicate) &#125; 跟我们前面 Hello::World 的例子是不是一模一样呢？ 不过相比包级函数，这种引用在 Kotlin 1.1 以前显得有些苍白，为什么这么说呢？ 123456789class PdfPrinter&#123; fun println(any: Any?)&#123; println(any) &#125; &#125; ... array.forEach(PdfPrinter::println) //错误！！ 请问，这种情况下，我该如何像 一样将 ```PdfPrinter::println``` 传递给 forEach 呢？我们知道，所有的类成员方法，它们其实都有一个隐含的参数，即类的实例本身，所以它的类型应该是下面这样：123```kotlin val pdfPrintln: (PdfPrinter, Any?)-&gt; Unit = PdfPrinter::println 那么，有人就会说，我干脆构造一个 PdfPrinter 的实例，然后这么写看看： 1array.forEach(PdfPrinter()::println)// Since Kotlin 1.1 看着很不错了吧？可惜，这个在 1.1 才支持哦，不过距离 1.1 正式发布应该不久了！ 2 常见的内置高阶函数Kotlin 为我们内置了不少好用的高阶函数，这一节我们就给大家简要介绍一下。 2.1 map我们经常用 forEach 来迭代一个集合，如果我们想要把一个集合映射成另外一个集合的话，通常我们会这么写： 1234567val list = listOf(1,3,4,5,10,6,8,2) val newlist = ArrayList&lt;Int&gt;() list.forEach &#123; val newElement = it * 2 + 3 newlist.add(newElement) &#125; 看上去还是挺简单的，不过终究不够简洁，而且还在 Lambda 表达式内部访问了外部变量，这其实都不是很好的编程习惯。 map 其实就是对类似的操作做了一点封装，类似的集合映射的操作用 map 再合适不过了： 123val newlist = list.map &#123; it * 2 + 3 &#125; Lambda 的参数是原集合的元素，返回值是对应位置的新集合的元素，新集合是 map 的返回值。我们再来看个例子： 1val stringlist = list.map(Int::toString) 上面这个例子，我们把一个整型的集合映射成了一个字符串类型的集合。不管你做何种变换，map 的返回值始终是一个大小与原集合相同的集合。 2.2 flatMap如果我手头有一个整型集合的集合，我想把他们打平，变成一个整型集合，用我们传统的方法就是两层循环。如果我还想要做点儿变换，那么这代码写起来就更丑了。 如果我们要用 flatMap，那么这个故事就直截了当得多： 12345678val list = listOf( 1..20, 2..5, 100..232 ) val flatList = list.flatMap &#123; it &#125; println(flatList) flatMap 后面的 Lambda 参数是 list 的元素，也就 1..20、2..5 这些 range，返回的值呢是一个 Iterable，flatMap 会把这些 Lambda 返回的 Iterable 统统添加到它自己的返回值也就是 flatList 当中，这样就相当于把 list 做了一次打平。 结果： 1[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 2, 3, 4, 5, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232] 那么这么直白的打平也不见得是我们的目标，比如我们要把这些数都做一些运算再打平，那么这个也简单： 12345val flatList = list.flatMap &#123; iterable -&gt; iterable.map &#123; element -&gt; element * 2 + 3 &#125; &#125; 我们只需要对 iterable 做一次 map 即可。 2.3 fold / reduce其实 fold 就是折叠的意思嘛，把一个集合的元素折叠起来的并得到一个最终的结果，这就是 fold 要做的事情。 123456789fun main(args: Array&lt;String&gt;) &#123; val ints = intArrayOf(1,2,3,4,5) val r = ints.fold(5)&#123; sum, element -&gt; println(\"$sum, $element\") sum + element &#125; println(r) &#125; 结果呢？就是从 5 开始，每次返回的结果又成了 sum，一直这么折叠下去，直到最后输出 20。 1234565, 1 6, 2 8, 3 11, 4 15, 5 20 当然，对于fold来说，我们还可以得到其他类型的结果，不一定要与集合的元素类型相同： 123456val r1 = ints.fold(StringBuilder())&#123; sb, element-&gt; sb.append(element).append(\",\") &#125; println(r1) 大家看到，我们的初始值实际上是一个 StringBuilder，后续一直在做字符串追加的操作，最后得到的 r1 其实就是一个追加了所有元素的 StringBuilder，我们把它打印出来： 11,2,3,4,5, 我们再来看下 reduce。 12val r2 = ints.reduce &#123; sum, element -&gt; sum + element &#125; println(r2) 输出的最终结果是 15，也即元素之和。显然，reduce 每次求值的结果都作为下一次迭代时传入的 sum，这个看上去跟 fold 极其的类似，只不过 reduce 没有额外的初始值，并且返回值类型也需要保持与集合的元素相同。 如果我们要求一个数的阶乘，那代码其实很容易写： 1234fun factorial(n: Int): Int&#123; if(n == 0) return 1 return (1..n).reduce &#123; factorial, element -&gt; factorial * element &#125; &#125; 2.4 filter / takeWhile如果我们有一个很大的集合，想要过滤掉其中的一些元素，那么通常的做法也是构造一个新集合来，然后遍历原集合。 显然，我们有更好的写法： 123val evens = (1..100).filter &#123; it % 2 == 0 &#125; 找出 1 到 100 之间的所有偶数，我们只需要用 filter，并传入判断条件，那么符合条件的元素就会被保留到返回的集合当中。 类似的，takeWhile 则返回的集合是原集合中从第一个元素开始到第一个不符合条件的元素之前的所有元素。例如： 1println((1..10).takeWhile &#123; it % 5 != 0 &#125;) 这表明，从 1..10 当中取元素，只要遇到一个是 5 的倍数的元素，那么立即返回，即结果为： 1[1, 2, 3, 4] 2.5 letlet 实际上比较简单，我们先来看下它的定义： 1public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this) 我们看到 let 实际上传入了一个 Lambda，而这个 Lambda 传入的参数就是 let 的调用者本身，返回值随便你。这个 let 有什么用呢？ 1val person: Person? = findPerson() 我们看到 person 这个变量是可空的，我们需要做一些判断才能对其进行操作。通常的写法可能是这样的： 123person?.name = \"张三\" person?.age = 18 ... 不过，这种问好满天飞的写法，看着其实并不是很让人舒服。 我们还可以这么写： 12345if(person != null)&#123; person.name = \"张三\" // person 被智能转换成 Person 类型 person.age = 18 ... &#125; 当然，我们还有一种写法就是： 12345person?.let&#123; it.name = \"张三\" it.age = 18 ... &#125; let 比较简单，其用法也是很灵活的，大家可以自行发挥。 2.6 apply / with下面我们来看 apply。 1public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125; 注意到 apply 传入的 Lambda 也是 apply 的调用者的扩展方法，所以，apply 相当于给了我们一个灵活切换上下文的机会， 1234567class Options&#123; var scale: Float = 1f var offsetX: Double = 0.0 var offsetY: Double = 0.0 var rotationX: Float = 0f var rotationY: Float = 0f &#125; 假设我们有这么一个类，我们在操作一个地图变换的时候需要传入这个东西，告诉地图该怎么变换。 12345mapView.animateChange(Options().apply &#123; //Options 的作用域 scale = 2f rotationX = 180f &#125;) 而 with 呢？ 1public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block() 跟 apply 比较类似，不同之处在与 Lambda 返回值。with 只是单纯的获取 receiver 的上下文，而 apply 则同时也把它本身返回了。 12345678val br = BufferedReader(FileReader(\"hello.txt\")) with(br)&#123; var line: String? while (true)&#123; line = readLine()?: break &#125; close() &#125; 我们看到在 with 当中，readLine 和 close 方法可以直接调用。 内置高阶函数其实非常多，这几个比较常用，剩下的大家可以自行学习。 3 尾递归优化递归大家都熟悉，一说递归大家都容易哆嗦：你可别递归的层次太深了啊，不然小心 StackOverflow！没错，StackOverflow 这个异常实在是太常见了，所以你最熟悉的程序员社交网站当中就有一个叫 StackOverflow 的。 其实大家肯定也都知道，递归能实现的，用迭代也基本上能实现，这个感觉就好像做小学数学题，用递归就好比设个 x，列个方程求解；而用迭代呢，就好比用算式生生的去把结果给算出来。前者思考起来比较直接，编写起来也自然更符合人的思维模式，后者呢往往编写困难，代码可读性差。 如果有一天，我能写出递归程序，编译器呢，却能够按照迭代的方式给我运行，那么我岂不是既能获得递归的简洁性，又不失迭代的运行效率，那该。。。想得美啊。 我们今天就要给大家看一种特定条件下的编译优化措施。其实前面我们的设想并不是完全做不到，对于某些比较简单的场景，编译器是可以直接把我们的递归代码翻译成迭代代码的，而这种场景其实就是“尾递归”。 什么叫“尾递归”？函数在调用自己之后，没有任何操作的情形就是尾递归。 比如： 1234567data class ListNode(val value: Int, var next: ListNode?) fun findListNode(head: ListNode?, value: Int): ListNode?&#123; head?: return null if(head.value == value) return head return findListNode(head.next, value) &#125; 我们随便定义了一个链表，ListNode 是它的元素，findListNode 目的是找到对应值的元素。我们看到最后一行只有 findListNode 的调用，没有其他任何操作，这就是尾递归。 我们再来看几个例子： 123fun factorial(n: Long): Long&#123; return n * factorial(n - 1) &#125; 求阶乘，因为 factorial 调用之后还有乘以 n 的操作，所以这个不是尾递归。 12345678910data class TreeNode(val value: Int)&#123; var left: TreeNode? = null var right: TreeNode? = null &#125; fun findTreeNode(root: TreeNode?, value: Int): TreeNode?&#123; root?: return null if(root.value == value) return root return findTreeNode(root.left, value) ?: return findTreeNode(root.right, value) &#125; 这个算不算尾递归呢？好像最后一行的两个 return 都是之调用了 findTreeNode，没有其他操作了啊，这个应该是尾递归吧？答案当然不是。。因为第一个 findTreeNode 的结果拿到之后，我们要看下他是不是为 null，实际上这个判断操作在 findTreeNode 之后，所以不能算尾递归。对于不是尾递归的情况，编译器是没有办法做优化的。 而对于尾递归的情况，我们该如何启用编译器优化呢？ 要说告诉编译器需要尾递归优化，其实非常简单，加一个关键字即可： 12345tailrec fun findListNode(head: ListNode?, value: Int): ListNode?&#123; head?: return null if(head.value == value) return head return findListNode(head.next, value) &#125; 这个看起来真的很简单，简单到没有说服力。我们看一段小程序： 12345678910val MAX_NODE_COUNT = 100000 val head = ListNode(0) var p = head for (i in 1..MAX_NODE_COUNT)&#123; p.next = ListNode(i) p = p.next!! &#125; //前面先构造了一个链表，节点个数有 10 万个 //后面进行查找，查找值为 MAX_NODE_COUNT - 2 的节点 println(findListNode(head, MAX_NODE_COUNT - 2)?.value) 对于没有 tailrec 关键字的版本，结果非常抱歉： 123Exception in thread \"main\" java.lang.StackOverflowError at net.println.kotlin.RecursiveKt.findListNode(Recursive.kt:34) at net.println.kotlin.RecursiveKt.findListNode(Recursive.kt:34) 而对于有 tailrec 的版本，结果是： 199998 显然，对于尾递归优化的版本，即使你递归再多的层次，都不会有 StackOverflow，原因也很简单，编译器其实已经把这种递归编译成迭代来运行了，迭代怎么会有 StackOverflow 呢？ 接着我们再来讨论一下非尾递归代码可以改写为尾递归代码的条件。大家仔细观察我们前面给出的两个例子，一个是求阶乘，一个是超找树的节点。二者最后一句： 1return n * factorial(n - 1) 1return findTreeNode(root.left, value) ?: return findTreeNode(root.right, value) 虽然都不是尾递归，但还是有差异的。前者在调用完自己之后进行了跟调用自己无关的运算；后者调用完一次自己之后，还有可能调用一次自己。注意，如果调用完自己，又进行了其他操作，也即没有再次调用自己，那么这种递归其实有希望转换为尾递归代码，下面我们就改写一下求阶乘的代码，让它变成尾递归代码。 12345678910111213fun factorial(n: Long): Long&#123; class Result(var value: Long) tailrec fun factorial0(n: Long, result: Result)&#123; if(n &gt; 0) &#123; result.value *= n factorial0(n - 1, result) &#125; &#125; val result = Result(1) factorial0(n, result) return result.value &#125; 这个例子当中有一些比较有意思的概念哈，我们在一个函数当中定义了一个函数和一个类，它们被称作“本地函数”和“本地类”，由于定义在函数内部，因此在外部无法使用它们。接着我们对内部的 factorial0 加了 tailrec 关键字，由于最后一行只有对自己的调用，因此符合尾递归优化的条件。 我们看到，之前 n * 的这部分操作通过 Result 携带的中间结果被移到了自身调用的前面，这样做让原本的递归代码符合了尾递归优化的条件，却也让代码本身复杂了许多。而对于此类操作，我个人更倾向于直接使用迭代。 1234567fun factorial(n: Long): Long&#123; var result: Long = 1 for (i in 1..n)&#123; result *= i &#125; return result &#125; 迭代的代码显然也直截了当得多。 总而言之，使用递归是为了让我们的代码更直接，更自然，使用迭代往往是为了追求效率（空间效率）。对于类似查找链表节点这样的场景，它很自然的就是一个尾递归的结构，我们可以使用尾递归优化来提升它的性能；而对于求阶乘这样的场景，它本来就不是尾递归的结构，我们尽管可以通过某种方式改写它，但这样做其实根本没必要；而对于查找树节点这样的场景，尾递归基本上是无能无力了。 ##4 闭包 对象是要携带状态的。比如： 1val string = \"HelloWorld\" string 这个对象它有值，这个值就是它的状态。那么同样作为对象的函数，它有什么状态呢？我们看个例子： 1234567891011121314fun makeFun(): ()-&gt;Unit&#123; var count = 0 return fun()&#123; println(++count) &#125; &#125; ... val x = makeFun() x() x() x() x() 输出的结果会是什么呢？从函数当中返回一个函数，这在 Java 当中简直不能想象，不过这在函数为“一等公民”的 Groovy、JavaScript 当中确实寻常可见。 12341 2 3 4 每次调用 x，打印的值都不一样，这说明函数也是可以保存状态的。受到这个启发，我们是不是可以继续写出这样的例子： 12345678910111213141516fun fibonacci(): ()-&gt;Long&#123; var first = 0L var second = 1L return fun(): Long&#123; val result = second second += first first = second - first return result &#125; &#125; ... val next = fibonacci() for (i in 1..10)&#123; println(next()) &#125; 输出结果： 123456789101 1 2 3 5 8 13 21 34 55 我们干脆再进一步吧： 1234567891011121314151617181920212223fun fibonacciGenerator(): Iterable&lt;Long&gt;&#123; var first = 0L var second = 1L return Iterable &#123; object : LongIterator()&#123; override fun hasNext() = true override fun nextLong(): Long &#123; val result = second second += first first = second - first return result &#125; &#125; &#125; &#125; ... for(x in fibonacciGenerator())&#123; println(x) if(x &gt; 100) break &#125; 这个例子我们干得更彻底，通过返回一个 Iterable，我们甚至可以用 for 循环迭代这个结果。 不管我们怎么写，请注意，每次调用同一个函数的结果都不一样，而承载返回结果的 first 和 second 这两个变量是定义在最外层的函数当中的，按说这个函数一旦运行完毕，它所在的作用域就会被回收，如果真是那样，前面的这两段代码一定是我们产生的幻觉。如果不是幻觉，那只能说明一个问题：这个作用域没有被回收。 这个作用域包含了所有函数运行的状态，包括变量、本地类、本地函数等等，那这个作用域其实就是闭包。 我们再来看个好玩的例子： 12345fun add(x: Int) = fun(y: Int) = x + y ... val add5 = add(5) println(add5(2)) 很显然，结果是 7，这个 add 的定义其实写得有些令人迷惑，我把它改写一下给大家看： 12345fun add(x: Int): (Int)-&gt;Int&#123; return fun(y: Int): Int&#123; return x + y &#125; &#125; 很显然，当我们调用 add(5) 返回 add5 这个函数时，它是持有了 add 函数的运行环境的，不然它怎么知道 x 的值是多少呢？ 通过这几个小例子，相信大家对闭包有了一定的了解。闭包其实就是函数运行的环境。 下周我们还会继续跟大家讨论函数编程相关的一些话题，谢谢大家的关注~","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"高阶函数","slug":"高阶函数","permalink":"http://www.Kotliner.cn/tags/高阶函数/"},{"name":"尾递归","slug":"尾递归","permalink":"http://www.Kotliner.cn/tags/尾递归/"}]},{"title":"[译]Kotlin 1.1 候选版本来啦","slug":"Kotlin 1.1 Release Candidate is Here","date":"2017-02-17T05:37:00.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2017/02/17/Kotlin 1.1 Release Candidate is Here/","link":"","permalink":"http://www.Kotliner.cn/2017/02/17/Kotlin 1.1 Release Candidate is Here/","excerpt":"","text":"截至今天，Kotlin 1.1 终于到了候选版本（RC）阶段。这意味着大部分开发工作都已经完成，我们对此结果感到满意，很快就会发布 Kotlin 1.1 正式版。我们已经在内部对此版本进行了大量测试，但现实世界总是比任何测试环境更加多样化，因此我们需要您的帮助。请尝试这个版本，让我们知道您的体验！ 候选版本中唯一的新功能是 takeUnless 函数，它对应 1.1 之前添加的 takeIf，但判断条件相反。至于错误修复则有很多，完整清单请查看更新日志。除此之外，我们还修复了几个 IDE 中的性能问题，包括长期存在和最近回归才出现的。 迁移说明就像我们之前提到的，预发布版本生成的所有二进制文件不能在当前的编译器下使用：您现在需要重新编译由 1.1-M0x 和 Beta 编译的所有内容。当然，从 1.0.x 开始的所有代码都不需要重新编译。 在这之前，您可以从 Java 6 开始，以任何版本的 Java 运行 Kotlin 编译器，但这从第一个 1.1.x 更新开始有变化，编译器将仅在 Java 8 或 9 下运行。为您准备迁移，编译器现在会在 Java 6 或 7 下运行时发出警告。请注意，这仅影响构建环境；编译代码默认情况下仍然与 Java 6 兼容，我们没有计划删除对它的支持。 现在不推荐使用 .javaClass 扩展属性。作为替代，请使用 ::class.java。IDE 提供了一个 quickfix 来更新写法，单独的修改或者更新整个项目。 为了减小 JavaScript 标准库的大小，我们已经将 kotlin.dom 和 kotlin.dom.build 包中的大量辅助函数注解为不推荐使用了，然后在将来的更新中删除它们。 如何尝鲜在 Maven/Gradle 中： 将 http://dl.bintray.com/kotlin/kotlin-eap-1.1 添加为构建脚本和项目的仓库；使用 1.1.0-rc-91 作为编译器和标准库的版本号。 在 IntelliJ IDEA 中： 点击菜单 Tools → Kotlin → Configure Kotlin Plugin Updates，然后在 Update channel 的下拉列表中选择 “Early Access Preview 1.1”，接着点击 Check for updates。 在 Eclipse 中： 从以下更新站点安装插件https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/0.8.0 The command-line compiler 可以从 Github 发布页面下载。最后，让我们开启 Kotlin 之旅吧！try.kotlinlang.org。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"细说 Lambda 表达式","slug":"细说 Lambda 表达式","date":"2017-02-13T02:37:42.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/02/13/细说 Lambda 表达式/","link":"","permalink":"http://www.Kotliner.cn/2017/02/13/细说 Lambda 表达式/","excerpt":"","text":"1. 什么是 Lambda 表达式Lambda 表达式，其实就是匿名函数。而函数其实就是功能（function），匿名函数，就是匿名的功能代码了。在 Kotlin 当中，函数也是作为类型的一种出现的，尽管在当前的版本中，函数类型的灵活性还不如 Python 这样的语言，不过它也是可以被赋值和传递的，这主要就体现在 Lambda 表达式上。 我们先来看一个 Lambda 表达式的例子： 12345678fun main(args: Array&lt;String&gt;) &#123; val lambda = &#123; left: Int, right: Int -&gt; left + right &#125; println(lambda(2, 3)) &#125; 大家可以看到我们定义了一个变量 lambda，赋值为一个 Lambda 表达式。Lambda 表达式用一对大括号括起来，后面先依次写下参数及其类型，如果没有就不写，接着写下 -&gt; ，这表明后面的是函数体了，函数体的最后一句的表达式结果就是 Lambda 表达式的返回值，比如这里的返回值就是参数求和的结果。 后面我们用 () 的形式调用这个 Lambda 表达式，其实这个 () 对应的是 invoke 方法，换句话说，我们在这里也可以这么写： 1println(lambda.invoke(2,3)) 这两种调用的写法是完全等价的。 毫无疑问，这段代码的输出应该是 5。 2 简化 Lambda 表达式我们再来看个例子： 1234567fun main(args: Array&lt;String&gt;) &#123; args.forEach &#123; if(it == \"q\") return println(it) &#125; println(\"The End\") &#125; args 是一个数组，我们已经见过 for 循环迭代数组的例子，不过我们其实有更现代化的手段来迭代一个数组，比如上面这个例子。这没什么可怕的，一旦撕下它的面具，你就会发现你早就认识它了： 123public inline fun &lt;T&gt; forEach(action: (T) -&gt; Unit): Unit &#123; for (element in this) action(element) &#125; 这是一个扩展方法，扩展方法很容易理解，原有类没有这个方法，我们在外部给它扩展一个新的方法，这个新的方法就是扩展方法。大家都把它当做 Array 自己定义的方法就好，我们看到里面其实就是一个 for 循环对吧，for 循环干了什么呢？调用了我们传入的Lambda表达式，并传入了每个元素作为参数。所以我们调用 forEach 方法时应该怎么写呢？ 123args.forEach(&#123; element -&gt; println(element) &#125;) 这相当于什么呢？ 123for(element in args)&#123; println(element) &#125; 很容易理解吧？ 接着，Kotlin 允许我们把函数的最后一个Lambda表达式参数移除括号外，也就是说，我们可以改下上面的 forEach 的写法： 123args.forEach()&#123; element -&gt; println(element) &#125; 看上去有点儿像函数定义了，不过区别还是很明显的。这时候千万不能晕了，晕了的话我这儿有晕车药吃点儿吧。 事儿还没完呢，如果函数只有这么一个 Lambda 表达式参数，前面那个不就是么，剩下一个小括号也没什么用，干脆也丢掉吧： 123args.forEach&#123; element -&gt; println(element) &#125; 大家还好吧？你以为这就结束了？nonono，如果传入的这个Lambda表达式只有一个参数，还是比如上面这位 forEach，参数只有一个 element ，于是我们也可以在调用的时候省略他，并且默认它叫 it，说得好有道理，它不就是 it 么，虽然人家其实是 iterator 的意思： 123args.forEach&#123; println(it) &#125; 嗯，差不多了。完了没，没有。还有完没啊？就剩这一个了。如果这个 Lambda 表达式里面只有一个函数调用，并且这个函数的参数也是这个Lambda表达式的参数，那么你还可以用函数引用的方式简化上面的代码： 1args.forEach(::println) 这有没有点儿像 C 里面的函数指针？函数也是对象嘛，没什么大惊小怪的，只要实参比如 println 的入参和返回值与形参要求一致，那么就可以这么简化。 总结一下： 最后一个Lambda可以移出去 只有一个Lambda，小括号可省略 Lambda 只有一个参数可默认为 it 入参、返回值与形参一致的函数可以用函数引用的方式作为实参传入 这样我们之前给的那个例子就大致能够看懂了吧： 1234567fun main(args: Array&lt;String&gt;) &#123; args.forEach &#123; if(it == \"q\") return println(it) &#125; println(\"The End\") &#125; 3 从 Lambda 中返回真看懂了吗？假设我输入的参数是 1o p q r s t 你知道输出什么吗？ 123o p The End 对吗？ 不对，return 会直接结束 main 函数。为啥？Lambda 表达式，是个表达式啊，虽然看上去像函数，功能上也像函数，可它看起来也不过是个代码块罢了。这就像琅琊榜前期，靖王虽然获得了自由进宫拜见母妃的特权，但他当时并不是亲王，而只是一个郡王一样。 那，就没办法 return 了吗？当然不是，兵来将挡水来土掩： 1234567fun main(args: Array&lt;String&gt;) &#123; args.forEach forEachBlock@&#123; if(it == \"q\") return@forEachBlock println(it) &#125; println(\"The End\") &#125; 定义一个标签就可以了。你还可以在 return@forEachBlock 后面加上你的返回值，如果需要的话。 4 Lambda 表达式的类型好，前面说到 Lambda 表达式其实是函数类型，我们在前面的 forEach 方法中传入的 Lambda 表达式其实就是 forEach 方法的一个参数，我们再来看下 forEach 的定义： 123public inline fun &lt;T&gt; Array&lt;out T&gt;.forEach(action: (T) -&gt; Unit): Unit &#123; for (element in this) action(element) &#125; 注意到，action 这个形参的类型是 (T) -&gt; Unit，这个是 Lambda 表达式的类型，或者说函数的类型，它表示这个函数接受一个 T 类型的参数，返回一个 Unit 类型的结果。我们再来看几个例子： 123() -&gt; Int //无参，返回 Int (Int, Int) -&gt; String //两个整型参数，返回字符串类型 (()-&gt;Unit, Int) -&gt; Unit //传入了一个 Lambda 表达式和一个整型，返回 Unit 我们平时就用这样的形式来表示 Lambda 表达式的类型的。有人可能会说，既然人家都是类型了，怎么就没有个名字呢？或者说，它对应的是哪个类呢？ 1public interface Function&lt;out R&gt; 其实所有的 Lambda 表达式都是 Function 的实现，这时候如果你问我，那 invoke 方法呢？在哪儿定义的？说出来你还真别觉得搞笑，Kotlin 的开发人员给我们定义了 23 个 Function 的子接口，其中 FunctionN 表示 invoke 方法有 n 个参数。。 12345678910public interface Function0&lt;out R&gt; : Function&lt;R&gt; &#123; public operator fun invoke(): R &#125; public interface Function1&lt;in P1, out R&gt; : Function&lt;R&gt; &#123; public operator fun invoke(p1: P1): R &#125; ... public interface Function22&lt;in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, in P18, in P19, in P20, in P21, in P22, out R&gt; : Function&lt;R&gt; &#123; public operator fun invoke(p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9, p10: P10, p11: P11, p12: P12, p13: P13, p14: P14, p15: P15, p16: P16, p17: P17, p18: P18, p19: P19, p20: P20, p21: P21, p22: P22): R &#125; 说实在的，第一看到这个的时候，我直接笑喷了，Kotlin 的开发人员还真是黑色幽默啊。 这事儿不能这么完了，万一我真有一个函数，参数超过了 22 个，难道 Kotlin 就不支持了吗？ 123fun hello2(action: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int) -&gt; Unit) &#123; action(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22) &#125; 于是我们定义一个参数有 23 个的 Lambda 表达式，调用方法也比较粗暴： 123hello2 &#123; i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22 -&gt; println(\"$i0, $i1, $i2, $i3, $i4, $i5, $i6, $i7, $i8, $i9, $i10, $i11, $i12, $i13, $i14, $i15, $i16, $i17, $i18, $i19, $i20, $i21, $i22,\") &#125; 编译运行结果： 12345Exception in thread \"main\" java.lang.NoClassDefFoundError: kotlin/Function23 at java.lang.Class.getDeclaredMethods0(Native Method) at java.lang.Class.privateGetDeclaredMethods(Class.java:2701) at java.lang.Class.privateGetMethodRecursive(Class.java:3048) at java.lang.Class.getMethod0(Class.java:3018) 果然，虽然这个参数有 23 个的 Lambda 表达式被映射成 kotlin/Function23 这个类，不过，这个类却不存在，也就是说，对于超过 22 个参数的 Lambda 表达式，Kotlin 代码可以编译通过，但会抛运行时异常。这当然也不是个什么事儿了，毕竟有谁脑残到参数需要 22 个以上呢？ 5 SAM 转换看名字挺高大上，用起来炒鸡简单的东西你估计见了不少，这样的东西你可千万不要回避，多学会一个就能多一样拿出去唬人。 12345val worker = Executors.newCachedThreadPool() worker.execute &#123; println(\"Hello\") &#125; 本来我们应该传入一个 Runnable 的实例的，结果用一个 Lambda 表达式糊弄过去，Java 怎么看？ 123GETSTATIC net/println/MainKt$main$1.INSTANCE : Lnet/println/MainKt$main$1; CHECKCAST java/lang/Runnable INVOKEINTERFACE java/util/concurrent/ExecutorService.execute (Ljava/lang/Runnable;)V Java 说介叫嘛事儿，介不就一 Lambda 么，转成 Runnable 在拿过来！ 你看上面的这三句字节码，第一句拿到了一个类的实例，这个类一看就是一个匿名内部类： 123final class net/println/MainKt$main$1 implements java/lang/Runnable &#123; ... &#125; 这是这个类定义的字节码部分，实现了 Runnable 接口的一个类！ 第二句，拿到这个类的实例以后做强转——还转啥，直接拿来用呗，肯定没问题呀。 那你说 SAM 转换有什么条件呢？ 首先，调用者在 Kotlin 当中，被调用者是 Java 代码。如果前面的例子当中 worker.execute(…) 是定义在 Kotlin 中方法，那么我们是不能用 SAM 转换的。 其次，参数必须是 Java 接口，也就是说，Kotlin 接口和抽象类、Java 抽象类都不可以。 再次，参数的 Java 接口必须只有一个方法。 我们再来举个 Android 中常见的例子： 1234view.setOnClickListener&#123; view -&gt; ... &#125; view.setOnClickListener(…) 是 Java 方法，参数 OnClickListener 是 Java 接口，并且只有一个方法： 123public interface OnClickListener &#123; void onClick(View v); &#125; 6 小结Lambda 表达式就是这么简单，简单的让人有点儿害怕。不知道大家有没有过这样的感觉，越是简单的东西用起来越复杂，不相信你回去翻一翻高中物理课本的牛顿第二定律。Lambda 表达式就是这样的东西，它能够极大的简化代码的书写，尽管一旦有了 Lambda 表达式的掺和，代码本身理解起来可就要稍微困难一些了，不过，因噎废食的事情想必大家也是不喜欢做的，对吧？","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"Lambda","slug":"Lambda","permalink":"http://www.Kotliner.cn/tags/Lambda/"},{"name":"匿名函数","slug":"匿名函数","permalink":"http://www.Kotliner.cn/tags/匿名函数/"}]},{"title":"Kotlin 1.1 Beta 2 发布~","slug":"Kotlin 1.1 Beta 2 发布~","date":"2017-02-06T00:14:15.000Z","updated":"2017-05-22T02:30:56.890Z","comments":true,"path":"2017/02/06/Kotlin 1.1 Beta 2 发布~/","link":"","permalink":"http://www.Kotliner.cn/2017/02/06/Kotlin 1.1 Beta 2 发布~/","excerpt":"","text":"1 协程改包名风波说真的，看到这个标题的时候我还挺兴奋，离 release 又近了一步。不过，看了这篇文章的时候，我就觉得也是醉醉的。发生了啥呢？ 原来，协程相关的依赖统统被标记为 experimental 了，以前叫： 1package kotlin.coroutines 现在呢？ 1package kotlin.coroutines.experimental 这意味着啥？意味着我们在这次更新之后，还得把原来的协程代码的包重新导入一遍，另外，如果你想使用协程，那么你还需要在配置当中呢启用它，例如 gradle 配置需要加入： 12345kotlin &#123; experimental &#123; coroutines 'enable' &#125; &#125; 你在升级所有的依赖的时候，确保它是兼容 1.1.0-beta-38 的，这一点很重要，不然等着报错吧！ 话说，为啥要这么搞呢？按照官方的说法就是，协程这个特性目前已经实现的非常不错了，内置 API 非常少，灵活扩展性也强，不过他们觉得这个东西还有很大的潜力，也不能就这样作为最终版本给大家放出来，而作为实验特性交给大家使用呢，更多地还是希望大家能提提意见啥的。嗯，说实在的，协程这个特性真不是个小特性。 2 兼容 1.0话说，1.1 的编译器终于声称兼容 1.0 的源码了，这表明我们再也不用搞两个 IntelliJ 分别装 1.0 稳定版的插件和 1.1 Beta 版的插件了。 是的，就算你不用 1.1 的特性，你装 1.1 的插件，用 1.1 的编译器，写 1.0 的代码毫无压力！！ 什么？你问我试了没？当然，我一直用最新的插件，折腾地挺苦的 T T，劝诸君还是装稳定版吧，吃螃蟹要做好心理准备~！ 3 小结浏览了一下 1.1Beta 2 的主要特性，其实就是改改包名，修几个小 Bug，大的改动基本没有了。如果大家想要尽早上手 1.1 的特性，那么就从现在开始吧~","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://www.Kotliner.cn/tags/Coroutine/"},{"name":"兼容","slug":"兼容","permalink":"http://www.Kotliner.cn/tags/兼容/"}]},{"title":"深入理解 Kotlin Coroutine (2)","slug":"深入理解 Kotlin Coroutine (2)","date":"2017-02-06T00:14:15.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/02/06/深入理解 Kotlin Coroutine (2)/","link":"","permalink":"http://www.Kotliner.cn/2017/02/06/深入理解 Kotlin Coroutine (2)/","excerpt":"","text":"上周我们把 Kotlin Coroutine 的基本 API 挨个讲了一下，也给出了一些简单的封装。 真是不要太给脸，就在前几天发布的 1.1 Beta 2 当中，所有协程的 API 包名后面都加了一个 experimental，这意味着 Kotlin 官方在 1.1 当中还是倾向于将 Coroutine 作为一个实验性质的特性的，不过，这也没关系，我们学习的心不以外界的变化而变化不是？ 这一篇我们基于前面的基础来了解一下 Kotlinx.coroutines 这个库的使用，如果大家对它的实现原理有兴趣，可以再读一读上一篇文章，我们也可以在后面继续写一些文章来给深入地大家介绍。 1. 准备工作就像前面我们说到的，1.1 Beta 2 当中协程相关的基础库的包名都增加了 experimental，所以我们在选择 kotlinx.coroutines 的版本的时候也一定要对应好编译器的版本，不然。。。你自己想哈哈。 我们强调一下，kotlin 的版本选择 1.1.0-beta-38，kotlinx.coroutines 的版本选择 0.6-beta，如果你恰好使用 gradle，那么告诉你一个好消息，我会直接告诉你怎么配置： 1234567891011121314151617181920212223242526272829303132buildscript &#123; ext.kotlin_version = '1.1.0-beta-38' repositories &#123; jcenter() maven &#123; url \"http://dl.bintray.com/kotlin/kotlin-eap-1.1\" &#125; &#125; ... &#125; repositories &#123; jcenter() maven &#123; url \"http://dl.bintray.com/kotlin/kotlin-eap-1.1\" &#125; &#125; kotlin &#123; experimental &#123; coroutines 'enable' &#125; &#125; dependencies &#123; compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\" compile 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.6-beta' &#125; 2. 一个基本的协程的例子这个例子是 kotlinx.coroutines 的第一个小例子。 12345678fun main(args: Array&lt;String&gt;) &#123; launch(CommonPool) &#123; // create new coroutine in common thread pool delay(1000L) // non-blocking delay for 1 second (default time unit is ms) println(\"World!\") // print after delay &#125; println(\"Hello,\") // main function continues while coroutine is delayed Thread.sleep(2000L) // block main thread for 2 seconds to keep JVM alive &#125; 这个例子的运行结果是： 12Hello, World! 其实有了上一篇文章的基础我们很容易知道，launch 方法启动了一个协程，CommonPool 是一个有线程池的上下文，它可以负责把协程的执行分配到合适的线程上。所以从线程的角度来看，打印的这两句是在不同的线程上的。 1220170206-063015.015 [main] Hello, 20170206-063016.016 [ForkJoinPool.commonPool-worker-1] World! 这段代码的执行效果与线程的版本看上去是一样的： 123456thread(name = \"MyThread\") &#123; Thread.sleep(1000L) log(\"World!\") &#125; log(\"Hello,\") Thread.sleep(2000L) 3. 主线程上的协程我们刚才通过 launch 创建的协程是在 CommonPool 的线程池上面的，所以协程的运行并不在主线程。如果我们希望直接在主线程上面创建协程，那怎么办？ 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; launch(CommonPool) &#123; delay(1000L) println(\"World!\") &#125; println(\"Hello,\") delay(2000L) &#125; 这个还是 kotlinx.coroutines 的例子，我们来分析一下。runBlocking 实际上也跟 launch 一样，启动一个协程，只不过它传入的 context 不会进行线程切换，也就是说，由它创建的协程会直接运行在当前线程上。 在 runBlocking 当中通过 launch 再创建一个协程，显然，这段代码的运行结果与上一个例子是完全一样的。需要注意的是，尽管我们可以在协程中通过 launch 这样的方法创建协程，但不要再协程当中通过 runBlocking 再来创建协程，因为这样做虽然一般来说不会导致程序异常，不过，这样的程序也没有多大意义： 1234567fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; runBlocking &#123; delay(1000L) println(\"World!\") &#125; println(\"Hello,\") &#125; 运行结果： 12World! Hello, 大家看到了，嵌套的 runBlocking 实际上仍然只是一段顺序代码而已。 那么，让我们再仔细看看前面的例子，不知道大家有没有问题：如果我在 launch 创建的协程当中多磨叽一会儿，主线程上的协程 delay(2000L) 好像也没多大用啊。有没有什么方法保证协程执行完？ 4. 外部控制协程我们在上一篇文章当中只是对内置的基础 API 进行了简单的封装，而 kotlinx.coroutines 却为我们做了非常多的事情。比如，每一个协程都看做一个 Job，我们在一个协程的外部也可以控制它的运行。 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val job = launch(CommonPool) &#123; delay(1000L) println(\"World!\") &#125; println(\"Hello,\") job.join() &#125; job.join 其实就是要求当前协程等待 job 执行完成之后再继续执行。 其实，我们还可以取消协程，让他直接停止执行： 12345678fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val job = launch(CommonPool) &#123; delay(1000L) println(\"World!\") &#125; println(\"Hello,\") job.cancel() &#125; job.cancel 会直接终止 job 的执行。如果 job 已经执行完毕，那么 job.cancel 的执行时没有意义的。我们也可以根据 cancel 的返回值来判断是否取消成功。 另外，cancel 还可以提供原因： 1job.cancel(IllegalAccessException(\"World!\")) 如果我们提供了这个原因，那么被取消的协程会将它打印出来。 12345Hello, Exception in thread \"main\" java.lang.IllegalAccessException: World! at example13.Example_13Kt$main$1.doResume(example-13.kt:14) at kotlin.coroutines.experimental.jvm.internal.CoroutineImpl.resume(CoroutineImpl.kt:53) at kotlinx.coroutines.experimental.DispatchedContinuation$resume$1.run(CoroutineDispatcher.kt:57) 其实，如果你自己做过对线程任务的取消，你大概会知道除非被取消的线程自己去检查取消的标志位，或者被 interrupt，否则取消是无法实现的，这有点儿像一个人执意要做一件事儿，另一个人说你别做啦，结果人家压根儿没听见，你说他能停下来吗？那么我们前面的取消到底是谁去监听了这个 cancel 操作呢？ 当然是 delay 这个操作了。其实所有 kotlinx.coroutines 当中定义的操作都可以做到这一点，我们对代码稍加改动，你就会发现异常来自何处了： 123456789101112val job = launch(CommonPool) &#123; try &#123; delay(1000L) println(\"World!\") &#125; catch(e: Exception) &#123; e.printStackTrace() &#125;finally &#123; println(\"finally....\") &#125; &#125; println(\"Hello,\") job.cancel(IllegalAccessException(\"World!\")) 是的，你没看错，我们居然可以在协程里面对 cancel 进行捕获，如果你愿意的话，你甚至可以继续在这个协程里面运行代码，但请不要这样做，下面的示例破坏了 cancel 的设计本意，所以请勿模仿： 12345678val job = launch(CommonPool) &#123; try &#123; ... &#125;finally &#123; println(\"finally....\") &#125; println(\"I'm an EVIL!!! Hahahaha\") &#125; 说这个是什么意思呢？在协程被 cancel 掉的时候，我们应该做的其实是把战场打扫干净，比如： 12345678val job = launch(CommonPool) &#123; val inputStream = ... try &#123; ... &#125;finally &#123; inputStream.close() &#125;&#125; 我们再来考虑下面的情形： 123456789101112131415161718fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val job = launch(CommonPool) &#123; var nextPrintTime = 0L var i = 0 while (true) &#123; // computation loop val currentTime = System.currentTimeMillis() if (currentTime &gt;= nextPrintTime) &#123; println(\"I'm sleeping $&#123;i++&#125; ...\") nextPrintTime = currentTime + 500L &#125; &#125; &#125; delay(1300L) // delay a bit println(\"main: I'm tired of waiting!\") job.cancel() // cancels the job delay(1300L) // delay a bit to see if it was cancelled.... println(\"main: Now I can quit.\") &#125; 不得不说，kotlinx.coroutines 在几天前刚刚更新的文档和示例非常的棒。我们看到这个例子，while(true) 会让这个协程不断运行来模拟耗时计算，尽管外部调用了 job.cancel()，但由于内部并没有 care 自己是否被 cancel，所以这个 cancel 显然有点儿失败。如果你想要在类似这种耗时计算当中检测当前协程是否被取消的话，你可以这么写： 12345... while (isActive) &#123; // computation loop ... &#125; ... isActive 会在 cancel 之后被置为 false。 其实，通过这几个示例大家就会发现协程的取消，与我们通常取消线程操作的思路非常类似，只不过人家封装的比较好，而我们呢，每次还得自己搞一个 CancelableTask 来实现 Runnable 接口去承载自己的异步操作，想想也是够原始呢。 5. 轻量级线程协程时轻量级的，它拥有自己的运行状态，但它对资源的消耗却非常的小。其实能做到这一点的本质原因，我们已经在上一篇文章当中提到过，一台服务器开 1k 线程和 1k 协程来响应服务，前者对资源的消耗必然很大，而后者可能只是基于很少的几个或几十个线程来工作的，随着请求数量的增加，协程的优势可能会体现的更加明显。 我们来看个比较简单的例子： 123456789fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val jobs = List(100_000) &#123; launch(CommonPool) &#123; delay(1000L) print(\".\") &#125; &#125; jobs.forEach &#123; it.join() &#125; //这里不能用 jobs.forEach(Job::join)，因为 Job.join 是 suspend 方法 &#125; 通过 List 这个方法，我们可以瞬间创建出很多对象放入返回的 List，注意到这里的 jobs 其实就是协程的一个 List。 运行上面的代码，我们发现 CommonPool 当中的线程池的线程数量基本上维持在三四个就足够了，如果我们用线程来写上面的代码会是什么感觉？ 123456789fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123; val jobs = List(100_000) &#123; thread &#123; Thread.sleep(1000L) log(\".\") &#125; &#125; jobs.forEach(Thread::join) // Thread::join 说起来也是 1.1 的新特性呢！ &#125; 运行时，在创建了 1k 多个线程之后，就抛出了异常： 12Exception in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread at java.lang.Thread.start0(Native Method) 嗯，又多了一个用协程的理由，对不对？ 6. 携带值的 Job我们前面说了，通过携程返回的 Job，我们可以控制携程的运行。可有时候我们更关注协程运行的结果，比如从网络加载一张图片： 1234suspend fun loadImage(url: String): Bitmap &#123; ... return ... &#125; 没错，我们更关注它的结果，这种情况我们该怎么办呢？如果 loadImage 不是 suspend 方法，那么我们在非 UI 线程当中直接获取他们： 123val imageA = loadImage(urlA) val imageB = loadImage(urlB) onImageGet(imageA, imageB) 这样的操作有什么问题？顺序获取两张图片，耗时，不经济。所以传统的做法就是开两个线程做这件事儿，这意味着你会看到两个回调，并且还要同步这两个回调，想想都头疼。 不过我们现在有更好的办法： 123val imageA = defer(CommonPool) &#123; loadImage(urlA) &#125; val imageB = defer(CommonPool) &#123; loadImage(urlB) &#125; onImageGet(imageA.await(),imageB.await()) 代码量几乎没有增加，不过我们却做到了两张图片异步获取，并同时传给 onImageGet 以便继续后面的操作。 defer 到底是个什么东西？其实大家大可不必看到新词就感到恐慌，这东西用法几乎跟 launch 一样，只不过它返回的 Deferred 功能比 Job 多了一样：携带返回值。我们前面看到的 imageA 其实就是一个 Deferred 实例，而它的 await 方法返回的则是 Bitmap 类型，也即 loadImage(urlA) 的返回值。 所以如果你对协程运行的结果感兴趣，直接使用 defer 来替换你的 launch 就可以了。需要注意的是，即便你不调用 await，defer 启动的协程也会立即运行，如果你希望你的协程能够按需启动，例如只有你调用 await 之后再启动，那么你可以用 lazyDefer： 123val imageA = lazyDefer(CommonPool) &#123; loadImage(urlA) &#125; val imageB = lazyDefer(CommonPool) &#123; loadImage(urlB) &#125; onImageGet(imageA.await(),imageB.await()) //这时候才开始真正去加载图片 7. 生成器不知道大家对 python 的生成器有没有了解，这个感觉就好似延迟计算一样。 假设我们要计算 fibonacci 数列，这个大家都知道，也非常容易写，你可能分分钟写出一个递归的函数来求得这个序列，不过你应该知道递归的层级越多，stackOverflow 的可能性越大吧？另外，如果我们只是用到其中的几个，那么递归的函数一下子都给求出来，而且每次调用也没有记忆性导致同一个值计算多次，非常不经济。大家看一个 python 的例子： 12345678910111213def fibonacci(): yield 1 # 直接返回 1， 并且在此处暂停 first = 1 second = 1 while True: yield first first, second = first + second, first a = fibonacci() for x in a: print x if x &gt; 100: break 前面给出的这种计算方法，fibonacci 函数返回一个可迭代的对象，这个对象其实就是生成器，只有我们在迭代它的时候，它才会去真正执行计算，只要遇到 yield，那么这一次迭代到的值就是 yield 后面的值，比如，我们第一次调用 fibonacci 这个函数的时候，得到的值就是 1，后面依次类推。 Kotlin 在添加了协程这个功能之后，也可以这么搞了： 12345678910111213141516val fibonacci = buildSequence &#123; yield(1) // first Fibonacci number var cur = 1 var next = 1 while (true) &#123; yield(next) // next Fibonacci number val tmp = cur + next cur = next next = tmp &#125; &#125; ... for (i in fibonacci)&#123; println(i) if(i &gt; 100) break //大于100就停止循环 &#125; 可以这么说，这段代码与前面的 python 版本功能是完全相同的，在 yield 方法调用时，传入的值就是本次迭代的值。 fibonacci 这个变量的类型如下： 123public interface Sequence&lt;out T&gt; &#123; public operator fun iterator(): Iterator&lt;T&gt; &#125; 既然有 iterator 方法，那么我们可以直接对 fibonacci 进行迭代也就没什么大惊小怪的了。这个 iterator 保证每次迭代的时候去执行 buildSequence 后面的 Lambda 的代码，从上一个 yield 之后开始到下一个 yield 结束，yield 传入的值就是 iterator 的 next 的返回值。 有了这个特性，我们就可以构造许多“懒”序列，只有在用到的时候才去真正计算每一个元素的值，而且运算状态可以保存，每次计算的结果都不会浪费。 注：这个特性是被 Kotlin 标准库收录了的，并不存在于 kotlinx.coroutines 当中，不过这也没关系啦，kotlinx.coroutines 的 API 会不会在不久的将来也作为 Kotlin 标准库的内容出现呢？ 8. 小结这一篇的内容其实相对上一篇要简单一些，面对 kotlinx.coroutines 这样的框架，我们直接通过分析案例，将 coroutine 这么理论化的东西投入实际场景，让大家从感性上对其有个更加深入的认识。 当然，我们并没有深入其中了解其原理，原因就是上一篇我们为此做了足够的准备 —— kotlinx.coroutines 作为官方的框架，自然要实现得完善一些，但也是万变不离其宗。 写到这里，我想，我们还是需要有一篇文章再来介绍一些协程使用的一些注意事项，那么我们下一篇再见吧。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://www.Kotliner.cn/tags/Coroutine/"},{"name":"kotlinx","slug":"kotlinx","permalink":"http://www.Kotliner.cn/tags/kotlinx/"}]},{"title":"深入理解 Kotlin Coroutine","slug":"深入理解 Kotlin Coroutine","date":"2017-01-30T04:25:08.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/01/30/深入理解 Kotlin Coroutine/","link":"","permalink":"http://www.Kotliner.cn/2017/01/30/深入理解 Kotlin Coroutine/","excerpt":"","text":"本文主要介绍 Kotlin Coroutine 的基础 API，有关 Kotlinx.Coroutine 的内容，我们将在下一期给大家介绍。由于本人水平有限，如果大家有什么异议，欢迎直接抛出来跟我讨论~ 1 什么是 CoroutineCoroutine 被翻译成了“协程”，意思就是要各个子任务程协作运行的意思，所以大家一下就明白了它被创造出来是要解决异步问题的。 我们写 Java 的程序员，对线程更熟悉一些。线程是比进程更小一级的运行单位，它的调度由操作系统来完成，所以我们只管 new Thread 和 start，至于什么时候 run，什么时候 run 完，我们都没办法预见。 12Thread t = new Thread(task); t.start(); 尽管有诸多不可控的因素，不过我们可以肯定的是起了一个新的线程并启动它之后，当前线程并不会受到阻塞。如果大家再往深处想想，CPU 在任意时刻运行什么进程及其线程，是操作系统决定的，但归根结底一个单线程的 CPU 在任一时刻只能运行一个任务。 那么协程呢？协程的调度是应用层完成的，比如我们说 Lua 支持协程，那么各个协程如何运行，这一调度工作实际上是 Lua 自己的虚拟机来完成的。这个调度与线程调度有着比较大的差别，线程调度是抢占式调度，很有可能线程 A 运行得美滋滋的，线程 B 突然把 CPU 抢过来，跟 A 说“你给我下去吧你”，于是线程 A 只能干瞪眼没办法；而协程的调度是非抢占式的，目前常见的各支持协程的语言实现中都有 yield 关键字，它有“妥协、退让”的意思，如果一个协程执行到一段代码需要歇会儿，那么它将把执行权让出来，如果它不这么做，没人跟它抢。 在 接触 Kotlin 的协程之前呢，我们先给大家看一个 Lua 的例子，比较直观： 123456789101112131415161718function foo(a) print(\"foo\", a) return coroutine.yield(2 * a) end co = coroutine.create(function ( a, b ) print(\"co-body\", a, b) local r = foo(a + 1) print(\"co-body\", r) local r, s = coroutine.yield(a + b, a - b) print(\"co-body\", r, s) return b, \"end\" end) print(\"main\", coroutine.resume(co, 1, 10)) print(\"main\", coroutine.resume(co, \"r\")) print(\"main\", coroutine.resume(co, \"x\", \"y\")) print(\"main\", coroutine.resume(co, \"x\", \"y\")) 运行结果如下： 12345678co-body 1 10 foo 2 main true 4 co-body r main true 11 -9 co-body x y main true 10 end main false cannot resume dead coroutine 首先定义了一个 foo 函数，然后创建 coroutine，创建了之后还需要调用 resume 才能执行协程，运行过程是谦让的，是交替的： 图中数字表示第n次 协程为我们的程序提供了一种暂停的能力，就好像状态机，只有等到下一次输入，它才做状态转移。显然，用协程来描述一个状态机是再合适不过的了。 也许大家对 lua 的语法不是很熟悉，不过没关系，上面的例子只需要知道大概是在干什么就行：这例子就好像，main 和 Foo 在交替干活，有点儿像 A B 两个人分工协作，A 干一会儿 B 来，B 干一会儿，再让 A 来一样。如果我们用线程来描述这个问题，那么可能会用到很多回调，相信写 Js 的兄弟听到这儿要感到崩溃了，因为 Js 的代码写着写着就容易回调满天飞，业务逻辑的实现越来越抽象，可读性越来越差；而用协程的话，就好像一个很平常的同步操作一样，一点儿异步任务的感觉都没有。 我们前面提到的协程的非抢占调度方式，以及这个交替执行代码的例子，基本上可以说明协程实际上致力于用同步一样的代码来完成异步任务的运行。 一句话，有了协程，你的异步程序看起来就像同步代码一样。 2 Kotlin 协程初体验Kotlin 1.1 对协程的基本支持都在 Kotlin 标准库当中，主要涉及两个类和几个包级函数和扩展方法： CoroutineContext，协程的上下文，这个上下文可以是多个的组合，组合的上下文可以通过 key 来获取。EmptyCoroutineContext 是一个空实现，没有任何功能，如果我们在使用协程时不需要上下文，那么我们就用这个对象作为一个占位即可。上下文这个东西，不管大家做什么应用，总是能遇到，比如 Android 里面的 Context，JSP 里面的 PageContext 等等，他们扮演的角色都大同小异：资源管理，数据持有等等，协程的上下文也基本上是如此。 Continuation，顾名思义，继续、持续的意思。我们前面说过，协程提供了一种暂停的能力，可继续执行才是最终的目的，Continuation 有两个方法，一个是 resume，如果我们的程序没有任何异常，那么直接调用这个方法并传入需要返回的值；另一个是 resumeWithException，如果我们的程序出了异常，那我们可以通过调用这个方法把异常传递出去。 协程的基本操作，包括创建、启动、暂停和继续，继续的操作在 Continuation 当中，剩下的三个都是包级函数或扩展方法： 这几个类和函数其实与我们前面提到的 Lua 的协程 API 非常相似，都是协程最基础的 API。 除此之外，Kotlin 还增加了一个关键字：suspend，用作修饰会被暂停的函数，被标记为 suspend 的函数只能运行在协程或者其他 suspend 函数当中。 好，介绍完这些基本概念，让我们来看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647fun main(args: Array&lt;String&gt;) &#123; log(\"before coroutine\") //启动我们的协程 asyncCalcMd5(\"test.zip\") &#123; log(\"in coroutine. Before suspend.\") //暂停我们的线程，并开始执行一段耗时操作 val result: String = suspendCoroutine &#123; continuation -&gt; log(\"in suspend block.\") continuation.resume(calcMd5(continuation.context[FilePath]!!.path)) log(\"after resume.\") &#125; log(\"in coroutine. After suspend. result = $result\") &#125; log(\"after coroutine\") &#125; /** * 上下文，用来存放我们需要的信息，可以灵活的自定义 */ class FilePath(val path: String): AbstractCoroutineContextElement(FilePath)&#123; companion object Key : CoroutineContext.Key&lt;FilePath&gt; &#125; fun asyncCalcMd5(path: String, block: suspend () -&gt; Unit) &#123; val continuation = object : Continuation&lt;Unit&gt; &#123; override val context: CoroutineContext get() = FilePath(path) override fun resume(value: Unit) &#123; log(\"resume: $value\") &#125; override fun resumeWithException(exception: Throwable) &#123; log(exception.toString()) &#125; &#125; block.startCoroutine(continuation) &#125; fun calcMd5(path: String): String&#123; log(\"calc md5 for $path.\") //暂时用这个模拟耗时 Thread.sleep(1000) //假设这就是我们计算得到的 MD5 值 return System.currentTimeMillis().toString() &#125; 这段程序在模拟计算文件的 Md5 值。我们知道，文件的 Md5 值计算是一项耗时操作，所以我们希望启动一个协程来处理这个耗时任务，并在任务运行结束时打印出来计算的结果。 我们先来一段一段分析下这个示例： 123456/** * 上下文，用来存放我们需要的信息，可以灵活的自定义 */ class FilePath(val path: String): AbstractCoroutineContextElement(FilePath)&#123; companion object Key : CoroutineContext.Key&lt;FilePath&gt; &#125; 我们在计算过程中需要知道计算哪个文件的 Md5，所以我们需要通过上下文把这个路径传入协程当中。如果有多个数据，也可以一并添加进去，在运行当中，我们可以通过 Continuation 的实例拿到上下文，进而获取到这个路径： 1continuation.context[FilePath]!!.path 接着，我们再来看下 Continuation： 123456789101112val continuation = object : Continuation&lt;Unit&gt; &#123; override val context: CoroutineContext get() = FilePath(path) override fun resume(value: Unit) &#123; log(\"resume: $value\") &#125; override fun resumeWithException(exception: Throwable) &#123; log(exception.toString()) &#125; &#125; 我们除了给定了 FilePath 这样一个上下文之外就是简单的打了几行日志，比较简单。这里传入的 Continuation 当中的 resume 和 resumeWithException 只有在协程最终执行完成后才会被调用，这一点需要注意一下，也正是因为如此，startCoroutine 把它叫做 completion： 1public fun &lt;T&gt; (suspend () -&gt; T).startCoroutine(completion: Continuation&lt;T&gt; 那么下面我们看下最关键的这段代码： 1234567891011asyncCalcMd5(\"test.zip\") &#123; log(\"in coroutine. Before suspend.\") //暂停我们的协程，并开始执行一段耗时操作 val result: String = suspendCoroutine &#123; continuation -&gt; log(\"in suspend block.\") continuation.resume(calcMd5(continuation.context[FilePath]!!.path)) log(\"after resume.\") &#125; log(\"in coroutine. After suspend. result = $result\") &#125; suspendCoroutine 这个方法将外部的代码执行权拿走，并转入传入的 Lambda 表达式中，而这个表达式当中的操作就对应异步的耗时操作了，在这里我们“计算”出了 Md5 值，接着调用 将结果传了出去，传给了谁呢？传给了 suspendCoroutine 的返回值也即 result，这时候协程继续执行，打印 result 结束。12下面就是运行结果了： 2017-01-30T06:43:52.284Z [main] before coroutine 2017-01-30T06:43:52.422Z [main] in coroutine. Before suspend. 2017-01-30T06:43:52.423Z [main] in suspend block. 2017-01-30T06:43:52.423Z [main] calc md5 for test.zip. 2017-01-30T06:43:53.426Z [main] after resume. 2017-01-30T06:43:53.427Z [main] in coroutine. After suspend. result = 1485758633426 2017-01-30T06:43:53.427Z [main] resume: 1485758633426 2017-01-30T06:43:53.427Z [main] after coroutine123456789101112131415161718细心的读者肯定一看就发现，所谓的异步操作是怎么个异步法？从日志上面看，明明上面这段代码就是顺序执行的嘛，不然 after coroutine 这句日志为什么非要等到最后才打印？还有，整个程序都只运行在了主线程上，我们的日志足以说明这一点了，根本没有异步嘛。难道说协程就是一个大骗子？？## 3 实现异步这一部分我们就要回答上一节留下的问题。不过在此之前，我们再来回顾一下协程存在的意义：让异步代码看上去像同步代码，直接自然易懂。至于它如何做到这一点，可能各家的语言实现各有不同，但协程给人的感觉更像是底层并发 API（比如线程）的语法糖。当然，如果你愿意，我们通常所谓的线程也可以被称作操作系统级 API 的语法糖了吧，毕竟各家语言对于线程的实现也各有不同，这个就不是我们今天要讨论的内容了。不管怎么样，你只需要知道，协程的异步需要依赖比它更底层的 API 支持，那么在 Kotlin 当中，这个所谓的底层 API 就非线程莫属了。知道了这一点，我们就要考虑想办法来把前面的示例完善一下了。首先我们实例化一个线程池：```kotlin private val executor = Executors.newSingleThreadScheduledExecutor &#123; Thread(it, &quot;scheduler&quot;) &#125; 接着我们把计算 Md5 的部分交给线程池去运行： 1234567891011121314asyncCalcMd5(\"test.zip\") &#123; log(\"in coroutine. Before suspend.\") //暂停我们的线程，并开始执行一段耗时操作 val result: String = suspendCoroutine &#123; continuation -&gt; log(\"in suspend block.\") executor.submit &#123; continuation.resume(calcMd5(continuation.context[FilePath]!!.path)) log(\"after resume.\") &#125; &#125; log(\"in coroutine. After suspend. result = $result\") executor.shutdown() &#125; 那么结果呢？ 123456782017-01-30T07:18:04.496Z [main] before coroutine 2017-01-30T07:18:04.754Z [main] in coroutine. Before suspend. 2017-01-30T07:18:04.757Z [main] in suspend block. 2017-01-30T07:18:04.765Z [main] after coroutine 2017-01-30T07:18:04.765Z [scheduler] calc md5 for test.zip. 2017-01-30T07:18:05.769Z [scheduler] in coroutine. After suspend. result = 1485760685768 2017-01-30T07:18:05.769Z [scheduler] resume: 1485760685768 2017-01-30T07:18:05.769Z [scheduler] after resume. 我们看到在协程被暂停的那一刻，协程外面的代码被执行了。一段时间之后，协程被继续执行，打印结果。 截止到现在，我们用协程来实现异步操作的功能已经实现。 你可能要问，如果我们想要完成异步操作，直接用线程池加回调岂不更直接简单，为什么要用协程呢，搞得代码这么让人费解不说，也没有变的很简单啊。 说的对，如果我们实际当中把协程的代码都写成这样，肯定会被蛋疼死，我前面展示给大家的，是 Kotlin 标准库当中最为基础的 API，看起来非常的原始也是理所应当的，如果我们对其加以封装，那效果肯定大不一样。 除此之外，在高并发的场景下，多个协程可以共享一个或者多个线程，性能可能会要好一些。举个简单的例子，一台服务器有 1k 用户与之连接，如果我们采用类似于 Tomcat 的实现方式，一个用户开一个线程去处理请求，那么我们将要开 1k 个线程，这算是个不小的数目了；而我们如果使用协程，为每一个用户创建一个协程，考虑到同一时刻并不是所有用户都需要数据传输，因此我们并不需要同时处理所有用户的请求，那么这时候可能只需要几个专门的 IO 线程和少数来承载用户请求对应的协程的线程，只有当用户有数据传输事件到来的时候才去相应，其他时间直接挂起，这种事件驱动的服务器显然对资源的消耗要小得多。 4 进一步封装**这一节的内容较多的参考了 Kotlin 官方的 Coroutine Example，里面有更多的例子，大家可以参考学习。 4.1 异步刚才那个示例让我们感觉到，写个协程调用异步代码实在太原始了，所以我们决定对它做一下封装。如果我们能在调用 suspendCoroutine 的时候直接把后面的代码拦截，并切到线程池当中执行，那么我们就不用每次自己搞一个线程池来做这事儿了，嗯，让我们研究下有什么办法可以做到这一点。 拦截。。。怎么拦截呢？ 12345public interface ContinuationInterceptor : CoroutineContext.Element &#123; companion object Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt; public fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; &#125; 我们发现，Kotlin 的协程 API 当中提供了这么一个拦截器，可以把协程的操作拦截，传入的是原始的 Continuation，返回的是我们经过线程切换的 Continuation，这样就可以实现我们的目的了。 123456789101112131415161718192021222324252627282930open class Pool(val pool: ForkJoinPool) : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123; override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;) : Continuation&lt;T&gt; = PoolContinuation(pool, //下面这段代码是要查找其他拦截器，并保证能调用它们的拦截方法 continuation.context.fold(continuation, &#123; cont, element -&gt; if (element != this@Pool &amp;&amp; element is ContinuationInterceptor) element.interceptContinuation(cont) else cont &#125;)) &#125; private class PoolContinuation&lt;T&gt;( val pool: ForkJoinPool, val continuation: Continuation&lt;T&gt; ) : Continuation&lt;T&gt; by continuation &#123; override fun resume(value: T) &#123; if (isPoolThread()) continuation.resume(value) else pool.execute &#123; continuation.resume(value) &#125; &#125; override fun resumeWithException(exception: Throwable) &#123; if (isPoolThread()) continuation.resumeWithException(exception) else pool.execute &#123; continuation.resumeWithException(exception) &#125; &#125; fun isPoolThread(): Boolean = (Thread.currentThread() as? ForkJoinWorkerThread)?.pool == pool &#125; 这个 Pool 是什么鬼？我们让它继承 AbstractCoroutineContextElement 表明它其实就是我们需要的上下文。实际上这个上下文可以给任意协程使用，于是我们再定义一个 object： 1object CommonPool : Pool(ForkJoinPool.commonPool()) 有了这个，我们就可以把没加线程池的版本改改了： 12345678910111213141516171819202122232425fun main(args: Array&lt;String&gt;) &#123; log(\"before coroutine\") //启动我们的协程 asyncCalcMd5(\"test.zip\") &#123; ... &#125; log(\"after coroutine\") //加这句的原因是防止程序在协程运行完之前停止 CommonPool.pool.awaitTermination(10000, TimeUnit.MILLISECONDS) &#125; ... fun asyncCalcMd5(path: String, block: suspend () -&gt; String) &#123; val continuation = object : Continuation&lt;String&gt; &#123; override val context: CoroutineContext //注意这个写法，上下文可以通过 + 来组合使用 get() = FilePath(path) + CommonPool ... &#125; block.startCoroutine(continuation) &#125; ... 那么运行结果呢？ 123456782017-01-30T09:13:11.183Z [main] before coroutine 2017-01-30T09:13:11.334Z [main] after coroutine 2017-01-30T09:13:11.335Z [ForkJoinPool.commonPool-worker-1] in coroutine. Before suspend. 2017-01-30T09:13:11.337Z [ForkJoinPool.commonPool-worker-1] in suspend block. 2017-01-30T09:13:11.337Z [ForkJoinPool.commonPool-worker-1] calc md5 for test.zip. 2017-01-30T09:13:12.340Z [ForkJoinPool.commonPool-worker-1] after resume. 2017-01-30T09:13:12.341Z [ForkJoinPool.commonPool-worker-1] in coroutine. After suspend. result = 1485767592340 2017-01-30T09:13:12.341Z [ForkJoinPool.commonPool-worker-1] resume: 1485767592340 我们看到程序已经非常完美的实现异步调用。显然，这种写法要比线程池回调的写法看上去顺理成章得多。 4.2 启动协程在讨论完异步的封装后，有人肯定还是会提出新问题：启动协程的写法是不是有点儿啰嗦了啊？没错，每次构造一个 Continuation，也没干多少事儿，实在没什么必要，干脆封装一个通用的版本得了： 123456789class StandaloneCoroutine(override val context: CoroutineContext): Continuation&lt;Unit&gt; &#123; override fun resume(value: Unit) &#123;&#125; override fun resumeWithException(exception: Throwable) &#123; //处理异常 val currentThread = Thread.currentThread() currentThread.uncaughtExceptionHandler.uncaughtException(currentThread, exception) &#125; &#125; 这样就好办了，我们每次启动协程只需要针对当前协程提供特定的上下文即可，那么我们是不是再把启动的那个函数改改呢？ 12fun launch(context: CoroutineContext, block: suspend () -&gt; Unit) = block.startCoroutine(StandaloneCoroutine(context)) 有了这个，我们前面的代码就可以进一步修改： 12345678910111213141516171819202122232425262728293031fun main(args: Array&lt;String&gt;) &#123; log(\"before coroutine\") //启动我们的协程 launch(FilePath(\"test.zip\") + CommonPool) &#123; log(\"in coroutine. Before suspend.\") //暂停我们的线程，并开始执行一段耗时操作 val result: String = suspendCoroutine &#123; continuation -&gt; log(\"in suspend block.\") continuation.resume(calcMd5(continuation.context[FilePath]!!.path)) log(\"after resume.\") &#125; log(\"in coroutine. After suspend. result = $result\") &#125; log(\"after coroutine\") CommonPool.pool.awaitTermination(10000, TimeUnit.MILLISECONDS) &#125; /** * 上下文，用来存放我们需要的信息，可以灵活的自定义 */ class FilePath(val path: String) : AbstractCoroutineContextElement(Key) &#123; companion object Key : CoroutineContext.Key&lt;FilePath&gt; &#125; fun calcMd5(path: String): String &#123; log(\"calc md5 for $path.\") //暂时用这个模拟耗时 Thread.sleep(1000) //假设这就是我们计算得到的 MD5 值 return System.currentTimeMillis().toString() &#125; 运行结果自然也没什么好说的。 4.3 暂停协程暂停协程这块儿也太乱了，看着莫名其妙的，能不能直白一点儿呢？其实我们的代码不过是想要获取 Md5 的值，所以如果能写成下面这样就好了： 1val result = calcMd5(continuation.context[FilePath]!!.path).await() 毋庸置疑，这肯定是可以的。想一下，有哪个类可以支持我们直接阻塞线程，等到获取到结果之后再返回呢？当然是 Future 了。 123456789suspend fun &lt;T&gt; CompletableFuture&lt;T&gt;.await(): T &#123; return suspendCoroutine &#123; continuation -&gt; whenComplete &#123; result, e -&gt; if (e == null) continuation.resume(result) else continuation.resumeWithException(e) &#125; &#125; &#125; 我们干脆就直接给 CompletableFuture 定义一个扩展方法，当中只是用来挂起协程，并在结果拿到之后继续执行协程。这样，我们的代码可以进一步修改： 1234567891011121314151617181920212223fun main(args: Array&lt;String&gt;) &#123; log(\"before coroutine\") //启动我们的协程 val coroutineContext = FilePath(\"test.zip\") + CommonPool launch(coroutineContext) &#123; log(\"in coroutine. Before suspend.\") //暂停我们的线程，并开始执行一段耗时操作 val result: String = calcMd5(coroutineContext[FilePath]!!.path).await() log(\"in coroutine. After suspend. result = $result\") &#125; log(\"after coroutine\") CommonPool.pool.awaitTermination(10, TimeUnit.SECONDS) &#125; fun calcMd5(path: String): CompletableFuture&lt;String&gt; = CompletableFuture.supplyAsync &#123; log(\"calc md5 for $path.\") //暂时用这个模拟耗时 Thread.sleep(1000) //假设这就是我们计算得到的 MD5 值 System.currentTimeMillis().toString() &#125; ... 省略掉一些没有修改的代码 ... 4.4 带有 Receiver 的协程不知道大家注意到没有， 4.3 的代码中有个地方比较别扭： 1234567val coroutineContext = FilePath(\"test.zip\") + CommonPool launch(coroutineContext) &#123; ... //在协程内部想要访问上下文居然需要用到外部的变量 val result: String = calcMd5(coroutineContext[FilePath]!!.path).await() ... &#125; 在协程内部想要访问上下文居然需要用到外部的变量。这个上下文毕竟是协程自己的，自己居然没有办法直接获取到，一点儿都不自然。 其实这也不是没有办法，startCoroutine 其实还有一个带 receiver 的版本： 123public fun &lt;R, T&gt; (suspend R.() -&gt; T).startCoroutine( receiver: R, completion: Continuation&lt;T&gt; 也就是说，我们不仅可以传入一个独立的函数作为协程的代码块，还可以将一个对象的方法传入，也就是说，我们完全可以在启动协程的时候为它指定一个 receiver： 12345fun &lt;T&gt; launch( receiver: T, context: CoroutineContext, block: suspend T.() -&gt; Unit) = block.startCoroutine(receiver, StandaloneCoroutine(context)) 我们修改了 launch，加入了 receiver，于是我们的代码也可以这么改： 12345678val coroutineContext = FilePath(\"test.zip\") + CommonPool //需要传入 receiver launch(coroutineContext, coroutineContext) &#123; ... //注意下面直接用 this 来获取路径 val result: String = calcMd5(this[FilePath]!!.path).await() ... &#125; 如果你觉得绝大多数情况下 receiver 都会是上下文那么上面的代码还可以接着简化： 1234fun launchWithContext( context: CoroutineContext, block: suspend CoroutineContext.() -&gt; Unit) = launch(context, context, block) 123456launchWithContext(FilePath(\"test.zip\") + CommonPool) &#123; log(\"in coroutine. Before suspend.\") //暂停我们的线程，并开始执行一段耗时操作 val result: String = calcMd5(this[FilePath]!!.path).await() log(\"in coroutine. After suspend. result = $result\") &#125; 截止到现在，我们对最初的代码做了各种封装，这些封装后的代码可以在各种场景下直接使用，于是我们的协程代码也得到了大幅简化。另外，不知道大家有没有注意到，协程当中异常的处理也要比直接用线程写回调的方式容易的多，我们只需要在 Continuation 当中覆写 resumeWithException 方法就可以做到这一点。 5 拿来主义：Kotlinx.CoroutineKotlinx.Coroutine 是官方单独发出来的一个 Coroutine 的库，这个库为什么没有随着标准库一并发出来，想必大家从其包名就能略窥一二：kotlinx.coroutines.experimental，experimental，还处于试验阶段。不过既然敢随着 1.1 Beta 一并发出来，也说明后面的大方向不会太远，大家可以直接开始尝试其中的 API 了。 应该说，Kotlinx.Coroutine 做的事情跟我们在上一节做的事情是相同的，只不过它在这个方向上面走的更远。有关它的一些用法和细节，我们将在下一期给大家介绍。 6 小结本文主要对 Kotlin 1.1Beta 标准库的 Coroutine API 做了介绍，也给出了相应的示例向大家展示 Coroutine 能为我们带来什么。 协程是干什么的？是用来让异步代码更具表现力的。如果运用得当，它将让我们免于回调嵌套之苦，并发加锁之痛，使我们能够利用我们有限的时间写出更有魅力的程序。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://www.Kotliner.cn/tags/Coroutine/"},{"name":"基础Api","slug":"基础Api","permalink":"http://www.Kotliner.cn/tags/基础Api/"}]},{"title":"如何优雅的在微信公众号中编辑代码","slug":"如何优雅的在微信公众号中编辑代码","date":"2017-01-30T04:25:08.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/01/30/如何优雅的在微信公众号中编辑代码/","link":"","permalink":"http://www.Kotliner.cn/2017/01/30/如何优雅的在微信公众号中编辑代码/","excerpt":"","text":"这篇文章严格意义上是写给有公众号且公众号文章需要贴代码的朋友们看的。 1 公众号编辑器真难用自从入坑公众号以来，被公众号的这个编辑器简直折磨死了。我发的文章基本上是少不了贴代码的，可是每次贴上去的代码总是被公众号的编辑器无厘头的给我过滤掉换行符，简直气死人。 例如我编辑得好好的代码， 12345Person person = new Person(\"benny\", 27); System.out.println(person.getName() + \" is \" + person.age); //benny is 27 person.setName(\"andy\"); person.age = 26; System.out.println(person.getName() + \" is \" + person.age); //andy is 26 贴上去就成了这样： 1Person person = new Person(\"benny\", 27);System.out.println(person.getName() + \" is \" + person.age); //benny is 27person.setName(\"andy\");person.age = 26;System.out.println(person.getName() + \" is \" + person.age); //andy is 26 每次一段代码一段代码的敲回车，简直敲到手抽筋。醉了。 这还不算，这个格式的代码发到手机上，还不能水平滚动，各种任性的折行，让本来清秀的代码看起来真是一坨一坨的。 2 分析下原因查了一下，不少同行都在因为这个而感到苦恼，大家分析得出的结论是微信公众号的编辑器会对我们贴上去的内容进行处理，而处理的过程中又会对一些换行符进行过滤，导致本来排好的代码乱成一团。 3 几种常见的贴代码的方法3.1 贴图法对于这种情况，最直接的方法自然是用工具渲染好，然后截图贴到公众号的编辑器里面。也可以写一个工具把代码自动绘成图片。 优点：简单直接，在找到更好的办法之前，我之前的几篇文章都是这么处理的。 缺点：操作繁琐，除了生成图片或者截图，还要手动贴到公众号编辑器中，截图时对于代码的文字清晰度控制也不太容易，贴到编辑器之后，还会被压缩，导致代码不容易被看清楚。当然，另一个更大的硬伤就是读者阅读的时候会耗费比较多的流量，如果网速不好还会加载不出来。 3.2 Markdown Here很多朋友都提到 Markdown Here，这是一个非常棒的 Chrome 插件，大家可以搜索并添加它，安装之后可以在 Options 当中选择自己喜欢的主题，之后只要在选中编辑框，贴入 Markdown 源码，再点击插件的按钮即可。 不过。。这个插件同样不能幸免于换行符的过滤，如果我们在微信公众号编辑器当中贴入 md 源码，按照上述操作渲染出漂亮的格式，保存之后预览，你就会发现这个办法其实并不怎么好用，或者说基本上不能用。 优点：这插件真的很棒。 缺点：因为渲染后的格式还是会惨遭微信公众号的编辑器的毒手，也就是说，你得自己手动处理一下换行的问题。 3.3 渲染好的格式直接贴我们前面说，可以先把 md 源码渲染好，然后直接复制粘贴到公众号的编辑器当中，结果其实与 Markdown Here 的效果完全一样。说到底是换行符被过滤的问题。 我一直用的 md 工具是 MacDown，可以直接先用它编辑好文章，然后复制渲染结果贴到微信公众号当中，自行处理一下换行的问题即可。 优点：本地编辑，方便快捷。 缺点：一样，还是换行符的问题。 3.4 其他什么编辑器当你在搜索引擎里面搜索这个问题的时候，大多数回答可能是推荐你用一些第三方的编辑器，比如 什么 135 编辑器之类的，这些编辑器对于不写代码的朋友来说，真的挺好用的，里面提供了各式各样的模板，大家只要把文字准备好，一套用就立马狂拽酷炫吊炸天。 可是，它们并不是为我们这些码农准备的啊，你想想公众号绝大多数的运营者都是编辑，而不是程序员，他们根本不需要关心什么是代码，更不需要关心怎么把代码排版好（我相信微信公众号编辑器的开发小伙伴大概也是这么想的吧，这么久了这编辑器还是这鬼样子）。 第三方编辑器很多，不过，当你一个一个去试的时候，你会发现这条路根本不通！！ 优点：适合编辑各种花哨的文字和图片。 缺点：不支持代码的格式。 4 目前最优雅的方案诞生记说实在的这个方案没有很高端。我们的痛点其实就是想个办法不让微信公众号编辑器对贴到里面的代码进行换行符的过滤。 有朋友提出把渲染后的结果每行都用 替换 \\n，这样过滤时，换行自然就不会被干掉了。 123456789101112&lt;code class=\"hljs language-java\" style=\"...\"&gt;Person person = &lt;span class=\"hljs-keyword\" style=\"color: rgb(170, 13, 145);\"&gt;new&lt;/span&gt; Person(&lt;span class=\"hljs-string\" style=\"color: rgb(196, 26, 22);\"&gt;\"benny\"&lt;/span&gt;, &lt;span class=\"hljs-number\" style=\"color: rgb(28, 0, 207);\"&gt;27&lt;/span&gt;); System.out.println(person.getName() + &lt;span class=\"hljs-string\" style=\"color: rgb(196, 26, 22);\"&gt;\" is \"&lt;/span&gt; + person.age); &lt;span class=\"hljs-comment\" style=\"color: rgb(0, 106, 0);\"&gt;//benny is 27&lt;/span&gt; person.setName(&lt;span class=\"hljs-string\" style=\"color: rgb(196, 26, 22);\"&gt;\"andy\"&lt;/span&gt;); person.age = &lt;span class=\"hljs-number\" style=\"color: rgb(28, 0, 207);\"&gt;26&lt;/span&gt;; System.out.println(person.getName() + &lt;span class=\"hljs-string\" style=\"color: rgb(196, 26, 22);\"&gt;\" is \"&lt;/span&gt; + person.age); &lt;span class=\"hljs-comment\" style=\"color: rgb(0, 106, 0);\"&gt;//andy is 26&lt;/span&gt; &lt;/code&gt; 这就是 md 渲染后的结果，代码对应于文章开头的例子。我们发现所有的代码被放到 code 这个标签当中，如果我们在其中用 替换 \\n 会发生什么呢？ 1234Person person = new Person(\"benny\", 27); System.out.println(person.getName() + \" is \" + person.age); //benny is 27 person.setName(\"andy\");&lt;br&gt;person.age = 26; System.out.println(person.getName() + \" is \" + person.age); //andy is 26 被直接显示出来了。根本不能用来换行。所以直接从结果入手好像没那么简单。那怎么办，我们干脆修改渲染方式吗？针对每行，用 ``````\">标签包起来不就可以换行了吗？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263想法挺好啊。想到这里我就开始准备去修改 Markdown Here 的源码了。。。可，尼玛，我不是搞前端的，一片一片的 js 代码我该修改哪里呢？这下可尴尬了。此路通，可能成本还是有点儿高了。于是我又回到原点，思考如何欺骗微信公众号编辑器那个换行符不能被过滤的问题。怎么骗呢？关键是，公众号的编辑器通过识别怎样的 pattern 来过滤换行符呢？如果我找到这个 pattern，然后把它破坏掉，不就可以了么？经过一番尝试发现：* 每一行代码的前后各加一个空格，那么正常有内容的行末换行符就不会被过滤* 空行替换成“英文空格+中文空格+英文空格”，这样在微信公众号编辑器看起来似乎不是空行，不过在我们看来其实是空行于是我动手写了一个简单的 python 脚本，那么后续我只要用 MacDown 编辑好我的文章，再用下面这个脚本自动为所有的代码加上空格、替换空行，那么我再把渲染好的文章贴到公众号的话，大功就告成了。附上非常简单的脚本代码：```py #!/usr/local/bin/python import sys, re CODE_PATTERN_START = r&quot;^\\s*```\\s*\\w*$&quot; CODE_PATTERN_END = r&quot;^\\s*```\\s*$&quot; if len(sys.argv) &lt; 2: print &quot;参数不正确.&quot; exit() inputFile = open(sys.argv[1]) output = [] while True: line = inputFile.readline() if line: if re.match(CODE_PATTERN_START, line): output.append(line) while True: line = inputFile.readline() if re.match(CODE_PATTERN_END, line): output.append(line) break if line.strip(): line = &quot; &quot; + line line = line.replace(&quot;\\n&quot;, &quot; \\n&quot;) print line else: print &quot;空行&quot; line = &quot; \\n&quot; output.append(line) else: output.append(line) else: break inputFile.close() outputFile = open(sys.argv[1], &apos;w+&apos;) outputFile.writelines(output) outputFile.close() 5 小结这种方法应该算不上一个最终的方案（最终方案应该是公众号编辑器的开发该考虑的事儿），但它成本比较低，输出效果也比较不错，希望能给大家带来帮助。","raw":null,"content":null,"categories":[{"name":"其他","slug":"其他","permalink":"http://www.Kotliner.cn/categories/其他/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://www.Kotliner.cn/tags/微信公众号/"},{"name":"编辑代码","slug":"编辑代码","permalink":"http://www.Kotliner.cn/tags/编辑代码/"}]},{"title":"勘误：15 Kotlin 与 Java 共存 (2)","slug":"勘误：15 Kotlin 与 Java 共存 (2) ","date":"2017-01-30T04:25:08.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/01/30/勘误：15 Kotlin 与 Java 共存 (2) /","link":"","permalink":"http://www.Kotliner.cn/2017/01/30/勘误：15 Kotlin 与 Java 共存 (2) /","excerpt":"","text":"在过去推送过的第15期视频中，涉及到一个泛型对比的点，当时文中提到“对于循环引用泛型参数的情况，Kotlin 无法实现”的结论是有问题的。感谢 @zhangdatou 指正，对应部分的内容修改如下： 3 泛型整体上来讲，Kotlin 的泛型与 Java 的没什么大的差别，Java 的 ? 在 Kotlin 中变成了 *，毕竟 ? 在 Kotlin 当中用处大着呢。另外，Java 泛型的上限下限的表示法在 Kotlin 当中变成了 out 和 in。 不过，由于 Java 1.5 之前并没有泛型的概念，为了兼容旧版本，1.5 之后的 Java 仍然允许下面的写法存在： 123456List list = new ArrayList(); list.add(\"Hello\"); list.add(1); for (Object o : list) &#123; System.out.println(o); &#125; 而对应的，在 Kotlin 当中要用 List&lt;*&gt; 来表示 Java 中的 List —— 这本身没什么问题。那么我们现在再看一段代码： 1234567public abstract class View&lt;P extends Presenter&gt;&#123; protected P presenter; &#125; public abstract class Presenter&lt;V extends View&gt;&#123; protected V view; &#125; 这个其实是现在比较流行的 MVP 设计模式的一个简单的接口，我希望通过泛型来绑定 V-P，并且我可以通过泛型参数在运行时直接反射实例化一个 presenter 完成 V-P 的实例注入，这在 Java 当中是没有问题的。 那么在 Kotlin 当中呢？ 因为我们知道 View 和 Presenter 都有泛型参数的，所以我们在 Kotlin 当中就要这么写： 1234567abstract class View&lt;P : Presenter&lt;out View&lt;out Presenter&lt;out View&lt;...&gt;&gt;&#123; protected abstract val presenter: P &#125; abstract class Presenter&lt;out V : View&lt;out Presenter&lt;out View&lt;...&gt;&gt;&gt;&gt;&#123; protected abstract val view: V &#125; 一直写下去，最终陷入了死循环。编译器给出的解释是： This type parameter violates the Finite Bound Restriction. 在 @zhangdatou 给我发邮件之前，我曾一直对此耿耿于怀，Kotlin 这么优秀的语言怎么还会有做不到的事情呢。原来不是做不到，而是我没有想到： 12345abstract class View&lt;out P: Presenter&lt;View&lt;P&gt;&gt;&gt; abstract class Presenter&lt;out V: View&lt;Presenter&lt;V&gt;&gt;&gt; class MyView: View&lt;MyPresenter&gt;() class MyPresenter: Presenter&lt;MyView&gt;() 实际上我们需要 View 的泛型参数 P 只要是 Presenter 的子类即可，并且要求这个泛型参数 P 本身对应的泛型参数也需要是 View 的子类，而这个 View 其实就是最初的那个 View，那么这个 View 的泛型参数当然就是 P 了。有点儿绕，但这么写出来明显感觉比 Java 安全靠谱多了。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"http://www.Kotliner.cn/tags/泛型/"}]},{"title":"用 Kotlin 写 Android 02 说说 Anko","slug":"用 Kotlin 写 Android 02 说说 Anko","date":"2017-01-23T04:46:49.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/01/23/用 Kotlin 写 Android 02 说说 Anko/","link":"","permalink":"http://www.Kotliner.cn/2017/01/23/用 Kotlin 写 Android 02 说说 Anko/","excerpt":"","text":"上周的文章其实我们提到了 Anko 的，不过我们只是给大家展示了一下 find 方法。除了这个之外，还有哪些好玩的东西呢？ 1、简化页面操作我们写 Android 最先做的是什么？当然是设置个 OnClickLisener，这样自然我的按钮听我的，我的地盘我做主了。 123hello.onClick &#123; startActivity&lt;AnotherActivity&gt;(\"from\" to \"MainActivity\")&#125; 哎哟，不错哦。其中 hello 是一个 TextView，我们通过 onClick 为其设置了一个 OnClickListener，这样看上去真是简洁不少。 123fun android.view.View.onClick(l: (v: android.view.View?) -&gt; Unit) &#123; setOnClickListener(l)&#125; 也没什么难理解的，onClick 是一个扩展方法，传入的 Lambda 表达式通过 SAM 转换成了 OnClickListener，一切都是这么的自然。如果你对传入的 view 感兴趣，你当然可以直接用 it 召唤它： 1234hello.onClick &#123; Log.d(TAG, it.toString()) startActivity&lt;AnotherActivity&gt;(\"from\" to \"MainActivity\")&#125; 简单吧。 等等！那个 startActivity 是怎么回事？没有 Intent 么？ 哈哈，这个嘛，且看源码： 12345678910111213inline fun &lt;reified T: Activity&gt; Context.startActivity(vararg params: Pair&lt;String, Any&gt;) &#123; AnkoInternals.internalStartActivity(this, T::class.java, params)&#125;...fun internalStartActivity( ctx: Context, activity: Class&lt;out Activity&gt;, params: Array&lt;out Pair&lt;String, Any&gt;&gt;) &#123; ctx.startActivity(createIntent(ctx, activity, params))&#125; 其实也没什么，就是对我们之前模板式的跳转写法做了简化而已，至于用到的 reified 和 Pair 也不算什么新鲜的东西，Pair 当中的 K-V 实际上就是我们通常放入 Intent 的 extra，所以我们自然可以在 AnotherActivity 当中取到这个值： 12345678910111213class AnotherActivity: AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) relativeLayout &#123; textView &#123; text = if(intent == null) \"from nowhere\" else intent.extras[\"from\"]?.toString() &#125; &#125; &#125;&#125; 取到我们传入的值，在 AnotherActivity 当中显示出来。有木有觉得要比我们用 Java 老大哥写出来的代码简洁易懂呢？ 2、聊聊 DSL 布局**再等等！那个 12345678910111213141516171819嗯，这个要多说几句了，Anko 这个框架虽然打着简化开发的旗号，不过野心终归还是不小的。它自己搞出一套用 Kotlin 写布局的 DSL，换句话说，有了 Anko 我们布局甚至可以不需要用 XML 了，也不需要像用 Java 硬编码 View 那么繁琐，只需要通过几句 DSL 就可以搞定。我们来多看几个例子：### 2.1 水平布局下面是是三个按钮水平等分布局的写法，我们用到的实际上就是线性布局，比较简单，button 的参数是按钮的文字（有较多重载的版本，大家可以酌情选择），lparams 的参数有三个，前两个分别是宽、高，最后一个是一个 Lambda 表达式，我们可以在这个Lambda表达式当中详细定义我们需要的布局，比如设置 margin 等等。```kotlinlinearLayout &#123; button(&quot;1&quot;).lparams(wrapContent, wrapContent)&#123; weight = 1f &#125; button(&quot;2&quot;).lparams(wrapContent, wrapContent)&#123; weight = 1f &#125; button(&quot;3&quot;).lparams(wrapContent, wrapContent)&#123; weight = 1f &#125;&#125; 效果图如下： 2.2 纵向布局还是线性布局，不过换了个方向，你当然可以这么写： 123456789101112linearLayout &#123; orientation = LinearLayout.VERTICAL button(\"1\").lparams(wrapContent, wrapContent)&#123; weight = 1f &#125; button(\"2\").lparams(wrapContent, wrapContent)&#123; weight = 1f &#125; button(\"3\").lparams(wrapContent, wrapContent)&#123; weight = 1f &#125;&#125; 不过，Anko 更倾向于让我们用这个： 1234567891011verticalLayout &#123; button(\"1\").lparams(wrapContent, wrapContent)&#123; weight = 1f &#125; button(\"2\").lparams(wrapContent, wrapContent)&#123; weight = 1f &#125; button(\"3\").lparams(wrapContent, wrapContent)&#123; weight = 1f &#125;&#125; 我给大家看一下源码，大家就分分钟明白了： 12345val VERTICAL_LAYOUT_FACTORY = &#123; ctx: Context -&gt; val view = _LinearLayout(ctx) view.orientation = LinearLayout.VERTICAL view&#125; 其实我们创建的 verticalLayout 最终是从这个方法当中获取的，没啥新鲜的，就是设置了一下 orientation 罢了。效果图我就不贴了，大家很容易猜得到。 2.3 相对布局12345678910111213141516171819202122232425262728293031323334353637383940relativeLayout &#123; relativeLayout &#123; textView(\"周杰伦\") &#123; id = R.id.extra useSecondary() &#125;.lparams(wrapContent, wrapContent) &#123; alignParentRight() centerVertically() rightMargin = dip(10) &#125; imageView &#123; id = R.id.avatar imageResource = R.drawable.jaychow scaleType = ImageView.ScaleType.FIT_XY &#125;.lparams(dip(40), dip(40))&#123; centerVertically() leftMargin = dip(10) &#125; textView(\"千里之外\") &#123; id = R.id.title usePrimary() &#125;.lparams(matchParent, wrapContent) &#123; leftOf(R.id.extra) rightOf(R.id.avatar) margin = dip(5) &#125; textView(\"依然范特西\") &#123; id = R.id.subtitle useSecondary() &#125;.lparams(matchParent, wrapContent) &#123; leftOf(R.id.extra) rightOf(R.id.avatar) below(R.id.title) leftMargin = dip(5) &#125; &#125;.lparams(matchParent, dip(50))&#125; 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;item name=\"title\" type=\"id\"/&gt; &lt;item name=\"subtitle\" type=\"id\"/&gt; &lt;item name=\"extra\" type=\"id\"/&gt; &lt;item name=\"avatar\" type=\"id\"/&gt;&lt;/resources&gt; 这个布局我们看到其实就是一张图片，三个 TextView，难度也不大，不过这种写法可能要适应一下。 效果如下： 注意到我在 TextView 当中用了两个方法：usePrimary() 和 useSecondary()，这其实是我定义的样式： 12345678910fun TextView.usePrimary()&#123; textSize = 15f //注意这里就是 sp 的值 textColor = Color.BLACK typeface = Typeface.DEFAULT_BOLD&#125;fun TextView.useSecondary()&#123; textSize = 12f //注意这里就是 sp 的值 textColor = Color.GRAY&#125; 这个算是比较复杂的一个布局了，只要 XML 可以搞定的用 Anko DSL 的方式一样可以搞定，而且写出来的东西都可以直接对应到源码，这一点是非常棒的。我们在使用 XML 布局的时候如果想要知道某一个属性对应 View 的什么成员，还得去找这个 View 解析 XML 的代码，显然这一点 DSL 要方便一些。 2.4 独立的 UI前面我们说到的都是在 Activity 的 onCreate 方法中使用 DSL 的场景。很多时候我们其实还是希望布局和 Activity 分开的，那么我们就可以用官方推荐的这种方式来给 Activity 设置布局： 1234567891011121314151617class MyActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) &#123; super.onCreate(savedInstanceState, persistentState) MyActivityUI().setContentView(this) &#125;&#125;class MyActivityUI : AnkoComponent&lt;MyActivity&gt; &#123; override fun createView(ui: AnkoContext&lt;MyActivity&gt;) = with(ui) &#123; verticalLayout &#123; val name = editText() button(\"Say Hello\") &#123; onClick &#123; ctx.toast(\"Hello, $&#123;name.text&#125;!\") &#125; &#125; &#125; &#125;&#125; 2.5 在任意位置用 DSL 定义 View前面提到的各种 &#123;&#125;``` 也好，```verticalLayout &#123;&#125;``` 也好，都只能在 Activity、ViewManager（ViewGroup 的接口）、Context 这三个类的作用域范围之内使用，换句话说前面的几个布局的方法都是这几个类的扩展方法。123456789下面这个写法是没有问题的：```kotlinfun createView(context: Context): View&#123; return context.relativeLayout&#123; ... &#125;&#125; 相应的，我们可以用任意一个 ViewGroup 的子类来调用类似的方法，这与调用 是一样的：1234567```kotlinfun addViewToParent(viewRoot: ViewGroup)&#123; viewRoot.frameLayout &#123; ... &#125;&#125; 如果是在 Fragment 当中，Anko 还非常贴心的定义了一个叫 UI 的方法，这个方法同时也存在于 Context 当中，用法也比较简单： 123456789101112class MainFragment: Fragment()&#123; override fun onCreateView( inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View &#123; return UI &#123; tableLayout &#123; ... &#125; &#125;.view &#125;&#125; 2.6 扩展 Anko，支持自定义 View我们在开发中经常继承一个 View 实现一些自己想要的功能，比如我们继承 _RelativeLayout: 1234class CustomLayout(context: Context) : _RelativeLayout(context) &#123; ... &#125; 注意，如果我们直接继承 RelativeLayout，那么还需要自己定义 lparams 方法，这个我就不细说了，大家有需求可以自己详细研究~ 为了让 Anko DSL 支持下面的写法： 123customLayout&#123; button(\"ClickMe\")&#123; ... &#125;&#125; 我们需要定义下面三组扩展方法： 1234567891011121314151617181920inline fun ViewManager.customLayout(theme: Int = 0) = customLayout(theme) &#123;&#125;inline fun ViewManager.customLayout( theme: Int = 0, init: CustomLayout.() -&gt; Unit) = ankoView(::CustomLayout, theme, init)inline fun Activity.customLayout(theme: Int = 0) = customLayout(theme) &#123;&#125;inline fun Activity.customLayout( theme: Int = 0, init: CustomLayout.() -&gt; Unit) = ankoView(::CustomLayout, theme, init)inline fun Context.customLayout(theme: Int = 0) = customLayout(theme) &#123;&#125;inline fun Context.customLayout( theme: Int = 0, init: CustomLayout.() -&gt; Unit) = ankoView(::CustomLayout, theme, init) 其中，第一组 ViewManager 的是为了在 ViewGroup 当中使用；第二组是为了在 Activity 当中使用，第三组就是为了在所有 Context 当中使用。 扩展也是非常简单的，用起来也丝毫感觉不到这些 View 是自定义的，比起 XML 标签长长的一串确实也要美观得多。 12345&lt;net.println.kotlinandroiddemo.CustomLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; ...&lt;/net.println.kotlinandroiddemo.CustomLayout&gt; 2.7 Anko DSL 使用小结Anko DSL 的方式布局看上去还是比较清爽直观的，而且因为这是 Kotlin 代码，自然所有的view 都是强类型约束的，不需要我们 findViewById 再强转，除此之外由于是代码，可以直接运行，也就省去了运行时解析 XML 的开销，这一点可以说也是相比于 Android 官方的 XML 布局而言 Anko 主打的性能优势。 它的各方面优势我们在前面已经给大家一一点到，可是它存在哪些问题呢？ 首先，Anko DSL 布局不能预览。可以说这一点足以让我们放弃它了，不能预览的话很多时候我们只能通过运行结果来判断布局是否准确，这对开发效率的影响是巨大的。当然，这么说可能 Anko 不服，毕竟人家也是发布了一个叫 Anko Preview Plugin 的 IDE 插件的，有了这个插件理论上我们就可以预览 Anko DSL 的布局结果了对吧？可是结果呢，每次做了修改都需要 make 一下才可以看到结果，显然预览速度来看不如 XML 快。而就算这个问题我们可以忍，慢就慢点儿，别慢太多就行了吧，结果呢，人家这个插件存在各种各样的问题，比如对最新版的 Android Studio 2.2 和 IntelliJ 2016.3 不支持（当然其实本质上是对新版本的 Preview 功能不兼容），大家可以参考这个 issue：https://github.com/Kotlin/anko/issues/202。也就是说，这个插件现在是不能用的，所以跟没有也没啥区别。 其次，对于 id 的定义会比较蛋疼。我们知道我们在布局的时候可以通过 的方式生成一个 id，并交给 Android 资源管理器统一管理，用 Anko DSL 的话我们就得专门定义一个变量或者在 value 目录下面增加 id 的定义（就像 2.3 的例子那样）去让 view 引用。不用 id 行不行呢？你去问问 RelativeLayout 答应不答应吧。12345678910111213141516```kotlin val FROM_TEXT = 0 val CLICK_ME = 1 relativeLayout &#123; textView &#123; text = ... id = FROM_TEXT &#125; button(&quot;clickMe&quot;)&#123; id = CLICK_ME &#125;.lparams &#123; below(FROM_TEXT) &#125; &#125; 再次，我们通常会需要引用一些 view，通过 XML 布局 + kotlin-android-extensions 的方式，我们可以直接引用到这些有 id 的 view，非常方便，不过，如果我们用 Anko DSL 布局的话，我们就享受不到这项福利了（如果你不明白为什么，可以去看下我的前一篇文章: 用Kotlin写Android 01 难道只有环境搭建这么简单？）。 1234567891011121314151617181920val FROM_TEXT = 0 val CLICK_ME = 1 var fromText: TextView? = null relativeLayout &#123; fromText = textView &#123; text = ... id = FROM_TEXT &#125; button(\"clickMe\")&#123; id = CLICK_ME &#125;.lparams &#123; below(FROM_TEXT) &#125; &#125; ... if(shouldHideText) fromText?.visibility = View.GONE else fromText?.visibility = View.VISIBLE 还有就是，如果我们的布局有多个版本，而且需要动态替换外部资源以达到换肤的效果，那么 XML 显然比 Kotlin 代码要来得容易：前者可以编译成一个只有资源的 apk 供应用加载，后者的话就得搞一下动态类加载了。 总之，Anko DSL 布局这个特性我个人觉得还没有达到可以取代 XML 布局的地步，如果大家习惯用 Java 硬编码 View 结构的话，Anko DSL 是个非常不错的选择；相反，如果大家一直用 XML 的话，那请接着用 XML 吧。当然，如果大家有好的使用方式，无论如何要来我这儿跟我嘚瑟一下哈~ 3、简化异步操作假如你要在点击按钮之后把一个文件（本地或者服务端，也可能比较大，总之读取耗时）当中的文字显示出来，你用 Java 会怎么写呢？ 123456789101112button.setOnClickListener(new OnClickListener()&#123; @Override public void onClick(View view)&#123; getExecutor().execute(new Runnable()&#123; @Override public void run()&#123; ... MainActivity.this.runOnUiThread(new Runnable()&#123; ... &#125;); &#125; &#125;) &#125;&#125;); 哎呀我去，真是蜜汁缩进啊，我都写晕了。可是有了 Anko 配合，这段代码简直不能更清爽： 12345678button.onClick &#123; doAsync &#123; val text = File(\"You raise me up.lrc\").readText() uiThread &#123; hello.text = text &#125; &#125;&#125; doAsync 当中的代码运行在 Anko 配置的线程池当中，执行完之后还可以转入 uiThread 块来操作 UI，简单明了，还不容易出错。你当然也可以处理异常和自定义线程池： 123456789101112doAsync( exceptionHandler = &#123; Log.e(TAG, \"error happened when read file.\", it) &#125;, task = &#123; val text = File(\"You raise me up.lrc\").readText() uiThread &#123; hello.text = text &#125; &#125;, executorService = Executors.newSingleThreadExecutor()) 其实大家肯定想到了这两个方法的实现逻辑： 1234567891011121314151617181920212223242526fun &lt;T&gt; T.doAsync( exceptionHandler: ((Throwable) -&gt; Unit)? = null, executorService: ExecutorService, task: AnkoAsyncContext&lt;T&gt;.() -&gt; Unit): Future&lt;Unit&gt; &#123; val context = AnkoAsyncContext(WeakReference(this)) return executorService.submit&lt;Unit&gt; &#123; try &#123; context.task() &#125; catch (thr: Throwable) &#123; exceptionHandler?.invoke(thr) &#125; &#125;&#125;...fun &lt;T&gt; AnkoAsyncContext&lt;T&gt;.uiThread(f: (T) -&gt; Unit): Boolean &#123; val ref = weakRef.get() ?: return false if (ContextHelper.mainThread == Thread.currentThread()) &#123; f(ref) &#125; else &#123; ContextHelper.handler.post &#123; f(ref) &#125; &#125; return true&#125; 4、简化日志打印不知道大家有没有觉得 ...)``` 这样的代码写起来麻烦，绝大多数情况下，我们打日志都需要多写个 Log. 除非静态导入方法，以及 TAG 的值通常都是对应的类名，有时候我只是为了临时打印一行日志，还得去定义一个静态常量 TAG，简直了，还有就是如果我只是想要打印一下某一个对象，还得显式得调用 toString 方法，一点儿都不智能。1234567891011```javapublic class MainActivity extends Activity&#123; public static final String TAG = &quot;MainActivity&quot;; ... View view = ... Log.d(TAG, view.toString()); ...&#125; 有了 Anko 就要简单的多了，只要实现 AnkoLogger 这个接口，我们就可以愉快的打印日志了： 1234567class SomeActivity : Activity(), AnkoLogger &#123; private fun someMethod() &#123; info(\"London is the capital of Great Britain\") debug(5) // .toString() method will be executed warn(null) // \"null\" will be printed &#125;&#125; 日志的 TAG 默认就是类名称，如果你需要自定义，那也没关系，直接覆写这个变量就可以了： 1override val loggerTag: String = \"SomeActivityTag\" 5、小结Anko 这个框架其实没有什么复杂的地方，它更多的是在想办法简化我们的“八股文”代码，让我们的生活更轻松一些而已。DSL 布局是一个很不错的尝试，不过现在看来还是不太完美的，XML 本身也没有太大的问题，想必后续大家完全转向 DSL 的动力也不会很大。 除了前面提到的特性，Anko 还可以简化对话框、toast、sqlite 等操作，相比之下，toast 的用法还是比较常用的，也比较简单，我就不细说了；至于 sqlite ，通常我们也不建议去直接操作它，用一些 ORM 框架可能会让你的代码更友好。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://www.Kotliner.cn/categories/Android/"}],"tags":[{"name":"Anko","slug":"Anko","permalink":"http://www.Kotliner.cn/tags/Anko/"},{"name":"DSL","slug":"DSL","permalink":"http://www.Kotliner.cn/tags/DSL/"}]},{"title":"喜大普奔！Kotlin 1.1 Beta 降临~","slug":"喜大普奔！Kotlin 1.1 Beta 降临~","date":"2017-01-21T04:55:54.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/01/21/喜大普奔！Kotlin 1.1 Beta 降临~/","link":"","permalink":"http://www.Kotliner.cn/2017/01/21/喜大普奔！Kotlin 1.1 Beta 降临~/","excerpt":"","text":"昨天 Kotlin 官方公布了一则消息：1.1 Beta 登场咯~用官方的原话就是说，这意味着正式版已经不再遥远，大家可以踊跃的试一试了~ 这么好的消息，我自然不能藏着掖着，要赶紧给大家发一篇文章先介绍介绍。当然啦，我还没有来得及去仔仔细细尝试其中的各种特性，所以以下内容主要来自官网原文内容和 KEEP（也就是 Kotlin Evolution and Enhancement Process）的讨论。 嗯，以后每周我们也可以考虑附加一篇 1.1 的尝鲜日志，有螃蟹就让我先吃吧，大家看着我吃哇咔咔咔！ 虽然官网没有提到，不过我还是想要强调一下，本文讨论的是 1.1 Beta！1.1 Beta ！！1.1 Beta！！！所以如果你装的是稳定版的 IDE 插件，并且在 gradle 当中配置的也是 1.0.6，就不要问『为什么我这个会报错』这样的问题了哦~~另外，如果真的会有这样的问题，我也不太建议大家去尝试 Bata 版，因为。。因为那样会比较打击人，你能忍受除了你自己写出bug之外还会有一些bug是因为语言本身有问题？ 1.1 协程不得不说，1.1 还是给我们带来了不少的惊。。喜的，额，虽然我们一直都知道，最重要的就是 协程（Coroutines），话说我最早听说这个概念的时候还是在 Lua 和 Golang 当中，这个 Java 并不支持的特性，一直与我忽远忽近，后来听说 Kotlin 1.1M 还是考虑支持协程，我着实兴奋了一把。好吧，现在终于又近了一步。 协程实际上是一个处理并发调度的概念，非阻塞的异步调用对于有过动态语言开发经历的朋友可能已是司空见惯，而对于我们这些深山老林中的 Java 程序员来说，还真是一个新鲜玩意儿。是不是厌倦了你的 new Thread 和 callback？我们看看异步加载数据的代码在 Kotlin 1.1 下要怎么写： 12345678future &#123; val original = asyncLoadImage(\"...original...\") // creates a Future val overlay = asyncLoadImage(\"...overlay...\") // creates a Future ... // suspend while awaiting the loading of the images // then run `applyOverlay(...)` when they are both loaded return applyOverlay(original.await(), overlay.await())&#125; 看上去好像没什么特别的，不过请注意，orginal 和 overlay 可都是异步加载的，applyOverlay 方法的调用会等到二者都准备好之后。 看上去非常符合人的思维，你不用再去过分 care 调用时序的问题，这些都交给虚拟机好了。有关协程的详细介绍，大家也可以看一下这里Coroutines for Kotlin (Revision 3)，我后续的推送当中也会逐渐推送相关内容。 1.2 类型别名其实很多时候我们都需要一个类型来表示多种不同的含义，比如对于一个音乐播放器来说，在随机模式下，一首歌在播放列表的位置就有两种：实际位置，播放位置。这两种位置其实都是可以用一个 int 来表示的，于是我们的代码就会写成： 123fun getPosition(): Int&#123; ...&#125; 不知道大家发现什么没有，这个方法这么看上去我们根本搞不清楚它要返回的是那种类型的位置。如果有了类型别名呢？ 12345typealias ListPosition = Intfun getPosition(): ListPosition&#123; ...&#125; 虽然返回的仍然是整型，不过含义却明确了许多。 当然，除了这个用途之外，对于 Lambda 表达式的表示也会简洁直接许多。 1typealias Callable = ()-&gt;Unit 1.3 Bound callable references说这个之前，我们先看个例子： 1array.map(::println) 这个很显然是遍历 array，并调用函数 println 打印每一个元素。 那么问题来了，假设，现在我不用控制台打印了，我要将元素打印到 PDF 上面，于是： 123array.map&#123; pdfPrinter.println(it)&#125; 那么可不可以简化呢？ 1array.map(pdfPrinter::println) 也就是说函数引用进一步支持了绑定调用者（或者 receiver）的情况。 1.4 Data class 可以有爸爸啦以前，data class 是不允许继承其他类的。不要问我为什么，没有父类这种事儿我更建议你去问问猴子。 你丫再瞎说小心我削你啊 不过，1.1 开始，Kotlin 的创造者们终于良心发现，允许 data class 有个爸爸，这种事儿嘛，终归是一幅令人感动的画面啦。 1data class Complex(...) : Something() 不过嘛，data class 这个家伙还是有点儿悲剧的，1.1 也没有允许他有子嗣，虽然可以认爹，不过没爹的时候就继续自己孤苦着吧。 1.5 放宽 sealed class 的子类定义限制sealed class 的子类必须同时也是它的内部类，这即将成为过去。从 1.1 开始，只要跟 sealed class 定义在同一个文件内即可，嗯。。这个功能没有什么逻辑上的变化，不过写起来倒是省力一些。 1.6 万金油下划线不知道大家有没有注意过 Golang 当中的下划线， 1_,err := func() 其实就是个占位符，如果我们对它不是很关心，那么还用得着费尽心思给它想个名字吗？当然不，Kotlin 1.1 也允许你这么干： 12val (_, x, _, z) = listOf(1, 2, 3, 4)print(x + z) 上面这个例子，我们只关心第2、4个值，1、3就直接忽视好了。 123var name: String by Delegates.observable(\"no name\") &#123; _, oldValue, _ -&gt; println(\"$oldValue\")&#125; 这个例子则是说，三个形参我只关心第二个，那么其他两个退下吧~ 哈哈，如果不需要我思考给变量起什么名字的话，我会不会轻松很多！ 1.7 provideDelegate不知道大家有没有想过，一旦给一个成员加了 Delegate，那么我就把这个成员的控制权交给了 Delegate，如果我想要监听一下这个成员的读写，我只能在 Delegate 当中做了。 12345678910111213141516class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123; operator fun provideDelegate(thisRef: MyUI, property: KProperty&lt;*&gt;) : ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(thisRef, property.name) ... // property creation &#125; private fun checkProperty(thisRef: MyUI, name: String) &#123; ... &#125;&#125; fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; ... &#125; class MyUI &#123; val image by bindResource(ResourceID.image_id) val text by bindResource(ResourceID.text_id)&#125; provideDelegate 可以允许我们在配置了 Delegate 之后也可以做一些织入代码的工作，这就为 Delegate 带来了更多的灵活性。 1.8 其他特性当然，1.1 这么大的版本，特性肯定不止这些了，还有一些特性比如 DSL 作用域控制、为 Kotlin 集合增加 Java 8 方法的支持等等，我这里就不一一介绍了，大家也可以直接到官博一探究竟。 如果你也想吃螃蟹，那你必须更新你的 Kotlin 插件版本： 选中 1.1 之后点击 check for update 就可以了。 如果你用 gradle 或者 maven 构建自己的工程，那么你需要添加插件仓库：http://dl.bintray.com/kotlin/kotlin-eap-1.1，选择 Kotlin 的版本为 1.1.0-beta-17 即可。 下面是 gradle 的配置： 1234567891011121314buildscript &#123; ext.kotlin_version = '1.1.0-beta-17' repositories &#123; jcenter() maven&#123; url \"http://dl.bintray.com/kotlin/kotlin-eap-1.1\" &#125; &#125; dependencies &#123; classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" &#125;&#125; Kotlin 的迭代速度还是非常快的，稳定版本基本上每两个月更新一次，1.1 版的开发工作从年初正式版发布就逐渐为人所知，终于 Beta 来了，相信 1.1 正式版也不会让我们等太久。 后续我也会陆续推送一些文章介绍 1.1 的新特性，希望大家多多关注~","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"http://www.Kotliner.cn/tags/Coroutine/"},{"name":"Type Alias","slug":"Type-Alias","permalink":"http://www.Kotliner.cn/tags/Type-Alias/"}]},{"title":"用 Kotlin 写 Android 01 难道只有环境搭建这么简单？","slug":"用 Kotlin 写 Android 01 难道只有环境搭建这么简单","date":"2017-01-16T03:07:06.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/01/16/用 Kotlin 写 Android 01 难道只有环境搭建这么简单/","link":"","permalink":"http://www.Kotliner.cn/2017/01/16/用 Kotlin 写 Android 01 难道只有环境搭建这么简单/","excerpt":"","text":"从这周开始，每周一的文章推送将连载 Kotlin Android 开发的文章，大家有关心的题目也可以直接反馈给我，这样也可以帮助我提高后续文章的针对性。 亲爱的小伙伴，阅读本文之前，请确保你对 Kotlin 有一定的了解，并且你的 Android Studio 或者 IntelliJ Idea 已经安装了 Kotlin 的插件。如果没有，果断回去先看我的 Kotlin 视频 第一集 :) 1 千里之行，始于 Hello World话说我们入坑 Kotlin 之后，要怎样才能把它运用到 Android 开发当中呢？我们作为有经验的开发人员，大家都知道 Android 现在基本上都用 gradle 构建，gradle 构建过程中只要加入 Kotlin 代码编译的相关配置，那么 Kotlin 的代码运用到 Android 的问题就解决了。 这个问题有何难呢？Kotlin 团队早就帮我们把这个问题解决了，只要大家在 gradle 配置中加入： 1apply plugin: 'kotlin-android' 就可以了，这与我们在普通 Java 虚拟机的程序的插件不太一样，其他的都差不多，比如我们需要在 buildScript 当中添加的 dependencies 与普通 Java虚拟机程序毫无二致： 12345678910buildscript &#123; ext.kotlin_version = '1.0.6'//版本号根据实际情况选择 repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.0' classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" &#125;&#125; 当然，我们还要在应用的 dependencies 当中添加 Kotlin 标准库： 1compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\" 有了这些，你的 Kotlin 代码就可以跑在 Android 上面了！当然，你的代码写在 src/main/java 或是 src/main/kotlin 下都是可以的。这不重要了，我觉得把 Java 和 Kotlin 代码混着写就可以了，没必要分开，嗯，你最好不要感觉到他们是两个不同的语言，就酱紫。 1234567891011121314151617package net.println.kotlinandroiddemoimport android.os.Bundleimport android.support.v7.app.AppCompatActivityimport android.widget.TextViewclass MainActivity : AppCompatActivity() &#123; private lateinit var textView: TextView override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) textView = findViewById(R.id.hello) as TextView textView.text = \"Hello World\" &#125;&#125; 我们定义一个 TextView 的成员，由于我们只能在 onCreate 当中初始化这个成员，所以我们只好用 lateinit 来修饰它。当然，如果你不怕麻烦，你也可以选择 TextView? ，然后给这个成员初始化为 null。 接着我们就用最基本的写法 findViewById、类型强转拿到这个 textView 的引用，然后 setText。 运行自然是没有问题的。 不过，不过！我如果就写这么点儿就想糊弄过去这一周的文章，番茄鸡蛋砸过来估计够我吃一年的西红柿炒鸡蛋了吧（我~就~知~道~，我这一年不用愁吃的了！） 2 Anko 已经超神要说用 Kotlin 写 Android，Anko 谁人不知谁人不晓，简直到了超神的地步。好好，咱们不吹牛了，赶紧把它老人家请出来： 123compile 'org.jetbrains.anko:anko-sdk15:0.9' // sdk19, sdk21, sdk23 are also availablecompile 'org.jetbrains.anko:anko-support-v4:0.9' // In case you need support-v4 bindingscompile 'org.jetbrains.anko:anko-appcompat-v7:0.9' // For appcompat-v7 bindings 稍微提一句 anko-sdk 的版本选择： org.jetbrains.anko:anko-sdk15 ： 15 &lt;= minSdkVersion &lt; 19 org.jetbrains.anko:anko-sdk19 ： 19 &lt;= minSdkVersion &lt; 21 org.jetbrains.anko:anko-sdk21 ： 21 &lt;= minSdkVersion &lt; 23 org.jetbrains.anko:anko-sdk23 ： 23 &lt;= minSdkVersion 当然除了这些之外，anko 还对 cardview、recyclerview等等做了支持，大家可以按需添加，详细可以参考 Github - Anko 另外，也建议大家用变量的形式定义 anko 库的版本，比如： 123456ext.anko_version = \"0.9\"...compile \"org.jetbrains.anko:anko-sdk15:$anko_version\" // sdk19, sdk21, sdk23 are also availablecompile \"org.jetbrains.anko:anko-support-v4:$anko_version\" // In case you need support-v4 bindingscompile \"org.jetbrains.anko:anko-appcompat-v7:$anko_version\" // For appcompat-v7 bindings 好，有了 Anko 我们能干什么呢？ 1textView = find(R.id.hello) 还记得 findViewById 么？变成 find 了，而且强转也没有了，是不是很有趣？你一定有疑问，Anko 究竟干了啥，一下子省了这么多事儿，我们跳进去看看 find 的真面目： 123inline fun &lt;reified T : View&gt; View.find(id: Int): T = findViewById(id) as Tinline fun &lt;reified T : View&gt; Activity.find(id: Int): T = findViewById(id) as Tinline fun &lt;reified T : View&gt; Fragment.find(id: Int): T = view?.findViewById(id) as T 首先它是个扩展方法，我们暂时只用到了 Activity 的扩展版本，实际上 View、Fragment 都有这个扩展方法；其次，它是个 inline 方法，并且还用到了 reified 泛型参数，我们本来应该这么写： 1textView = find&lt;TextView&gt;(R.id.hello) 由于泛型参数的类型可以很容易的推导出来，所以我们再使用 find 的时候不需要显式的注明。 说到这里，其实还是有问题没有说清楚的，reified 究竟用来做什么？其实我们就算不写 inline 和 reified 泛型，这个方法照样是可以用的： 1fun &lt;T : View&gt; Activity.myFind(id: Int): T = findViewById(id) as T 1textView = myFind(R.id.hello) 不过呢，这地方用 inline 就省了一次函数调用，并且 reified 也可以消除 IDE 的类型检查提示，所以既然可以，为什么不呢？ 当然，用 Anko 的好处不可能就这么点儿，我们今天先按住不说，谁好奇的话可以先自己去看看（我~就~知~道~，你们肯定忍不住！！）~ 3 不要 findViewById作为第一篇介绍 Kotlin 写 Android 的文章，绝对不能少的就是 kotlin-android-extensions 插件了。在 gradle 当中加配置： 1apply plugin: 'kotlin-android-extensions' 之后，我们只需要在 Activity 的代码当中直接使用在布局中定义的 id 为 hello 的这个 textView，于是： 123456789101112131415import android.os.Bundleimport android.support.v7.app.AppCompatActivity//这个包会自动导入import kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //直接使用 hello，hello 实际上是这个view 在布局当中的id hello.text = \"Hello World\" &#125;&#125; 只要布局添加一个 View，在 Activity、View、Fragment 中其实都可以直接用 id 来引用这个 view，超级爽~ 所以，你们不准备问下这是为什么吗？为什么可以这样做呢？ 其实要回答这个问题也不难，首先 Android Studio 要能够从 IDE 的层面索引到 hello 这个 View，需要 Kotlin 的 IDE 插件的支持（别问我啥是 IDE 插件，你们用 Kotlin 的第一天肯定都装过）；其次，在编译的时候，编译器能够找到 hello 这个变量，那么还需要 Kotlin 的 gradle 插件支持（我们刚刚好像 apply 了个什么 plugin 来着？）。知道了这两点，我们就要有的放矢了~ “啊！” 那边的 Kotlin 源码一声惨叫。。。 前方高能。。我们讨论的源码主要在 plugins 目录下的 android-extensions-compiler 和 android-extensions-idea 两个模块当中。 如果让大家自己实现一套机制来完成上面的功能，大家肯定会想，我首先得解析一下 XML 布局文件吧，并把里面的 View 存起来，这样方便后面的查找。我告诉大家，Kotlin 也是这么干的！ AndroidXmlVisitor.kt 1234567891011121314override fun visitXmlTag(tag: XmlTag?) &#123; ... val idAttribute = tag?.getAttribute(AndroidConst.ID_ATTRIBUTE) if (idAttribute != null) &#123; val idAttributeValue = idAttribute.value if (idAttributeValue != null) &#123; val xmlType = tag?.getAttribute(AndroidConst.CLASS_ATTRIBUTE_NO_NAMESPACE)?.value ?: localName val name = androidIdToName(idAttributeValue) if (name != null) elementCallback(name, xmlType, idAttribute) &#125; &#125; tag?.acceptChildren(this)&#125; 这是遍历 XML 标签的代码，典型的访问者模式对吧。如果拿到这个标签，它有 android:id 这个属性，那么小样儿，你别走，老实交代你的 id 是什么！举个例子，如果这个标签是这样的： 123&lt;Button android:id=\"@+id/login\" ... /&gt; 那么，name 就是 login 了，既然 name 不为空，那么调用 elementCallback，其实就是把它记录了下来。 IDEAndroidLayoutXmlFileManager.kt 12345678910111213override fun doExtractResources(files: List&lt;PsiFile&gt;, module: ModuleDescriptor): List&lt;AndroidResource&gt; &#123; val widgets = arrayListOf&lt;AndroidResource&gt;() //注意到这里的 Lambda 表达式就是前面的 elementCallback val visitor = AndroidXmlVisitor &#123; id, widgetType, attribute -&gt; widgets += parseAndroidResource(id, widgetType, attribute.valueElement) &#125; files.forEach &#123; it.accept(visitor) &#125; //返回所有带 id 的 view return widgets&#125; 接着想既然我们找到了所有的布局带有 id 的 view，那么我们总得想办法让 Activity 它们找到这些 view 才行对吧，而我们发现其实在引用它们的时候总是要导入一个包，包名叫做： 1kotlinx.android.synthetic.main.&lt;布局文件名&gt;.* 几个意思？Kotlin 编译器为我们创建了一个包？ AndroidPackageFragmentProviderExtension.kt 1234...createPackageFragment(packageFqName, false)createPackageFragment(packageFqName + \".view\", true)... 注意到，这里的 packageFqName 其实就是我们前面提到的 1kotlinx.android.synthetic.main.&lt;布局文件名&gt; 不对呀，怎么创建了两个包呢？其实第二个多了个 .view ，我们在 Activity 当中 导入的包是第一个，但如果是我们用父 view 引用子 view 时，用的是第二个： 123456789101112...import kotlinx.android.synthetic.main.activity_main.view.*class OverlayManager(context: Context)&#123; init &#123; val view = LayoutInflater.from(context).inflate(R.layout.activity_main, null) view.hello.text = \"HelloWorld\" ... &#125; ...&#125; 好，我们现在知道了，IntelliJ 居然已经通过解析 XML 帮我们偷偷搞出了这么两个虚拟的包，这样我们在代码当中能够引用到这个包就很容易解释了。 这时候可能还会有人比较疑惑点击了 Activity 的 hello 之后如何跳转到 XML 的，这个大家阅读一下 的源码就会很容易的看到答案。1234费了这么多篇幅，其实我们只是做好了表面文章。上面的一切其实都是障眼法，别管怎么说，这两个包都是虚拟的，编译的时候该怎么办？其实编译就简单多了，碰到这样的引用，比如前面的 hello，直接生成 findViewById 的字节码就可以了，我们把 ```hello.text = &quot;HelloWorld&quot;``` 的字节码贴出来给大家看： L2LINENUMBER 12 L2ALOAD 0GETSTATIC net/println/kotlinandroiddemo/R$id.hello : IINVOKEVIRTUAL net/println/kotlinandroiddemo/MainActivity._$_findCachedViewById (I)Landroid/view/View;CHECKCAST android/widget/TextViewLDC “Hello World”CHECKCAST java/lang/CharSequenceINVOKEVIRTUAL android/widget/TextView.setText (Ljava/lang/CharSequence;)V12345678910111213这个是怎么做到的？请大家阅读 ```AndroidExpressionCodegenExtension.kt```，```kotlin...//GETSTATIC net/println/kotlinandroiddemo/R$id.hello : Iv.getstatic(packageName.replace(&quot;.&quot;, &quot;/&quot;) + &quot;/R\\$id&quot;, resourceId.name, &quot;I&quot;) //INVOKEVIRTUAL net/println/kotlinandroiddemo/MainActivity._$_findCachedViewById (I)Landroid/view/View;v.invokevirtual(declarationDescriptorType.internalName, CACHED_FIND_VIEW_BY_ID_METHOD_NAME, &quot;(I)Landroid/view/View;&quot;, false)... 好，到这里，想必大家才能对 Android 的 HelloWorld 代码有一个彻底的理解。 4 小结虽然是 HelloWorld，但要想搞清楚其中的所有秘密，并没有那么简单，很多时候，阅读 Kotlin 源码几乎成了唯一的途径。 谢谢大家的关注和支持~如果有什么问题可以联系我~","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://www.Kotliner.cn/categories/Android/"}],"tags":[{"name":"搭建环境","slug":"搭建环境","permalink":"http://www.Kotliner.cn/tags/搭建环境/"},{"name":"Anko","slug":"Anko","permalink":"http://www.Kotliner.cn/tags/Anko/"},{"name":"extensions","slug":"extensions","permalink":"http://www.Kotliner.cn/tags/extensions/"}]},{"title":"高效地使用你的 IntelliJ","slug":"高效地使用你的 IntelliJ","date":"2017-01-09T08:20:22.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/01/09/高效地使用你的 IntelliJ/","link":"","permalink":"http://www.Kotliner.cn/2017/01/09/高效地使用你的 IntelliJ/","excerpt":"","text":"这个世界上，有些人是奥义·真·懒，他们懒得折腾一切，甚至懒得活，所以他们不会看到这篇文章的。还有些人是奥义·嘴上说的·懒，这些人有个特点，懒到什么事儿都要弄个工具，于是人类社会就这么被一点儿推动着前进了。看到这篇文章的大家应该都是后面的这类人，so，给自己鼓个掌吧！ 话说，人懒就要用 IDE，IntelliJ 已经超神了，用的人越来越多，不过，它有这么多技能你们都用到过吗？ 回车 or Tab？很多时候我们在召唤出自动补全之后，光标选中了我们想要的那个选项，于是我们按回车。。。 额。。这。。难道就不能直接替换掉那个 map 吗？！当然可以： 这操作有什么区别呢？前者按的是回车，后者按的是 Tab。 印象中，微软的东西都比较倾向于按 Tab 补全，比如 VS，再比如 Excel（Whaaaat?)，说这个也没别的意思，就是想让你记住，有时候 Tab 比回车好用。 Swap 一下位置？如果你飞快地写下了两句代码，然后发现他们的顺序是错的，你会怎么办？ 选中一整行，剪切，然后粘到上一句的前面？你 Out 了！看我的！ 怎么做到的？很简单，打开你的设置，找到 keymap，再找到下面的几个 Action： Statement 和 line 有时候会比较相似，比如我们刚才的情形；不过 Statement 还可以表示一整个函数或者类，于是你完全可以把光标放到一个函数的函数名上，然后 move up and down： 如果你觉得默认的快捷键不好使，自己定义一个，你开心就好。 想要不移动光标就换行？经常遇到这种需求，我的光标在某一行的中间，这时候想要换行，于是。。 这明显有点儿尴尬。。当然你也可以直接移到行末，再回车，但总是要操作两次。其实这个也简单了，按住 shift 再回车，就可以直接换到下一行： 而按住 cmd+option 再按回车就直接换到上一行： windows的快捷键我不知道，不过我还是要告诉大家它的名称，你自己定义就好： 快速迭代一个集合或者数组？如果你在 Kotlin 里面，可能并不会有这样的困惑，毕竟我们可以写完一个集合，然后 .map 就行了。Java 里面可不能这样，于是。。。 怎么办，怎么忍？让我们喊出我们的口号：不能忍！ 上面只要我们在打出一个集合之后，再打出 for，就能自动生成这段迭代的代码，这个叫做 Postfix。IntelliJ 支持了挺多的 Postfix，我就不一一列出了，在设置里面输入 postfix 那么你将看到 IntelliJ 支持的所有 Postfix： 多行编辑，哎哟小心某些人的钛合金眼~多行编辑没什么神秘的，大家一看就明白了。第一种触发方式比较简单，按住 option或者alt，用鼠标往下拖就可以触发，例如： 第二种要高端一些了，比如我要修改个一个词，又不可以通过 refactor来统一修改，怎么办，难道有一百个还要让我改一百次吗？当然不需要，先选中第一个，然后如果是在Mac上，按 ctrl+G）选择下一个，或者直接 cmd+ctrl+G 选择全部，就如下图所示，选中之后，多行编辑触发，你就可以一下改掉所有的： 这里涉及到添加选择下一个和选择全部的操作，大家可以自己随意定义快捷键： 查找替换也有说法？常规的查找替换肯定没啥可说的。不过不知道你注意到没，查找替换还有个 regex 的选项： 这个咋用呢？很简单，搜索词按照标准的正则表达式写就行了。比如我要定位到这个文件里面的所有函数名称，并在他们后面加一个 Test 方法，这种通常来说多行编辑是不太好做了，所以： 替换结果中，$n 表示第n个匹配到的元组。这个用起来对正则表达式的功底要求比较高了，当然我觉得他更有用的地方在于帮助你熟悉正则比倒是的用法。 最强快捷键，没有之一我之前看谷歌大会的视频，有一哥们在操作几乎任何操作的时候都用到了一个类似于命令行的快捷键，看上去非常酷： 在这里，几乎可以输入任意操作，比如我们想要查看 Kotlin 的字节码，或者想要看下历史记录，甚至 make/run/debug，都毫无压力。 实际上，如果你对 IntelliJ 的插件开发有那么一丁点儿了解（比如我，虽然我自己没有写过= =、），你就会知道 IntelliJ 里面的各种操作都是 Action，只要是个 Action，就都可以配置快捷键，而且索引方式也是按照名称，所以前面的输入框就可以毫无压力的索引到这些 Action 了。 那么这个搜索框本身是个啥呢？它自己也是一个 Action，叫做： 给它配个快捷键，让你的 IntelliJ 起飞吧~ 为什么输入 main 就能打出完整的 main 方法？我在录制视频的时候经常会用一个比较快捷的输入方法： 输入main 之后就可以打出完整的main方法，这是怎么做到的？打开你的设置，找到 Live Templates， 新建一个 group 叫亚瑟： 在这个 group 当中我们新建一个 Live Templates： 注意看，abbreviation 是缩写的意思，也就是说你将通过输入这段文字来触发模板，比如我们刚才的 main，我们现在想要方便的在注释中写下自己的名字和注释的时间，于是我们给他起个名字叫 “//“ description 就是一个注释的作用，所以不写也可以（虽然这并不是一个好习惯）。接下来我们要写 Template Text了。我们希望输入 // 之后能自动生成下面的代码： 1&lt;你的用户名&gt;[当前时间] 那么我们需要定义两个变量来代表 用户名和时间： 接下来我们要考虑，我们的这个模板用在哪里呢？ 点击 Define，在弹出的菜单中选择 Java -&gt; Comment： 紧接着要给这两个变量赋值了，点击旁边的 Edit Variables： Expressions 有个下拉菜单，选出 user() 和 time() 赋给我们定义好的两个变量，同时勾上后面的两个勾 Skip if define——如果想知道为什么，你把勾去掉试试。 这样我们就创建好了一个新的模板，一路 OK之后，我们就可以试试了： 不过，你对时间格式有点儿不太满意，其实你还想要日期对不对？于是： 其实这样基本就满足需求了。如果你偏偏对此感到不满意，为什么时间的格式不能自定义，那。。我想告诉你的是，谁说不可以的。。 DATETIME 的表达式是：1groovyScript(&quot;import java.util.Date; import java.text.SimpleDateFormat; new SimpleDateFormat(&apos;yyyy-MM-dd HH:ss&apos;).format(new Date());&quot;) 就是一段普通的 groovy 脚本，不过由于 groovy 完全兼容 Java 语法，所以你可以写一段 Java 代码进入，最后一行的值就是表达式的值。 结果嘛： 小结当然 IntelliJ 当中好玩的东西不只这些，比如 最常用的 refactor等等，剩下的就需要大家自己去发现了，实在不行咱也可以写个插件或者去搜个别人做好的插件。IntelliJ 提供了很好的扩展性和定制性，每个人的背景和习惯不一样，对 IDE 的需求也不一样，只要肯折腾，这工具会越来越顺手的。","raw":null,"content":null,"categories":[{"name":"其他","slug":"其他","permalink":"http://www.Kotliner.cn/categories/其他/"}],"tags":[{"name":"IntelliJ","slug":"IntelliJ","permalink":"http://www.Kotliner.cn/tags/IntelliJ/"},{"name":"快捷键","slug":"快捷键","permalink":"http://www.Kotliner.cn/tags/快捷键/"},{"name":"高效","slug":"高效","permalink":"http://www.Kotliner.cn/tags/高效/"}]},{"title":"为什么不直接使用 Array<Int> 而是 IntArray ？","slug":"为什么不直接使用 Array&lt;Int&gt; 而是 IntArray ","date":"2017-01-09T08:20:22.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/01/09/为什么不直接使用 Array&lt;Int&gt; 而是 IntArray /","link":"","permalink":"http://www.Kotliner.cn/2017/01/09/为什么不直接使用 Array&lt;Int&gt; 而是 IntArray /","excerpt":"","text":"基本类型居然有特殊待遇其实我们用数组的场景不太多。有一天在做demo的时候，我突然意识到有 和 IntArray 这两种完全不同的存在，当时我感觉非常的奇怪，为什么要再搞一个 IntArray 呢？不仅 IntArray，还有 DoubleArray、LongArray 等等，所有基本类型都有一个专属的 Array 版本，这背后一定有什么原因的。1234567891011121314151617偏偏巧了，kotlin-runtime 这个 jar 包里面对应的 kotlin.kotlin_builtins 这个文件没有源码，所以直接跳进去看到的 IntArray 的声明什么都没有。。```kotlinpublic final class IntArray public constructor(size: kotlin.Int) : kotlin.Cloneable &#123; public constructor(size: kotlin.Int, init: (kotlin.Int) -&gt; kotlin.Int) &#123; /* compiled code */ &#125; public final val size: kotlin.Int /* compiled code */ public open fun clone(): kotlin.IntArray &#123; /* compiled code */ &#125; public final operator fun get(index: kotlin.Int): kotlin.Int &#123; /* compiled code */ &#125; public final operator fun iterator(): kotlin.collections.IntIterator &#123; /* compiled code */ &#125; public final operator fun set(index: kotlin.Int, value: kotlin.Int): kotlin.Unit &#123; /* compiled code */ &#125;&#125; 当时我就很纳闷，想来想去可能也就 IntIterator 特殊一点儿，点进去看看吧。 1234567/** An iterator over a sequence of values of type `Int`. */public abstract class IntIterator : Iterator&lt;Int&gt; &#123; override final fun next() = nextInt() /** Returns the next value in the sequence without boxing. */ public abstract fun nextInt(): Int&#125; 注意看，“without boxing” 这一句，如果大家对 Java 基本类型的装箱有所了解，看到这个肯定会立马明白什么的——Kotlin 为基本类型定制 Array 的目的是为了避免装箱？ 真相总是藏在字节码里面如果真是这个理由，那么这明显非常说得过去，毕竟装箱是有开销的。为了证实这个答案，我们只需要看下字节码就好了。我们分别用 kotlin 和 Java 写下下面的等价代码： 1val intArray = intArrayOf(1,3,4) 1int[] array = new int[]&#123;1,3,4&#125;; 使用 ASM Bytecode Outline 插件查看字节码，发现二者的结果几乎是完全一样的（当然除了行号之类）： 1234567891011121314151617LINENUMBER 7 L1ICONST_3NEWARRAY T_INT // 注意这里是构造int的数组DUPICONST_0ICONST_1IASTOREDUPICONST_1ICONST_3IASTOREDUPICONST_2ICONST_4IASTOREASTORE 1L2 而换个方式，如果我们用 ，会发生什么呢？123```kotlinval arrayOfInt = arrayOf(1,3,4) 123456789101112131415161718192021LINENUMBER 8 L2ICONST_3ANEWARRAY java/lang/IntegerDUPICONST_0ICONST_1INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;AASTOREDUPICONST_1ICONST_3INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;AASTOREDUPICONST_2ICONST_4INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;AASTOREASTORE 3NOPL3 这时候我们就能看到，其实是构造了一个 Integer[] 出来，每添加一个数字，就会调用 123456789101112131415161718192021222324252627282930## 编译器的答案故事本来发展到这儿就应该结束了吧，毕竟我们得到了一个说得过去的答案，可偏偏我是挖掘机专业毕业的，我就是很好奇 Kotlin 运行的时候把 IntArray 给搞成了什么样子，于是我打开了 Kotlin 的源码（1.0.5），并在 core/builtins/native/kotlin/Arrays.kt 当中找到了 IntArray 的真身：```kotlin/** * An array of ints. When targeting the JVM, instances of this class are represented as `int[]`. * @constructor Creates a new array of the specified [size], with all elements initialized to zero. */public class IntArray(size: Int) : Cloneable &#123; /** * Creates a new array of the specified [size], where each element is calculated by calling the specified * [init] function. The [init] function returns an array element given its index. */ public inline constructor(size: Int, init: (Int) -&gt; Int) /** Returns the array element at the given [index]. This method can be called using the index operator. */ public operator fun get(index: Int): Int /** Sets the element at the given [index] to the given [value]. This method can be called using the index operator. */ public operator fun set(index: Int, value: Int): Unit /** Returns the number of elements in the array. */ public val size: Int /** Creates an iterator over the elements of the array. */ public operator fun iterator(): IntIterator public override fun clone(): IntArray&#125; 果然，这里面的注释明确地告诉我们 IntArray 最终是要编译为 int[] 的。可是，现在骗子这么多，我怎么知道注释不是逗我玩呢？ 于是我开始翻 Kotlin 的源码，主要是编译器相关的代码。关于这块儿呢，目前我还没有理解的很透彻，不过答案应该是有了的。 Kotlin 的编译器运行的时候，主要依靠一个叫做 的类来识别我们代码运行时的类型，所谓 FqName，其实就是 Full Qualified Name，简单的说就是代码元素（主要是类）的全名，比如 String -> java.lang.String。12345678910下面是 Kotlin 映射 ```IntArray``` 的一段代码：**typeSignatureMapping.kt，mapBuiltInType方法**```kotlin val arrayElementType = KotlinBuiltIns.getPrimitiveTypeByArrayClassFqName(fqName) if (arrayElementType != null) &#123; return typeFactory.createFromString(&quot;[&quot; + JvmPrimitiveType.get(arrayElementType).desc) &#125; 在编译时，Kotlin 编译器如果遇到 IntArray，就会尝试映射这个类，运行到上面的代码时，fqName 的值是 “kotlin.IntArray”，而 arrayElementType 是 的一个实例 ```INT```，而这个 ```PrimitiveType``` 又是什么呢？1234567891011121314```javapublic enum PrimitiveType &#123; BOOLEAN(&quot;Boolean&quot;), CHAR(&quot;Char&quot;), BYTE(&quot;Byte&quot;), SHORT(&quot;Short&quot;), INT(&quot;Int&quot;), FLOAT(&quot;Float&quot;), LONG(&quot;Long&quot;), DOUBLE(&quot;Double&quot;), ; ...&#125; 是 Kotlin 基本类型的一个枚举。 我们还是看刚才的映射代码，返回的究竟是什么呢？由于我们已经知道 arrayElementType 的值，也就不难得到 JvmPrimitiveType.get(arrayElementType).desc 实际上是 I，这么说来返回的类型应该是 [I——而这个，正是 int[] 的字节码类型。 小结其实 Kotlin 中的不少类型都是对 Java 原有类型的扩展，当然有时候扩展不方便的话就直接在编译期做映射，类似的例子还有 kotlin.String -&gt; Java.lang.String，kotlin.collections.MutableMap -&gt; java.util.Map 等等。如果跟高大上的设计模式、应用框架比起来，基本类型的数组问题，算不上一个“大”问题。不过，我希望通过本文传达给大家的一个信息是：“Kotlin 是开源哒，源码面前，了无秘密”。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"基本类型","slug":"基本类型","permalink":"http://www.Kotliner.cn/tags/基本类型/"},{"name":"装箱类型","slug":"装箱类型","permalink":"http://www.Kotliner.cn/tags/装箱类型/"}]},{"title":"像写文章一样使用 Kotlin","slug":"像写文章一样使用 Kotlin","date":"2017-01-02T08:22:57.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2017/01/02/像写文章一样使用 Kotlin/","link":"","permalink":"http://www.Kotliner.cn/2017/01/02/像写文章一样使用 Kotlin/","excerpt":"","text":"我把所有文章和视频都放到了 Github 上 ，如果你喜欢，请给个 Star，谢谢~ 运算符重载不知道大家有没有看到过下面的函数调用： 1print \"Hello World\" 这样的感觉就好像在写文章，没有括号，让语言的表现力进一步增强。Groovy 和 Scala 就有这样的特性，那么 Kotlin 呢？ 123for(i in 0..10)&#123; ...&#125; 如果你在 Kotlin 中写下了这样的代码，你可能觉得很自然，不过你有没有想过 0..10 究竟是个什么？ “是个 IntRange 啊，这你都不知道。”你一脸嫌弃的回答道。 是啊，确实是个 IntRange，不过为什么是 0..10 返回个 IntRange，而不是 0-&gt;10 呢？ “我靠。。这是出厂设定，懂不懂。。”你开始变得更嫌弃了。。 额，其实我想说的是，你知不知道这其实是个运算符重载？！ 12345public final operator fun rangeTo(other: kotlin.Int) : kotlin.ranges.IntRange &#123; ...&#125; 没错，Kotlin 允许我们对运算符进行重载，所以你甚至可以给 String 定义 rangeTo 方法。 去掉方法的括号“毕竟运算符是有限的吧？如果说我想给 Person 增加个 say 方法，不带括号那种，怎么办？” 你不以为然地说。 这个嘛。。当然也是可以哒！ 12345678910class Person(val name: String)&#123; infix fun 说(word: String)&#123; println(\"\\\"$name 说 $word\\\"\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val 老张 = Person(\"老张\") 老张 说 \"小伙砸,你咋又调皮捏!\"&#125; 这段代码执行结果是： 1老张 说 &quot;小伙砸,你咋又调皮捏!&quot; 这个看上去有有点儿意思不？代码跟输出是一样滴！有人会说，中文变量和函数名真的大丈夫？是滴，全然大丈夫，这是因为 Java、Kotlin 的字节码都采用 Unicode，中文确实是可以的——不过，Java 还支持中文包名和文件名，这在 Kotlin 当中还是有些问题的。 接着说，通常我们的方法传参是需要括号的，为什么这里不需要了呢？因为 infix 这个关键字！这里跟 Scala 和 Groovy 不同，Kotlin 只有显示的声明为 infix 的只有一个参数的方法才可以这么玩，如果你不显示声明，想去括号门儿都没有。 聊聊 DSL好，抛开老张的例子不谈，毕竟真正生产环境下，谁会去用中文呢。什么情况下我们需要 infix？当然是 DSL 中。我们看一段 Gradle 配置： 1apply plugin: 'kotlin' 看上去很有表现力是吧，即使你不懂 groovy 语法，也能直接看懂这句话就是使用 kotlin 插件。可它本质上还是句 groovy 代码，所以它的结构是怎样的呢？ 1void apply(Map&lt;String, ?&gt; config); 实际上，apply 是 PluginAware 的一个方法，后面的 plugin 呢？ 那不过是一个 k-v 对而已，在 groovy 当中， K:V 的形式可以表示一个键值对。那既然参数是 Map，那我要是多传几个参数是不是也可以呢？ 1apply ([plugin: 'kotlin', 宝宝: \"不开心\"]) 不过这样虽然多传了一个键值对，不过由于 gradle 并不关心 “宝宝”，所以 “宝宝：不开心”那也没有办法了，说了也白说。哈哈。 前面的 DSL 是 groovy 版本的，再回到 Kotlin 当中，如果我们编写 DSL 代码，据说 Kotlin 版本的 gradle 也已经在开发中了，那么我们猜猜它会长成啥样？ 1apply mapOf(\"plugin\" to \"kotlin\") 用 Kotlin 的 K to V 的方式传入一个 Pair。这里的 apply 的声明就应该是： 1infix fun apply(config: Map&lt;String, Any&gt;) 很丑？没关系，我们为什么不直接搞一个方法叫做 applyPlugin 呢？ 1infix fun applyPlugin(pluginName: String) 于是： 1applyPlugin \"kotlin\" 当然，作为静态语言，与 groovy 当然不能照搬了，所以最理想的实现肯定是强类型约束，比如 1apply&lt;KotlinPlugin&gt;() 不过，这个我们就不谈了，跑题了。 小结infix 是一个非常有用的关键字，让你的代码看起来像一篇文章一样，你不比再为前后括号匹配着慌，每一个单词其实都是方法调用。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"运算符重载","slug":"运算符重载","permalink":"http://www.Kotliner.cn/tags/运算符重载/"},{"name":"中缀表达式","slug":"中缀表达式","permalink":"http://www.Kotliner.cn/tags/中缀表达式/"}]},{"title":"Kotlin 1.0.6","slug":"Kotlin 1.0.6","date":"2017-01-02T08:22:57.000Z","updated":"2017-05-22T02:30:56.890Z","comments":true,"path":"2017/01/02/Kotlin 1.0.6/","link":"","permalink":"http://www.Kotliner.cn/2017/01/02/Kotlin 1.0.6/","excerpt":"","text":"我把所有文章和视频都放到了 Github 上 ，如果你喜欢，请给个 Star，谢谢~ 在上周二，Kotlin 1.0.6 发布啦！这次更新主要是工具更新和bug修复。本文的内容主要来自官方博客。 IDE 插件的更新 try-finally 转换为 use() 通常我们在进行 IO 操作的时候，我们并不希望异常影响我们程序的执行，所以我们需要对异常进行捕获，但捕获的话我们也没有必要处理，所以写下来的就是下面的形式： 12345try&#123; ... do something with \"reader\" ...&#125;finally&#123; reader.close()&#125; 但这样写起来是不是非常的不流畅？如果用 use() 的话，简直一气呵成： 123reader.use&#123; reader -&gt; ... do something with \"reader\" ...&#125; 所以，这次更新 Kotlin 的插件为我们带来了这样的自动转换功能： 补全具名参数 通常我们在编写代码的时候，函数入参都会按照顺序一个一个传入，不过随着代码量的增加，特别是对于参数较多的函数，一长串的代码看上去会让我们感到非常的头疼。所以，这次更新 Kotlin 还为我们带来了自动补全具名参数的功能。 删除空构造方法的声明 合并声明和赋值 inline 函数的问题修复和调试工具的优化 提示、KDoc 和 Quick Doc 相关的较多问题的修复 Android 相关更新 支持 Android Studio 2.3 beta 1 和 Android Gradle Plugin 2.3.0-alpha3及更新的版本 增加 “Create XML resource” 的提示 Android Extensions support 这个功能可以让我们很方便的引用 XML 布局的 View，不过这需要我们主动启用 ‘kotlin-android-extensions’ 才行。在过去，即使不启用这个插件，IDE 也会允许我们直接引用 XML 布局的 View，但这并不能正常编译，所以这次更新修复了这个问题：只有启用了这个插件，IDE 才会允许我们引用对应的 View。 Android Lint 相关的问题修复。 增加 Suppress Lint 提示。 Kapt 优化尽管还不能完全支持增量编译，相比 1.0.4，这次更新较大的提升了 Kapt 的性能。如果需要启用 Kapt，请在 gradle 当中启动它：plugin: 'kotlin-kapt'```123456789101112131415161718192021222324252627282930313233## All-open 插件我们知道 Kotlin 的所有类及其成员默认情况下都是 final 的，也就是说你想要继承一个类，就要不断得写各种 open。刚开始看到这一特性的时候，觉得很赞，它对培养良好的编码意识非常有帮助，不过它也在某些情况下给我们带来麻烦，比如在一些大量依赖继承和覆写的 Java 框架的使用中。这一次 Kotlin 提供了一个妥协的办法，主要某个类被某一个特定注解标注，那么这个类就默认所有成员通通 open，省得一个一个写了。有关 allopen 的讨论，大家可以参考这里 [KEEP](https://github.com/Kotlin/KEEP/pull/40)。那么 allopen 如何使用呢？```groovybuildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot; &#125;&#125;apply plugin: &quot;kotlin-allopen&quot;allOpen &#123; annotation(&quot;com.your.Annotation&quot;)&#125;buildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot; &#125;&#125; apply plugin: &quot;kotlin-allopen&quot; allOpen &#123; annotation(&quot;com.your.Annotation&quot;)&#125; 那么所有被 com.your.Annotation 这个注解标注的类成员都会默认 open。除此之外，它还可以作为元注解使用： 12345@com.your.Annotationannotation class MyFrameworkAnnotation@MyFrameworkAnnotationclass MyClass // will be all-open Kotlin 还提供了 “kotlin-spring” 插件，其中包含了 spring 相关的所有注解，这样免得我们一个一个在 allopen 的配置中声明了。 No-arg 插件如果大家看过我的视频，一定对我之前提到的“毁三观”的实例化有印象吧，附上视频连接：12 Json数据引发的血案，其中我们提到对于没有无参构造方法的 Kotlin 类，Gson 反序列化它们的时候，不知道如何实例化它们，只好用到了 这个类。听说 Java 9 要移除这个略显黑科技的类，如果是这样，Gson 是不是会被削弱呢？Java 的心我们还是不操了，从 Kotlin 1.0.6 开始，这个问题将得到一个比较好的解决。1234567891011121314```groovybuildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot; &#125;&#125;// Or &quot;kotlin-jpa&quot; for the Java Persistence API supportapply plugin: &quot;kotlin-noarg&quot;noArg &#123; annotation(&quot;com.your.Annotation&quot;)&#125; 类似于 allopen 的使用方法，如果某个类需要无参默认构造方法，你只需要用上面声明好的注解 com.your.Annotation 标注即可。当然，这个生成的默认构造方法只能通过反射调用。 如何更新我一直觉得虽然我们出生就被选择了 Hard 模式，但我们没啥感觉啊。可是最近一直访问国外的网站，感觉真的好困难，宽带换成了电信 100M，下载 Kotlin 的插件仍然跟小水管一样，真也是没谁了。为了方便大家我把我下载的几个版本的插件放到百度网盘，供大家使用，请大家点击阅读原文获取下载地址。 小结目前 Kotlin 1.0.x 的版本更新更侧重于稳定性和易用性，因此语言上的特性基本不会更新，主要集中于 IDE 插件和编译器插件。如果大家期待语言特性的更新，那我们就去关注一下 1.1 吧！","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[{"name":"AllOpen","slug":"AllOpen","permalink":"http://www.Kotliner.cn/tags/AllOpen/"},{"name":"NoArg","slug":"NoArg","permalink":"http://www.Kotliner.cn/tags/NoArg/"},{"name":"Kapt","slug":"Kapt","permalink":"http://www.Kotliner.cn/tags/Kapt/"}]},{"title":"Kotlin 如何优雅的实现『多继承』","slug":"Kotlin 如何优雅的实现『多继承』","date":"2016-12-26T01:49:45.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2016/12/26/Kotlin 如何优雅的实现『多继承』/","link":"","permalink":"http://www.Kotliner.cn/2016/12/26/Kotlin 如何优雅的实现『多继承』/","excerpt":"","text":"Hi，Kotliners，尽管视频完结了，不过每周一我还是会给大家推送一些 Kotlin 的有意思的话题，如果大家对视频有兴趣，直接点击阅读原文就可以找到~ Kotlin 从入门到『放弃』视频教程 – 这一期给大家讲一个有意思的东西。我们都知道 Java 当年高调的调戏 C++ 的时候，除了最爱说的内存自动回收之外，还有一个著名的单继承，任何 Java 类都是 Object 的子类，任何 Java 类有且只有一个父类，不过，它们可以有多个接口，就像这样： 1234567public class Java extends Language implements JVMRunnable&#123; ...&#125;public class Kotlin extends Language implements JVMRunnable, FERunnable&#123; ...&#125; 这样用起来真的比 C++ 要简单得多，不过有时候也会有些麻烦：Java 和 Kotlin 都可以运行在 JVM 上面，我们用一个接口 JVMRunnable 来标识它们的这一身份；现在我们假设这二者对于 JVMRunnable 接口的实现都是一样的，所以我们将会在 Java 和 Kotlin 当中写下两段重复的代码： 1234567891011121314public class Java extends Language implements JVMRunnable&#123; public void runOnJVM()&#123; ... &#125;&#125;public class Kotlin extends Language implements JVMRunnable, FERunnable&#123; public void runOnJVM()&#123; ... &#125; public void runOnFE()&#123; ... &#125;&#125; 重复代码使我们最不愿意看到的，所以我们决定创建一个 JVMLanguage 作为 Java 和 Kotlin 的父类，它提供默认的 runOnJVM 的实现。看上去挺不错。 123456789101112131415public abstract class JVMLanguage&#123; public void runOnJVM()&#123; ... &#125;&#125;public class Java extends JVMLanguage&#123;&#125;public class Kotlin extends JVMLanguage implements FERunnable&#123; public void runOnFE()&#123; ... &#125;&#125; 当然，我们还知道 Kotlin 可以编译成 Js 运行，那我们硬生生的把 Kotlin 称作 JVMLanguage 就有些牵强了，而刚刚我们觉得很完美的写法呢，其实是不合适的。 简单的说，继承和实现接口的区别就是：继承描述的是这个类『是什么』的问题，而实现的接口则描述的是这个类『能做什么』的问题。 Kotlin 与 Java 在能够运行在 JVM 这个问题上是一致的，可 Java 却不能像 Kotlin 那样去运行在前端，Kotlin 和 Java 运行在 JVM 上这个点只能算作一种能力，而不能对其本质定性。 于是我们在 Java 8 当中看到了接口默认实现的 Feature，于是我们的代码可以改改了： 123456789101112131415public interface JVMRunnable&#123; default void runOnJVM()&#123; ... &#125;&#125;public class Java extends Language implements JVMRunnable&#123;&#125;public class Kotlin extends Language implements JVMRunnable, FERunnable&#123; public void runOnFE()&#123; ... &#125;&#125; 这样很好，不过，由于接口无法保存状态，runOnJVM 这个方法的接口级默认实现仍然非常受限制。 那么 Kotlin 给我们带来什么呢？大家请看下面的代码： 123456789101112131415161718abstract class Languageinterface JVMRunnable&#123; fun runOnJVM()&#125;class DefaultJVMRunnable : JVMRunnable &#123; override fun runOnJVM() &#123; println(\"running on JVM!\") &#125;&#125;class Java(jvmRunnable: JVMRunnable) : Language(), JVMRunnable by jvmRunnableclass Kotlin(jvmRunnable: JVMRunnable) : Language(), JVMRunnable by jvmRunnable, FERunnable&#123; fun runOnFE()&#123; ... &#125;&#125; 通过接口代理的方式，我们把 JVMRunnable 的具体实现代理给了 jvmRunnable 这个实例，这个实例当然是可以保存状态的，它一方面可以很好地解决我们前面提到的接口默认实现的问题，另一方面也能在提供能力的同时不影响原有类的『本质』。","raw":null,"content":null,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.Kotliner.cn/categories/编程语言/"}],"tags":[{"name":"接口代理","slug":"接口代理","permalink":"http://www.Kotliner.cn/tags/接口代理/"},{"name":"多继承","slug":"多继承","permalink":"http://www.Kotliner.cn/tags/多继承/"}]},{"title":"[译]Learn Kotlin with “Advent of Code”","slug":"Learn Kotlin with “Advent of Code”","date":"2015-12-18T14:08:00.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2015/12/18/Learn Kotlin with “Advent of Code”/","link":"","permalink":"http://www.Kotliner.cn/2015/12/18/Learn Kotlin with “Advent of Code”/","excerpt":"","text":"圣诞节快到了！准备好了吗？是时候来一场与新语言的邂逅了！ 你已经解决了Eric Wastl上神奇的谜题集锦 “代码挑战” 了吗？得益于Kotlin具有函数式语言的特性，这些任务可以找到非常简洁而不失可读性的解决方案。尽力用kotlin去解决他们吧！ 你可以在IntelliJ IDEA社区版上完成你的解决方案，它是免费的，也原生支持Kotlin。也可以在浏览器上通过Kotlin playground解决任务。我们为“Advent of Code”添加了特殊模板： 祝你圣诞(Kotlin)快乐!","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"[译]Kotlin 1.0 Beta 3 发布啦!","slug":"Kotlin 1.0 Beta 3 is Out!","date":"2015-12-07T07:45:00.000Z","updated":"2017-05-22T02:30:56.890Z","comments":true,"path":"2015/12/07/Kotlin 1.0 Beta 3 is Out!/","link":"","permalink":"http://www.Kotliner.cn/2015/12/07/Kotlin 1.0 Beta 3 is Out!/","excerpt":"","text":"我们很高兴发布了 Kotlin 1.0 Beta 的另一个更新。我们正在努力完善标准库，抛弃了过时已久的设计结构，同时修复了 bugs，改进性能和为下一个版本作准备。完整的更新历史在 这里 。 最新的 issue 在 这里 。 Library 变更我们努力在 1.0 版本到来之前让标准库变得更加完美。这意味着进行一些尝试，所以会有新的部分被弃用，有新的函数被添加。我们计划在 1.0 版本（或 RC）中对标准库进行一次最后的清理：删除所有已过时和其他遗留的东西。这里我们只关心一个需要注意的变化：现在contains()和其他类似的扩展方法接受集合元素的父类型。 1234567// strs: Collection&lt;String&gt;// ns: String?// cs: CharSequence// i: Intstrs.contains(ns) // accepted nowstrs.contains(cs) // accepted nowstr.contains(i) // ERROR (in fact, a deprecation warning, but will be an error soon) 我们发现以前建议的containsRaw方法比较低效，使用contains()更加合适，同时保证了兼容性。请注意，集合接口本身是完整的，所有这些都是通过扩展功能完成的。请使用Code Cleanup来迁移代码。 语言变化一些需要注意的语言变化，完整列表在这里 。 许多我们以前不推荐的实现现在会报错。请使用Code Cleanup进行迁移。 When 表达式这种代码已被证明是有问题的，所以我们决定弃用它： 1234when &#123; foo.isValid(), foo.isReady() -&gt; process(foo) ...&#125; 许多人倾向于认为条件 foo.isValid(), foo.isReady() 表示 foo.isValid() == true and foo.isReady() == true，而实际上逗号是指 or。解决方法很简单：只需使用 ||: 1234when &#123; foo.isValid() || foo.isReady() -&gt; process(foo) ...&#125; Code Cleanup会自动迁移。 注释一个 bug 已被修复，现在我们可以在注解的参数中使用默认值： 12345annotation class Entry(val value: String) annotation class Example( val entries: Array&lt;Entry&gt; = arrayOf(Entry(\"a\"), Entry(\"b\")) // OK now) 枚举值()最近我们将传统的 Java 的Enum.values()更改为一个属性：Enum.values，但现在我们将回滚这个更改，因为有一个没有注意到的角落：枚举中的常量可能被命名为values，然后便没有办法访问其中的任何一个。我们考虑了不同的方案，最后决定将values改回函数是最干净的。所以，现在不推荐使用values属性，也不推荐使用values()函数。 可见性和作用域我们正在清理和修正小问题的可见性和作用域 companion objects 中允许 protected 成员 子类调用非 @JvmStatic 的 protected 对象将被标记为错误（不支持） 对于 open 属性，私有 setters 现在已被标记为过时 local sealed class 已弃用（从不可用） 重写的 setter 不能降低可见性 枚举类中不再允许存在内部类 lambdas / object literals / local 函数中禁止使用未初始化的变量 Android 扩展我们合并了 IntelliJ IDEA 的主要 Kotlin 插件和 Android 的Kotlin扩展插件。后者现在已经过时了，因为它的功能可以从 Kotlin 插件获取。此外，我们还添加了对 Android productFlavors的支持：现在，来自不同 flavors 的属性可以在不同的包中使用。例如，我们可以在build.gradle文件中存在两种 flavors： 12345678productFlavors &#123; free &#123; versionName \"1.0-free\" &#125; pro &#123; versionName \"1.0-pro\" &#125;&#125; 现在，我们不仅可以在main source set中的布局使用合成属性，还可以在 flavor 布局使用合成属性： 1234567891011121314// Import synthetic properties for the `activity_free.xml` layout in the `free` flavorimport kotlinx.android.synthetic.free.activity_free.versionMarker class FreeActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; ... setContentView(R.layout.activity_free) ... versionMarker.text = \"Free version\" &#125;&#125; 请注意，main source set的所有布局现在位于kotlinx.android.synthetic.main包之下，旧的包命名约定已被弃用。 IDE 中的新功能 Android Extensions 插件已被合并到 Kotlin 插件中，不再需要单独安装 创建新的 Gradle 工程时，添加了 Kotlin 的选项以供选择： 调试器：stacktrace 导航功能现在支持跟踪内联函数的堆栈帧。同时对内联函数的步进调试功能进行了一系列的改进。 添加了三个快速初始化新属性的Quick Fixes： Introduce Variable（Ctrl + Alt + V / Cmd + Alt + V）现在支持结构声明(multi-declarations)： 同时Introduce Variable还能使用于 lambda 或匿名函数中： Beta 3 开始支持在字符串模板中使用 Introduce Variable/Parameter/Property/Function 最后，添加了一个实验功能 —— 在 IDE 中对 Kotlin 脚本文件（.kts）做了基本的支持","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"[译]“Static constants” in Kotlin","slug":"“Static constants” in Kotlin","date":"2013-06-24T04:00:00.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2013/06/24/“Static constants” in Kotlin/","link":"","permalink":"http://www.Kotliner.cn/2013/06/24/“Static constants” in Kotlin/","excerpt":"","text":"“静态成员(static member)” 没有包含在Kotlin类的设计中，假设在类中有一个函数，那么该函数只能通过这个类的实例调用。而如果函数与任何类的实例并没有关联，那么就可以在类之外、包级进行定义（我们称之为包级函数–package-level functions）： 123package foo fun bar() &#123;&#125; 然而有时仍需要在类中使用静态常量：例如，要符合某些框架的要求或使用序列化，那么在kotlin中应该如何实现？Kotlin中有两种类似于Java的静态概念：上述的包级别函数以及类对象 。下面将简要解释类对象，然后继续讨论静态常量。 类对象一个类(非inner且非局部)或属性最多可以声明一个相关联的类对象。例如： 1234567class Foo &#123; class object &#123; val bar = 1 &#125; val baz = 2&#125; 上例中我们有创建类Foo，内部声明一个类对象，类对象中又含有成员属性bar。这意味着我们可以直接通过类名访问bar(与JAVA一样)： 1println(Foo.bar) 注意我们无法使用Foo的实例访问bar： 12val foo = Foo()println(foo.bar) // compilation error 因为bar并非Foo的成员，而是属于Foo的类对象；类对象是与所在的类相联的单独实体，并且不与其实例共享成员。因此也不能通过类名直接访问baz： 1prinltn(Foo.baz) // error 因为baz是Foo的成员，不属于它的类对象，所以只能通过Foo的实例访问baz。 现在，我们来看看类对象的工作原理。首先，存在一个为类对象单独生成的JVM类，bar便是该类的成员。假设用Java的方式访问类对象： 12/* Java */Foo.object$.getBar() 类对象是存储在它定义的类中的静态字段中的一个实例，其属性使用getter/setter访问。 静态常量类对象中的属性与静态字段相同（甚至更好），但仅限于Kotlin。如上所述，对于Java而言这是不同的，如果（在Java中）框架或约定要求您必须使用静态字段，则可能会引发问题。 免责声明：在Kotlin M5.3中，类是不可能存在静态字段的。但最近已经实现，所以只要你去每日最新版本尝试即可。 当对类对象使用public或internal访问修饰符，且不定义getter与setter时，Kotlin会自动将其直接存储在附属类中，所以在Java中可以用 1System.out.println(Foo.bar); 这对您的Kotlin代码而言没有任何区别：一切都能正常运行。即便在Java中老掉牙的Foo.object$.getBar()，但是现在也可以在你的类中使用真正的静态常量了。 感谢使用 Kotlin。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"[译]为什么 JetBrains 需要 Kotlin","slug":"Why JetBrains needs Kotlin","date":"2011-08-02T07:52:00.000Z","updated":"2017-05-22T02:30:56.921Z","comments":true,"path":"2011/08/02/Why JetBrains needs Kotlin/","link":"","permalink":"http://www.Kotliner.cn/2011/08/02/Why JetBrains needs Kotlin/","excerpt":"","text":"动机是人们在学习或使用新的编程语言时首先要问的问题。 Kotlin 文档对于这门语言为何出现已经做了相当详细的说明。尽管如此，我们还是乐于让大家更加清楚 JetBrains 希望从这门语言上获得什么。这门语言的开发显然是项长期的工作，我们明确意识到需要多年才能达成目标。而以下就是为什么我们愿意做这个投入的原因。 首先，这关乎我们自己的生产力。虽然我们已经为若干门 JVM 语言开发过工具，但都是基于 IntelliJ 的 IDE 完全用 Java 编写的。IntelliJ 构建系统基于 Groovy 和 Gant，同时 Groovy 也用于部分测试，RubyMine 中则有一些 JRuby 代码，这是目前的概况。我们希望通过切换到更具表现力的语言来提高生产力。同时，我们不希望这门语言存在与 Java 交互（新语言将逐步引入，需要与现有代码库顺畅地进行交互）或编译速度（我们的代码库需要使用 javac 编译很长的时间，任何程度的变慢我们都无法接受）方面的问题。 接着这点则十分简单明了：我们期望 Kotlin 推动 IntelliJ IDEA 的销售。我们正在开发一种新的语言，但是不打算让它替代 JVM 构建的整个生态系统。因此，您可以在使用 Kotlin 构建的项目中继续使用 Spring 和 Hibernate 或其他类似的框架。虽然 Kotlin 本身的开发工具将是免费的和开源的，但对企业开发框架和工具的支持仍将是 IDE 的商业版本 IntelliJ IDEA Ultimate 的一部分。所以使用 Kotlin 时也将获得完整的框架支持。 最后一点不太明显，但仍然很重要：新的编程语言是许多人喜欢谈论的话题，而我们公布 Kotlin 的那第一天就证明了这一点。许多熟悉 JetBrains 的人相信我们能够在这个项目中做得很好。因此我们相信对 JetBrains 的这种信任和日益增长的社区意识不仅将推动公司的业务发展，而且还将吸引更多的人来构建开发工具同时获得乐趣。 另外我们想重申：Kotlin 的工作并不会影响我们对其他开发工具的投入，特别是 Scala 插件。如果您已经对 Scala 感到满意，并且不需要另一种新语言，我们将继续尽力为您提供一流的 Scala 开发工具。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"[译] JVM 语言峰会上的演示幻灯片","slug":"Slides from the JVM Language Summit presentations","date":"2011-07-20T15:16:00.000Z","updated":"2017-05-22T02:30:56.906Z","comments":true,"path":"2011/07/20/Slides from the JVM Language Summit presentations/","link":"","permalink":"http://www.Kotliner.cn/2011/07/20/Slides from the JVM Language Summit presentations/","excerpt":"","text":"一个简短的说明：我们已经公开了 JVM 语言峰会上演示和研讨会时使用的幻灯片。其中 演示 涉及到高阶函数和类型安全的 Builder，而 研讨会 则涵盖了类、多继承、泛型和 Class objects。","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]},{"title":"[译]Hello World","slug":"Hello World","date":"2011-07-19T14:13:00.000Z","updated":"2017-05-22T02:30:56.890Z","comments":true,"path":"2011/07/19/Hello World/","link":"","permalink":"http://www.Kotliner.cn/2011/07/19/Hello World/","excerpt":"","text":"在今天的 JVM 语言峰会 上，JetBrains 公开了已经积极开发近一年的新项目 Kotlin，这是一门运行在 JVM 上的新静态类型编程语言。 凭借多年为不同语言创建开发工具的经验，我们希望能为当今的环境提供足够高效的语言，同时足够简单以便于普通程序员学习。 当前 Kotlin 正在积极开发中但是远未成熟，还不能提供给开发团队以外的人使用。现在能做的是阅读 语言文档 并留下关于语言设计的反馈——你喜欢哪些功能、哪些功能缺失、哪里令人困惑等等。 有一件事要注意：由于我们是一个开发工具公司，我们同时正在为 Kotlin 语言本身建立一流的 IDE 支持。一旦语言达到了 beta 阶段（目前计划在2011年底），我们会使用 Apache 2 许可证将编译器和开发工具开源。 我们接下来还有很多工作，很乐于听到你对我们最近努力成果的看法。所以让我们开始讨论吧！","raw":null,"content":null,"categories":[{"name":"官方动态","slug":"官方动态","permalink":"http://www.Kotliner.cn/categories/官方动态/"}],"tags":[]}]}